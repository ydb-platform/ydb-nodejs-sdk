/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["ydb-sdk"] || ($protobuf.roots["ydb-sdk"] = {});

$root.Ydb = (function() {

    /**
     * Namespace Ydb.
     * @exports Ydb
     * @namespace
     */
    var Ydb = {};

    Ydb.Cms = (function() {

        /**
         * Namespace Cms.
         * @memberof Ydb
         * @namespace
         */
        var Cms = {};

        Cms.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Cms
             * @namespace
             */
            var V1 = {};

            V1.CmsService = (function() {

                /**
                 * Constructs a new CmsService service.
                 * @memberof Ydb.Cms.V1
                 * @classdesc Represents a CmsService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function CmsService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (CmsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CmsService;

                /**
                 * Creates new CmsService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Cms.V1.CmsService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {CmsService} RPC service. Useful where requests and/or responses are streamed.
                 */
                CmsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Cms.V1.CmsService#createDatabase}.
                 * @memberof Ydb.Cms.V1.CmsService
                 * @typedef CreateDatabaseCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Cms.CreateDatabaseResponse} [response] CreateDatabaseResponse
                 */

                /**
                 * Calls CreateDatabase.
                 * @function createDatabase
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.ICreateDatabaseRequest} request CreateDatabaseRequest message or plain object
                 * @param {Ydb.Cms.V1.CmsService.CreateDatabaseCallback} callback Node-style callback called with the error, if any, and CreateDatabaseResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CmsService.prototype.createDatabase = function createDatabase(request, callback) {
                    return this.rpcCall(createDatabase, $root.Ydb.Cms.CreateDatabaseRequest, $root.Ydb.Cms.CreateDatabaseResponse, request, callback);
                }, "name", { value: "CreateDatabase" });

                /**
                 * Calls CreateDatabase.
                 * @function createDatabase
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.ICreateDatabaseRequest} request CreateDatabaseRequest message or plain object
                 * @returns {Promise<Ydb.Cms.CreateDatabaseResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Cms.V1.CmsService#getDatabaseStatus}.
                 * @memberof Ydb.Cms.V1.CmsService
                 * @typedef GetDatabaseStatusCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Cms.GetDatabaseStatusResponse} [response] GetDatabaseStatusResponse
                 */

                /**
                 * Calls GetDatabaseStatus.
                 * @function getDatabaseStatus
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IGetDatabaseStatusRequest} request GetDatabaseStatusRequest message or plain object
                 * @param {Ydb.Cms.V1.CmsService.GetDatabaseStatusCallback} callback Node-style callback called with the error, if any, and GetDatabaseStatusResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CmsService.prototype.getDatabaseStatus = function getDatabaseStatus(request, callback) {
                    return this.rpcCall(getDatabaseStatus, $root.Ydb.Cms.GetDatabaseStatusRequest, $root.Ydb.Cms.GetDatabaseStatusResponse, request, callback);
                }, "name", { value: "GetDatabaseStatus" });

                /**
                 * Calls GetDatabaseStatus.
                 * @function getDatabaseStatus
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IGetDatabaseStatusRequest} request GetDatabaseStatusRequest message or plain object
                 * @returns {Promise<Ydb.Cms.GetDatabaseStatusResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Cms.V1.CmsService#alterDatabase}.
                 * @memberof Ydb.Cms.V1.CmsService
                 * @typedef AlterDatabaseCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Cms.AlterDatabaseResponse} [response] AlterDatabaseResponse
                 */

                /**
                 * Calls AlterDatabase.
                 * @function alterDatabase
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IAlterDatabaseRequest} request AlterDatabaseRequest message or plain object
                 * @param {Ydb.Cms.V1.CmsService.AlterDatabaseCallback} callback Node-style callback called with the error, if any, and AlterDatabaseResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CmsService.prototype.alterDatabase = function alterDatabase(request, callback) {
                    return this.rpcCall(alterDatabase, $root.Ydb.Cms.AlterDatabaseRequest, $root.Ydb.Cms.AlterDatabaseResponse, request, callback);
                }, "name", { value: "AlterDatabase" });

                /**
                 * Calls AlterDatabase.
                 * @function alterDatabase
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IAlterDatabaseRequest} request AlterDatabaseRequest message or plain object
                 * @returns {Promise<Ydb.Cms.AlterDatabaseResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Cms.V1.CmsService#listDatabases}.
                 * @memberof Ydb.Cms.V1.CmsService
                 * @typedef ListDatabasesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Cms.ListDatabasesResponse} [response] ListDatabasesResponse
                 */

                /**
                 * Calls ListDatabases.
                 * @function listDatabases
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IListDatabasesRequest} request ListDatabasesRequest message or plain object
                 * @param {Ydb.Cms.V1.CmsService.ListDatabasesCallback} callback Node-style callback called with the error, if any, and ListDatabasesResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CmsService.prototype.listDatabases = function listDatabases(request, callback) {
                    return this.rpcCall(listDatabases, $root.Ydb.Cms.ListDatabasesRequest, $root.Ydb.Cms.ListDatabasesResponse, request, callback);
                }, "name", { value: "ListDatabases" });

                /**
                 * Calls ListDatabases.
                 * @function listDatabases
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IListDatabasesRequest} request ListDatabasesRequest message or plain object
                 * @returns {Promise<Ydb.Cms.ListDatabasesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Cms.V1.CmsService#removeDatabase}.
                 * @memberof Ydb.Cms.V1.CmsService
                 * @typedef RemoveDatabaseCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Cms.RemoveDatabaseResponse} [response] RemoveDatabaseResponse
                 */

                /**
                 * Calls RemoveDatabase.
                 * @function removeDatabase
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IRemoveDatabaseRequest} request RemoveDatabaseRequest message or plain object
                 * @param {Ydb.Cms.V1.CmsService.RemoveDatabaseCallback} callback Node-style callback called with the error, if any, and RemoveDatabaseResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CmsService.prototype.removeDatabase = function removeDatabase(request, callback) {
                    return this.rpcCall(removeDatabase, $root.Ydb.Cms.RemoveDatabaseRequest, $root.Ydb.Cms.RemoveDatabaseResponse, request, callback);
                }, "name", { value: "RemoveDatabase" });

                /**
                 * Calls RemoveDatabase.
                 * @function removeDatabase
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IRemoveDatabaseRequest} request RemoveDatabaseRequest message or plain object
                 * @returns {Promise<Ydb.Cms.RemoveDatabaseResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Cms.V1.CmsService#describeDatabaseOptions}.
                 * @memberof Ydb.Cms.V1.CmsService
                 * @typedef DescribeDatabaseOptionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Cms.DescribeDatabaseOptionsResponse} [response] DescribeDatabaseOptionsResponse
                 */

                /**
                 * Calls DescribeDatabaseOptions.
                 * @function describeDatabaseOptions
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IDescribeDatabaseOptionsRequest} request DescribeDatabaseOptionsRequest message or plain object
                 * @param {Ydb.Cms.V1.CmsService.DescribeDatabaseOptionsCallback} callback Node-style callback called with the error, if any, and DescribeDatabaseOptionsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CmsService.prototype.describeDatabaseOptions = function describeDatabaseOptions(request, callback) {
                    return this.rpcCall(describeDatabaseOptions, $root.Ydb.Cms.DescribeDatabaseOptionsRequest, $root.Ydb.Cms.DescribeDatabaseOptionsResponse, request, callback);
                }, "name", { value: "DescribeDatabaseOptions" });

                /**
                 * Calls DescribeDatabaseOptions.
                 * @function describeDatabaseOptions
                 * @memberof Ydb.Cms.V1.CmsService
                 * @instance
                 * @param {Ydb.Cms.IDescribeDatabaseOptionsRequest} request DescribeDatabaseOptionsRequest message or plain object
                 * @returns {Promise<Ydb.Cms.DescribeDatabaseOptionsResponse>} Promise
                 * @variation 2
                 */

                return CmsService;
            })();

            return V1;
        })();

        Cms.StorageUnits = (function() {

            /**
             * Properties of a StorageUnits.
             * @memberof Ydb.Cms
             * @interface IStorageUnits
             * @property {string|null} [unitKind] StorageUnits unitKind
             * @property {number|Long|null} [count] StorageUnits count
             */

            /**
             * Constructs a new StorageUnits.
             * @memberof Ydb.Cms
             * @classdesc Represents a StorageUnits.
             * @implements IStorageUnits
             * @constructor
             * @param {Ydb.Cms.IStorageUnits=} [properties] Properties to set
             */
            function StorageUnits(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StorageUnits unitKind.
             * @member {string} unitKind
             * @memberof Ydb.Cms.StorageUnits
             * @instance
             */
            StorageUnits.prototype.unitKind = "";

            /**
             * StorageUnits count.
             * @member {number|Long} count
             * @memberof Ydb.Cms.StorageUnits
             * @instance
             */
            StorageUnits.prototype.count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new StorageUnits instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.StorageUnits
             * @static
             * @param {Ydb.Cms.IStorageUnits=} [properties] Properties to set
             * @returns {Ydb.Cms.StorageUnits} StorageUnits instance
             */
            StorageUnits.create = function create(properties) {
                return new StorageUnits(properties);
            };

            /**
             * Encodes the specified StorageUnits message. Does not implicitly {@link Ydb.Cms.StorageUnits.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.StorageUnits
             * @static
             * @param {Ydb.Cms.IStorageUnits} message StorageUnits message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageUnits.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.unitKind != null && message.hasOwnProperty("unitKind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.unitKind);
                if (message.count != null && message.hasOwnProperty("count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.count);
                return writer;
            };

            /**
             * Encodes the specified StorageUnits message, length delimited. Does not implicitly {@link Ydb.Cms.StorageUnits.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.StorageUnits
             * @static
             * @param {Ydb.Cms.IStorageUnits} message StorageUnits message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageUnits.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StorageUnits message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.StorageUnits
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.StorageUnits} StorageUnits
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageUnits.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.StorageUnits();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.unitKind = reader.string();
                        break;
                    case 2:
                        message.count = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StorageUnits message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.StorageUnits
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.StorageUnits} StorageUnits
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageUnits.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StorageUnits message.
             * @function verify
             * @memberof Ydb.Cms.StorageUnits
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageUnits.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.unitKind != null && message.hasOwnProperty("unitKind"))
                    if (!$util.isString(message.unitKind))
                        return "unitKind: string expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                        return "count: integer|Long expected";
                return null;
            };

            /**
             * Creates a StorageUnits message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.StorageUnits
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.StorageUnits} StorageUnits
             */
            StorageUnits.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.StorageUnits)
                    return object;
                var message = new $root.Ydb.Cms.StorageUnits();
                if (object.unitKind != null)
                    message.unitKind = String(object.unitKind);
                if (object.count != null)
                    if ($util.Long)
                        (message.count = $util.Long.fromValue(object.count)).unsigned = true;
                    else if (typeof object.count === "string")
                        message.count = parseInt(object.count, 10);
                    else if (typeof object.count === "number")
                        message.count = object.count;
                    else if (typeof object.count === "object")
                        message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a StorageUnits message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.StorageUnits
             * @static
             * @param {Ydb.Cms.StorageUnits} message StorageUnits
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageUnits.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.unitKind = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.count = options.longs === String ? "0" : 0;
                }
                if (message.unitKind != null && message.hasOwnProperty("unitKind"))
                    object.unitKind = message.unitKind;
                if (message.count != null && message.hasOwnProperty("count"))
                    if (typeof message.count === "number")
                        object.count = options.longs === String ? String(message.count) : message.count;
                    else
                        object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;
                return object;
            };

            /**
             * Converts this StorageUnits to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.StorageUnits
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageUnits.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StorageUnits;
        })();

        Cms.ComputationalUnits = (function() {

            /**
             * Properties of a ComputationalUnits.
             * @memberof Ydb.Cms
             * @interface IComputationalUnits
             * @property {string|null} [unitKind] ComputationalUnits unitKind
             * @property {string|null} [availabilityZone] ComputationalUnits availabilityZone
             * @property {number|Long|null} [count] ComputationalUnits count
             */

            /**
             * Constructs a new ComputationalUnits.
             * @memberof Ydb.Cms
             * @classdesc Represents a ComputationalUnits.
             * @implements IComputationalUnits
             * @constructor
             * @param {Ydb.Cms.IComputationalUnits=} [properties] Properties to set
             */
            function ComputationalUnits(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComputationalUnits unitKind.
             * @member {string} unitKind
             * @memberof Ydb.Cms.ComputationalUnits
             * @instance
             */
            ComputationalUnits.prototype.unitKind = "";

            /**
             * ComputationalUnits availabilityZone.
             * @member {string} availabilityZone
             * @memberof Ydb.Cms.ComputationalUnits
             * @instance
             */
            ComputationalUnits.prototype.availabilityZone = "";

            /**
             * ComputationalUnits count.
             * @member {number|Long} count
             * @memberof Ydb.Cms.ComputationalUnits
             * @instance
             */
            ComputationalUnits.prototype.count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ComputationalUnits instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.ComputationalUnits
             * @static
             * @param {Ydb.Cms.IComputationalUnits=} [properties] Properties to set
             * @returns {Ydb.Cms.ComputationalUnits} ComputationalUnits instance
             */
            ComputationalUnits.create = function create(properties) {
                return new ComputationalUnits(properties);
            };

            /**
             * Encodes the specified ComputationalUnits message. Does not implicitly {@link Ydb.Cms.ComputationalUnits.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.ComputationalUnits
             * @static
             * @param {Ydb.Cms.IComputationalUnits} message ComputationalUnits message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputationalUnits.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.unitKind != null && message.hasOwnProperty("unitKind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.unitKind);
                if (message.availabilityZone != null && message.hasOwnProperty("availabilityZone"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.availabilityZone);
                if (message.count != null && message.hasOwnProperty("count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.count);
                return writer;
            };

            /**
             * Encodes the specified ComputationalUnits message, length delimited. Does not implicitly {@link Ydb.Cms.ComputationalUnits.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.ComputationalUnits
             * @static
             * @param {Ydb.Cms.IComputationalUnits} message ComputationalUnits message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputationalUnits.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComputationalUnits message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.ComputationalUnits
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.ComputationalUnits} ComputationalUnits
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputationalUnits.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.ComputationalUnits();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.unitKind = reader.string();
                        break;
                    case 2:
                        message.availabilityZone = reader.string();
                        break;
                    case 3:
                        message.count = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ComputationalUnits message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.ComputationalUnits
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.ComputationalUnits} ComputationalUnits
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputationalUnits.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComputationalUnits message.
             * @function verify
             * @memberof Ydb.Cms.ComputationalUnits
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComputationalUnits.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.unitKind != null && message.hasOwnProperty("unitKind"))
                    if (!$util.isString(message.unitKind))
                        return "unitKind: string expected";
                if (message.availabilityZone != null && message.hasOwnProperty("availabilityZone"))
                    if (!$util.isString(message.availabilityZone))
                        return "availabilityZone: string expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                        return "count: integer|Long expected";
                return null;
            };

            /**
             * Creates a ComputationalUnits message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.ComputationalUnits
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.ComputationalUnits} ComputationalUnits
             */
            ComputationalUnits.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.ComputationalUnits)
                    return object;
                var message = new $root.Ydb.Cms.ComputationalUnits();
                if (object.unitKind != null)
                    message.unitKind = String(object.unitKind);
                if (object.availabilityZone != null)
                    message.availabilityZone = String(object.availabilityZone);
                if (object.count != null)
                    if ($util.Long)
                        (message.count = $util.Long.fromValue(object.count)).unsigned = true;
                    else if (typeof object.count === "string")
                        message.count = parseInt(object.count, 10);
                    else if (typeof object.count === "number")
                        message.count = object.count;
                    else if (typeof object.count === "object")
                        message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ComputationalUnits message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.ComputationalUnits
             * @static
             * @param {Ydb.Cms.ComputationalUnits} message ComputationalUnits
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComputationalUnits.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.unitKind = "";
                    object.availabilityZone = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.count = options.longs === String ? "0" : 0;
                }
                if (message.unitKind != null && message.hasOwnProperty("unitKind"))
                    object.unitKind = message.unitKind;
                if (message.availabilityZone != null && message.hasOwnProperty("availabilityZone"))
                    object.availabilityZone = message.availabilityZone;
                if (message.count != null && message.hasOwnProperty("count"))
                    if (typeof message.count === "number")
                        object.count = options.longs === String ? String(message.count) : message.count;
                    else
                        object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;
                return object;
            };

            /**
             * Converts this ComputationalUnits to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.ComputationalUnits
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComputationalUnits.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ComputationalUnits;
        })();

        Cms.AllocatedComputationalUnit = (function() {

            /**
             * Properties of an AllocatedComputationalUnit.
             * @memberof Ydb.Cms
             * @interface IAllocatedComputationalUnit
             * @property {string|null} [host] AllocatedComputationalUnit host
             * @property {number|null} [port] AllocatedComputationalUnit port
             * @property {string|null} [unitKind] AllocatedComputationalUnit unitKind
             */

            /**
             * Constructs a new AllocatedComputationalUnit.
             * @memberof Ydb.Cms
             * @classdesc Represents an AllocatedComputationalUnit.
             * @implements IAllocatedComputationalUnit
             * @constructor
             * @param {Ydb.Cms.IAllocatedComputationalUnit=} [properties] Properties to set
             */
            function AllocatedComputationalUnit(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AllocatedComputationalUnit host.
             * @member {string} host
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @instance
             */
            AllocatedComputationalUnit.prototype.host = "";

            /**
             * AllocatedComputationalUnit port.
             * @member {number} port
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @instance
             */
            AllocatedComputationalUnit.prototype.port = 0;

            /**
             * AllocatedComputationalUnit unitKind.
             * @member {string} unitKind
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @instance
             */
            AllocatedComputationalUnit.prototype.unitKind = "";

            /**
             * Creates a new AllocatedComputationalUnit instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @static
             * @param {Ydb.Cms.IAllocatedComputationalUnit=} [properties] Properties to set
             * @returns {Ydb.Cms.AllocatedComputationalUnit} AllocatedComputationalUnit instance
             */
            AllocatedComputationalUnit.create = function create(properties) {
                return new AllocatedComputationalUnit(properties);
            };

            /**
             * Encodes the specified AllocatedComputationalUnit message. Does not implicitly {@link Ydb.Cms.AllocatedComputationalUnit.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @static
             * @param {Ydb.Cms.IAllocatedComputationalUnit} message AllocatedComputationalUnit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AllocatedComputationalUnit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.unitKind != null && message.hasOwnProperty("unitKind"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.unitKind);
                return writer;
            };

            /**
             * Encodes the specified AllocatedComputationalUnit message, length delimited. Does not implicitly {@link Ydb.Cms.AllocatedComputationalUnit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @static
             * @param {Ydb.Cms.IAllocatedComputationalUnit} message AllocatedComputationalUnit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AllocatedComputationalUnit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AllocatedComputationalUnit message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.AllocatedComputationalUnit} AllocatedComputationalUnit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AllocatedComputationalUnit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.AllocatedComputationalUnit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.host = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.unitKind = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AllocatedComputationalUnit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.AllocatedComputationalUnit} AllocatedComputationalUnit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AllocatedComputationalUnit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AllocatedComputationalUnit message.
             * @function verify
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AllocatedComputationalUnit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.unitKind != null && message.hasOwnProperty("unitKind"))
                    if (!$util.isString(message.unitKind))
                        return "unitKind: string expected";
                return null;
            };

            /**
             * Creates an AllocatedComputationalUnit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.AllocatedComputationalUnit} AllocatedComputationalUnit
             */
            AllocatedComputationalUnit.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.AllocatedComputationalUnit)
                    return object;
                var message = new $root.Ydb.Cms.AllocatedComputationalUnit();
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.unitKind != null)
                    message.unitKind = String(object.unitKind);
                return message;
            };

            /**
             * Creates a plain object from an AllocatedComputationalUnit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @static
             * @param {Ydb.Cms.AllocatedComputationalUnit} message AllocatedComputationalUnit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AllocatedComputationalUnit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.host = "";
                    object.port = 0;
                    object.unitKind = "";
                }
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.unitKind != null && message.hasOwnProperty("unitKind"))
                    object.unitKind = message.unitKind;
                return object;
            };

            /**
             * Converts this AllocatedComputationalUnit to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.AllocatedComputationalUnit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AllocatedComputationalUnit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AllocatedComputationalUnit;
        })();

        Cms.Resources = (function() {

            /**
             * Properties of a Resources.
             * @memberof Ydb.Cms
             * @interface IResources
             * @property {Array.<Ydb.Cms.IStorageUnits>|null} [storageUnits] Resources storageUnits
             * @property {Array.<Ydb.Cms.IComputationalUnits>|null} [computationalUnits] Resources computationalUnits
             */

            /**
             * Constructs a new Resources.
             * @memberof Ydb.Cms
             * @classdesc Represents a Resources.
             * @implements IResources
             * @constructor
             * @param {Ydb.Cms.IResources=} [properties] Properties to set
             */
            function Resources(properties) {
                this.storageUnits = [];
                this.computationalUnits = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Resources storageUnits.
             * @member {Array.<Ydb.Cms.IStorageUnits>} storageUnits
             * @memberof Ydb.Cms.Resources
             * @instance
             */
            Resources.prototype.storageUnits = $util.emptyArray;

            /**
             * Resources computationalUnits.
             * @member {Array.<Ydb.Cms.IComputationalUnits>} computationalUnits
             * @memberof Ydb.Cms.Resources
             * @instance
             */
            Resources.prototype.computationalUnits = $util.emptyArray;

            /**
             * Creates a new Resources instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.Resources
             * @static
             * @param {Ydb.Cms.IResources=} [properties] Properties to set
             * @returns {Ydb.Cms.Resources} Resources instance
             */
            Resources.create = function create(properties) {
                return new Resources(properties);
            };

            /**
             * Encodes the specified Resources message. Does not implicitly {@link Ydb.Cms.Resources.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.Resources
             * @static
             * @param {Ydb.Cms.IResources} message Resources message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Resources.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.storageUnits != null && message.storageUnits.length)
                    for (var i = 0; i < message.storageUnits.length; ++i)
                        $root.Ydb.Cms.StorageUnits.encode(message.storageUnits[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.computationalUnits != null && message.computationalUnits.length)
                    for (var i = 0; i < message.computationalUnits.length; ++i)
                        $root.Ydb.Cms.ComputationalUnits.encode(message.computationalUnits[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Resources message, length delimited. Does not implicitly {@link Ydb.Cms.Resources.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.Resources
             * @static
             * @param {Ydb.Cms.IResources} message Resources message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Resources.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Resources message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.Resources
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.Resources} Resources
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Resources.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.Resources();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.storageUnits && message.storageUnits.length))
                            message.storageUnits = [];
                        message.storageUnits.push($root.Ydb.Cms.StorageUnits.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.computationalUnits && message.computationalUnits.length))
                            message.computationalUnits = [];
                        message.computationalUnits.push($root.Ydb.Cms.ComputationalUnits.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Resources message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.Resources
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.Resources} Resources
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Resources.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Resources message.
             * @function verify
             * @memberof Ydb.Cms.Resources
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Resources.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.storageUnits != null && message.hasOwnProperty("storageUnits")) {
                    if (!Array.isArray(message.storageUnits))
                        return "storageUnits: array expected";
                    for (var i = 0; i < message.storageUnits.length; ++i) {
                        var error = $root.Ydb.Cms.StorageUnits.verify(message.storageUnits[i]);
                        if (error)
                            return "storageUnits." + error;
                    }
                }
                if (message.computationalUnits != null && message.hasOwnProperty("computationalUnits")) {
                    if (!Array.isArray(message.computationalUnits))
                        return "computationalUnits: array expected";
                    for (var i = 0; i < message.computationalUnits.length; ++i) {
                        var error = $root.Ydb.Cms.ComputationalUnits.verify(message.computationalUnits[i]);
                        if (error)
                            return "computationalUnits." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Resources message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.Resources
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.Resources} Resources
             */
            Resources.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.Resources)
                    return object;
                var message = new $root.Ydb.Cms.Resources();
                if (object.storageUnits) {
                    if (!Array.isArray(object.storageUnits))
                        throw TypeError(".Ydb.Cms.Resources.storageUnits: array expected");
                    message.storageUnits = [];
                    for (var i = 0; i < object.storageUnits.length; ++i) {
                        if (typeof object.storageUnits[i] !== "object")
                            throw TypeError(".Ydb.Cms.Resources.storageUnits: object expected");
                        message.storageUnits[i] = $root.Ydb.Cms.StorageUnits.fromObject(object.storageUnits[i]);
                    }
                }
                if (object.computationalUnits) {
                    if (!Array.isArray(object.computationalUnits))
                        throw TypeError(".Ydb.Cms.Resources.computationalUnits: array expected");
                    message.computationalUnits = [];
                    for (var i = 0; i < object.computationalUnits.length; ++i) {
                        if (typeof object.computationalUnits[i] !== "object")
                            throw TypeError(".Ydb.Cms.Resources.computationalUnits: object expected");
                        message.computationalUnits[i] = $root.Ydb.Cms.ComputationalUnits.fromObject(object.computationalUnits[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Resources message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.Resources
             * @static
             * @param {Ydb.Cms.Resources} message Resources
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Resources.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.storageUnits = [];
                    object.computationalUnits = [];
                }
                if (message.storageUnits && message.storageUnits.length) {
                    object.storageUnits = [];
                    for (var j = 0; j < message.storageUnits.length; ++j)
                        object.storageUnits[j] = $root.Ydb.Cms.StorageUnits.toObject(message.storageUnits[j], options);
                }
                if (message.computationalUnits && message.computationalUnits.length) {
                    object.computationalUnits = [];
                    for (var j = 0; j < message.computationalUnits.length; ++j)
                        object.computationalUnits[j] = $root.Ydb.Cms.ComputationalUnits.toObject(message.computationalUnits[j], options);
                }
                return object;
            };

            /**
             * Converts this Resources to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.Resources
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Resources.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Resources;
        })();

        Cms.DatabaseOptions = (function() {

            /**
             * Properties of a DatabaseOptions.
             * @memberof Ydb.Cms
             * @interface IDatabaseOptions
             * @property {boolean|null} [disableTxService] DatabaseOptions disableTxService
             * @property {boolean|null} [disableExternalSubdomain] DatabaseOptions disableExternalSubdomain
             */

            /**
             * Constructs a new DatabaseOptions.
             * @memberof Ydb.Cms
             * @classdesc Represents a DatabaseOptions.
             * @implements IDatabaseOptions
             * @constructor
             * @param {Ydb.Cms.IDatabaseOptions=} [properties] Properties to set
             */
            function DatabaseOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DatabaseOptions disableTxService.
             * @member {boolean} disableTxService
             * @memberof Ydb.Cms.DatabaseOptions
             * @instance
             */
            DatabaseOptions.prototype.disableTxService = false;

            /**
             * DatabaseOptions disableExternalSubdomain.
             * @member {boolean} disableExternalSubdomain
             * @memberof Ydb.Cms.DatabaseOptions
             * @instance
             */
            DatabaseOptions.prototype.disableExternalSubdomain = false;

            /**
             * Creates a new DatabaseOptions instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.DatabaseOptions
             * @static
             * @param {Ydb.Cms.IDatabaseOptions=} [properties] Properties to set
             * @returns {Ydb.Cms.DatabaseOptions} DatabaseOptions instance
             */
            DatabaseOptions.create = function create(properties) {
                return new DatabaseOptions(properties);
            };

            /**
             * Encodes the specified DatabaseOptions message. Does not implicitly {@link Ydb.Cms.DatabaseOptions.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.DatabaseOptions
             * @static
             * @param {Ydb.Cms.IDatabaseOptions} message DatabaseOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.disableTxService != null && message.hasOwnProperty("disableTxService"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.disableTxService);
                if (message.disableExternalSubdomain != null && message.hasOwnProperty("disableExternalSubdomain"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.disableExternalSubdomain);
                return writer;
            };

            /**
             * Encodes the specified DatabaseOptions message, length delimited. Does not implicitly {@link Ydb.Cms.DatabaseOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.DatabaseOptions
             * @static
             * @param {Ydb.Cms.IDatabaseOptions} message DatabaseOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseOptions message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.DatabaseOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.DatabaseOptions} DatabaseOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.DatabaseOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.disableTxService = reader.bool();
                        break;
                    case 2:
                        message.disableExternalSubdomain = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.DatabaseOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.DatabaseOptions} DatabaseOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseOptions message.
             * @function verify
             * @memberof Ydb.Cms.DatabaseOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.disableTxService != null && message.hasOwnProperty("disableTxService"))
                    if (typeof message.disableTxService !== "boolean")
                        return "disableTxService: boolean expected";
                if (message.disableExternalSubdomain != null && message.hasOwnProperty("disableExternalSubdomain"))
                    if (typeof message.disableExternalSubdomain !== "boolean")
                        return "disableExternalSubdomain: boolean expected";
                return null;
            };

            /**
             * Creates a DatabaseOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.DatabaseOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.DatabaseOptions} DatabaseOptions
             */
            DatabaseOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.DatabaseOptions)
                    return object;
                var message = new $root.Ydb.Cms.DatabaseOptions();
                if (object.disableTxService != null)
                    message.disableTxService = Boolean(object.disableTxService);
                if (object.disableExternalSubdomain != null)
                    message.disableExternalSubdomain = Boolean(object.disableExternalSubdomain);
                return message;
            };

            /**
             * Creates a plain object from a DatabaseOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.DatabaseOptions
             * @static
             * @param {Ydb.Cms.DatabaseOptions} message DatabaseOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.disableTxService = false;
                    object.disableExternalSubdomain = false;
                }
                if (message.disableTxService != null && message.hasOwnProperty("disableTxService"))
                    object.disableTxService = message.disableTxService;
                if (message.disableExternalSubdomain != null && message.hasOwnProperty("disableExternalSubdomain"))
                    object.disableExternalSubdomain = message.disableExternalSubdomain;
                return object;
            };

            /**
             * Converts this DatabaseOptions to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.DatabaseOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DatabaseOptions;
        })();

        Cms.Attribute = (function() {

            /**
             * Properties of an Attribute.
             * @memberof Ydb.Cms
             * @interface IAttribute
             * @property {string|null} [name] Attribute name
             * @property {string|null} [value] Attribute value
             */

            /**
             * Constructs a new Attribute.
             * @memberof Ydb.Cms
             * @classdesc Represents an Attribute.
             * @implements IAttribute
             * @constructor
             * @param {Ydb.Cms.IAttribute=} [properties] Properties to set
             */
            function Attribute(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Attribute name.
             * @member {string} name
             * @memberof Ydb.Cms.Attribute
             * @instance
             */
            Attribute.prototype.name = "";

            /**
             * Attribute value.
             * @member {string} value
             * @memberof Ydb.Cms.Attribute
             * @instance
             */
            Attribute.prototype.value = "";

            /**
             * Creates a new Attribute instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.Attribute
             * @static
             * @param {Ydb.Cms.IAttribute=} [properties] Properties to set
             * @returns {Ydb.Cms.Attribute} Attribute instance
             */
            Attribute.create = function create(properties) {
                return new Attribute(properties);
            };

            /**
             * Encodes the specified Attribute message. Does not implicitly {@link Ydb.Cms.Attribute.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.Attribute
             * @static
             * @param {Ydb.Cms.IAttribute} message Attribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attribute.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified Attribute message, length delimited. Does not implicitly {@link Ydb.Cms.Attribute.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.Attribute
             * @static
             * @param {Ydb.Cms.IAttribute} message Attribute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attribute.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Attribute message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.Attribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.Attribute} Attribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attribute.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.Attribute();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Attribute message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.Attribute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.Attribute} Attribute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attribute.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Attribute message.
             * @function verify
             * @memberof Ydb.Cms.Attribute
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Attribute.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates an Attribute message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.Attribute
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.Attribute} Attribute
             */
            Attribute.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.Attribute)
                    return object;
                var message = new $root.Ydb.Cms.Attribute();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from an Attribute message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.Attribute
             * @static
             * @param {Ydb.Cms.Attribute} message Attribute
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Attribute.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Attribute to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.Attribute
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Attribute.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Attribute;
        })();

        Cms.CreateDatabaseRequest = (function() {

            /**
             * Properties of a CreateDatabaseRequest.
             * @memberof Ydb.Cms
             * @interface ICreateDatabaseRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CreateDatabaseRequest operationParams
             * @property {string|null} [path] CreateDatabaseRequest path
             * @property {Ydb.Cms.IResources|null} [resources] CreateDatabaseRequest resources
             * @property {Ydb.Cms.IDatabaseOptions|null} [options] CreateDatabaseRequest options
             * @property {Array.<Ydb.Cms.IAttribute>|null} [attributes] CreateDatabaseRequest attributes
             */

            /**
             * Constructs a new CreateDatabaseRequest.
             * @memberof Ydb.Cms
             * @classdesc Represents a CreateDatabaseRequest.
             * @implements ICreateDatabaseRequest
             * @constructor
             * @param {Ydb.Cms.ICreateDatabaseRequest=} [properties] Properties to set
             */
            function CreateDatabaseRequest(properties) {
                this.attributes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateDatabaseRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @instance
             */
            CreateDatabaseRequest.prototype.operationParams = null;

            /**
             * CreateDatabaseRequest path.
             * @member {string} path
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @instance
             */
            CreateDatabaseRequest.prototype.path = "";

            /**
             * CreateDatabaseRequest resources.
             * @member {Ydb.Cms.IResources|null|undefined} resources
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @instance
             */
            CreateDatabaseRequest.prototype.resources = null;

            /**
             * CreateDatabaseRequest options.
             * @member {Ydb.Cms.IDatabaseOptions|null|undefined} options
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @instance
             */
            CreateDatabaseRequest.prototype.options = null;

            /**
             * CreateDatabaseRequest attributes.
             * @member {Array.<Ydb.Cms.IAttribute>} attributes
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @instance
             */
            CreateDatabaseRequest.prototype.attributes = $util.emptyArray;

            /**
             * Creates a new CreateDatabaseRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @static
             * @param {Ydb.Cms.ICreateDatabaseRequest=} [properties] Properties to set
             * @returns {Ydb.Cms.CreateDatabaseRequest} CreateDatabaseRequest instance
             */
            CreateDatabaseRequest.create = function create(properties) {
                return new CreateDatabaseRequest(properties);
            };

            /**
             * Encodes the specified CreateDatabaseRequest message. Does not implicitly {@link Ydb.Cms.CreateDatabaseRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @static
             * @param {Ydb.Cms.ICreateDatabaseRequest} message CreateDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateDatabaseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.resources != null && message.hasOwnProperty("resources"))
                    $root.Ydb.Cms.Resources.encode(message.resources, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.Ydb.Cms.DatabaseOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.attributes != null && message.attributes.length)
                    for (var i = 0; i < message.attributes.length; ++i)
                        $root.Ydb.Cms.Attribute.encode(message.attributes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateDatabaseRequest message, length delimited. Does not implicitly {@link Ydb.Cms.CreateDatabaseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @static
             * @param {Ydb.Cms.ICreateDatabaseRequest} message CreateDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateDatabaseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateDatabaseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.CreateDatabaseRequest} CreateDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateDatabaseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.CreateDatabaseRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 3:
                        message.resources = $root.Ydb.Cms.Resources.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.options = $root.Ydb.Cms.DatabaseOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.attributes && message.attributes.length))
                            message.attributes = [];
                        message.attributes.push($root.Ydb.Cms.Attribute.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateDatabaseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.CreateDatabaseRequest} CreateDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateDatabaseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateDatabaseRequest message.
             * @function verify
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateDatabaseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.resources != null && message.hasOwnProperty("resources")) {
                    var error = $root.Ydb.Cms.Resources.verify(message.resources);
                    if (error)
                        return "resources." + error;
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.Ydb.Cms.DatabaseOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!Array.isArray(message.attributes))
                        return "attributes: array expected";
                    for (var i = 0; i < message.attributes.length; ++i) {
                        var error = $root.Ydb.Cms.Attribute.verify(message.attributes[i]);
                        if (error)
                            return "attributes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CreateDatabaseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.CreateDatabaseRequest} CreateDatabaseRequest
             */
            CreateDatabaseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.CreateDatabaseRequest)
                    return object;
                var message = new $root.Ydb.Cms.CreateDatabaseRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Cms.CreateDatabaseRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                if (object.resources != null) {
                    if (typeof object.resources !== "object")
                        throw TypeError(".Ydb.Cms.CreateDatabaseRequest.resources: object expected");
                    message.resources = $root.Ydb.Cms.Resources.fromObject(object.resources);
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".Ydb.Cms.CreateDatabaseRequest.options: object expected");
                    message.options = $root.Ydb.Cms.DatabaseOptions.fromObject(object.options);
                }
                if (object.attributes) {
                    if (!Array.isArray(object.attributes))
                        throw TypeError(".Ydb.Cms.CreateDatabaseRequest.attributes: array expected");
                    message.attributes = [];
                    for (var i = 0; i < object.attributes.length; ++i) {
                        if (typeof object.attributes[i] !== "object")
                            throw TypeError(".Ydb.Cms.CreateDatabaseRequest.attributes: object expected");
                        message.attributes[i] = $root.Ydb.Cms.Attribute.fromObject(object.attributes[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateDatabaseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @static
             * @param {Ydb.Cms.CreateDatabaseRequest} message CreateDatabaseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateDatabaseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.attributes = [];
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                    object.resources = null;
                    object.options = null;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.resources != null && message.hasOwnProperty("resources"))
                    object.resources = $root.Ydb.Cms.Resources.toObject(message.resources, options);
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.Ydb.Cms.DatabaseOptions.toObject(message.options, options);
                if (message.attributes && message.attributes.length) {
                    object.attributes = [];
                    for (var j = 0; j < message.attributes.length; ++j)
                        object.attributes[j] = $root.Ydb.Cms.Attribute.toObject(message.attributes[j], options);
                }
                return object;
            };

            /**
             * Converts this CreateDatabaseRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.CreateDatabaseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateDatabaseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateDatabaseRequest;
        })();

        Cms.CreateDatabaseResponse = (function() {

            /**
             * Properties of a CreateDatabaseResponse.
             * @memberof Ydb.Cms
             * @interface ICreateDatabaseResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CreateDatabaseResponse operation
             */

            /**
             * Constructs a new CreateDatabaseResponse.
             * @memberof Ydb.Cms
             * @classdesc Represents a CreateDatabaseResponse.
             * @implements ICreateDatabaseResponse
             * @constructor
             * @param {Ydb.Cms.ICreateDatabaseResponse=} [properties] Properties to set
             */
            function CreateDatabaseResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateDatabaseResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @instance
             */
            CreateDatabaseResponse.prototype.operation = null;

            /**
             * Creates a new CreateDatabaseResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @static
             * @param {Ydb.Cms.ICreateDatabaseResponse=} [properties] Properties to set
             * @returns {Ydb.Cms.CreateDatabaseResponse} CreateDatabaseResponse instance
             */
            CreateDatabaseResponse.create = function create(properties) {
                return new CreateDatabaseResponse(properties);
            };

            /**
             * Encodes the specified CreateDatabaseResponse message. Does not implicitly {@link Ydb.Cms.CreateDatabaseResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @static
             * @param {Ydb.Cms.ICreateDatabaseResponse} message CreateDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateDatabaseResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateDatabaseResponse message, length delimited. Does not implicitly {@link Ydb.Cms.CreateDatabaseResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @static
             * @param {Ydb.Cms.ICreateDatabaseResponse} message CreateDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateDatabaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateDatabaseResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.CreateDatabaseResponse} CreateDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateDatabaseResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.CreateDatabaseResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateDatabaseResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.CreateDatabaseResponse} CreateDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateDatabaseResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateDatabaseResponse message.
             * @function verify
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateDatabaseResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CreateDatabaseResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.CreateDatabaseResponse} CreateDatabaseResponse
             */
            CreateDatabaseResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.CreateDatabaseResponse)
                    return object;
                var message = new $root.Ydb.Cms.CreateDatabaseResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Cms.CreateDatabaseResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateDatabaseResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @static
             * @param {Ydb.Cms.CreateDatabaseResponse} message CreateDatabaseResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateDatabaseResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CreateDatabaseResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.CreateDatabaseResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateDatabaseResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateDatabaseResponse;
        })();

        Cms.GetDatabaseStatusRequest = (function() {

            /**
             * Properties of a GetDatabaseStatusRequest.
             * @memberof Ydb.Cms
             * @interface IGetDatabaseStatusRequest
             * @property {string|null} [path] GetDatabaseStatusRequest path
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] GetDatabaseStatusRequest operationParams
             */

            /**
             * Constructs a new GetDatabaseStatusRequest.
             * @memberof Ydb.Cms
             * @classdesc Represents a GetDatabaseStatusRequest.
             * @implements IGetDatabaseStatusRequest
             * @constructor
             * @param {Ydb.Cms.IGetDatabaseStatusRequest=} [properties] Properties to set
             */
            function GetDatabaseStatusRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDatabaseStatusRequest path.
             * @member {string} path
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @instance
             */
            GetDatabaseStatusRequest.prototype.path = "";

            /**
             * GetDatabaseStatusRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @instance
             */
            GetDatabaseStatusRequest.prototype.operationParams = null;

            /**
             * Creates a new GetDatabaseStatusRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @static
             * @param {Ydb.Cms.IGetDatabaseStatusRequest=} [properties] Properties to set
             * @returns {Ydb.Cms.GetDatabaseStatusRequest} GetDatabaseStatusRequest instance
             */
            GetDatabaseStatusRequest.create = function create(properties) {
                return new GetDatabaseStatusRequest(properties);
            };

            /**
             * Encodes the specified GetDatabaseStatusRequest message. Does not implicitly {@link Ydb.Cms.GetDatabaseStatusRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @static
             * @param {Ydb.Cms.IGetDatabaseStatusRequest} message GetDatabaseStatusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDatabaseStatusRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetDatabaseStatusRequest message, length delimited. Does not implicitly {@link Ydb.Cms.GetDatabaseStatusRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @static
             * @param {Ydb.Cms.IGetDatabaseStatusRequest} message GetDatabaseStatusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDatabaseStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDatabaseStatusRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.GetDatabaseStatusRequest} GetDatabaseStatusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDatabaseStatusRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.GetDatabaseStatusRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDatabaseStatusRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.GetDatabaseStatusRequest} GetDatabaseStatusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDatabaseStatusRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDatabaseStatusRequest message.
             * @function verify
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDatabaseStatusRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a GetDatabaseStatusRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.GetDatabaseStatusRequest} GetDatabaseStatusRequest
             */
            GetDatabaseStatusRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.GetDatabaseStatusRequest)
                    return object;
                var message = new $root.Ydb.Cms.GetDatabaseStatusRequest();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Cms.GetDatabaseStatusRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetDatabaseStatusRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @static
             * @param {Ydb.Cms.GetDatabaseStatusRequest} message GetDatabaseStatusRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDatabaseStatusRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.operationParams = null;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this GetDatabaseStatusRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.GetDatabaseStatusRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDatabaseStatusRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetDatabaseStatusRequest;
        })();

        Cms.GetDatabaseStatusResponse = (function() {

            /**
             * Properties of a GetDatabaseStatusResponse.
             * @memberof Ydb.Cms
             * @interface IGetDatabaseStatusResponse
             * @property {Ydb.Operations.IOperation|null} [operation] GetDatabaseStatusResponse operation
             */

            /**
             * Constructs a new GetDatabaseStatusResponse.
             * @memberof Ydb.Cms
             * @classdesc Represents a GetDatabaseStatusResponse.
             * @implements IGetDatabaseStatusResponse
             * @constructor
             * @param {Ydb.Cms.IGetDatabaseStatusResponse=} [properties] Properties to set
             */
            function GetDatabaseStatusResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDatabaseStatusResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @instance
             */
            GetDatabaseStatusResponse.prototype.operation = null;

            /**
             * Creates a new GetDatabaseStatusResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @static
             * @param {Ydb.Cms.IGetDatabaseStatusResponse=} [properties] Properties to set
             * @returns {Ydb.Cms.GetDatabaseStatusResponse} GetDatabaseStatusResponse instance
             */
            GetDatabaseStatusResponse.create = function create(properties) {
                return new GetDatabaseStatusResponse(properties);
            };

            /**
             * Encodes the specified GetDatabaseStatusResponse message. Does not implicitly {@link Ydb.Cms.GetDatabaseStatusResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @static
             * @param {Ydb.Cms.IGetDatabaseStatusResponse} message GetDatabaseStatusResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDatabaseStatusResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetDatabaseStatusResponse message, length delimited. Does not implicitly {@link Ydb.Cms.GetDatabaseStatusResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @static
             * @param {Ydb.Cms.IGetDatabaseStatusResponse} message GetDatabaseStatusResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDatabaseStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDatabaseStatusResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.GetDatabaseStatusResponse} GetDatabaseStatusResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDatabaseStatusResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.GetDatabaseStatusResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDatabaseStatusResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.GetDatabaseStatusResponse} GetDatabaseStatusResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDatabaseStatusResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDatabaseStatusResponse message.
             * @function verify
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDatabaseStatusResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a GetDatabaseStatusResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.GetDatabaseStatusResponse} GetDatabaseStatusResponse
             */
            GetDatabaseStatusResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.GetDatabaseStatusResponse)
                    return object;
                var message = new $root.Ydb.Cms.GetDatabaseStatusResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Cms.GetDatabaseStatusResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetDatabaseStatusResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @static
             * @param {Ydb.Cms.GetDatabaseStatusResponse} message GetDatabaseStatusResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDatabaseStatusResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this GetDatabaseStatusResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.GetDatabaseStatusResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDatabaseStatusResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetDatabaseStatusResponse;
        })();

        Cms.GetDatabaseStatusResult = (function() {

            /**
             * Properties of a GetDatabaseStatusResult.
             * @memberof Ydb.Cms
             * @interface IGetDatabaseStatusResult
             * @property {string|null} [path] GetDatabaseStatusResult path
             * @property {Ydb.Cms.GetDatabaseStatusResult.State|null} [state] GetDatabaseStatusResult state
             * @property {Ydb.Cms.IResources|null} [requiredResources] GetDatabaseStatusResult requiredResources
             * @property {Ydb.Cms.IResources|null} [allocatedResources] GetDatabaseStatusResult allocatedResources
             * @property {Array.<Ydb.Cms.IAllocatedComputationalUnit>|null} [registeredResources] GetDatabaseStatusResult registeredResources
             * @property {number|Long|null} [generation] GetDatabaseStatusResult generation
             */

            /**
             * Constructs a new GetDatabaseStatusResult.
             * @memberof Ydb.Cms
             * @classdesc Represents a GetDatabaseStatusResult.
             * @implements IGetDatabaseStatusResult
             * @constructor
             * @param {Ydb.Cms.IGetDatabaseStatusResult=} [properties] Properties to set
             */
            function GetDatabaseStatusResult(properties) {
                this.registeredResources = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDatabaseStatusResult path.
             * @member {string} path
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @instance
             */
            GetDatabaseStatusResult.prototype.path = "";

            /**
             * GetDatabaseStatusResult state.
             * @member {Ydb.Cms.GetDatabaseStatusResult.State} state
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @instance
             */
            GetDatabaseStatusResult.prototype.state = 0;

            /**
             * GetDatabaseStatusResult requiredResources.
             * @member {Ydb.Cms.IResources|null|undefined} requiredResources
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @instance
             */
            GetDatabaseStatusResult.prototype.requiredResources = null;

            /**
             * GetDatabaseStatusResult allocatedResources.
             * @member {Ydb.Cms.IResources|null|undefined} allocatedResources
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @instance
             */
            GetDatabaseStatusResult.prototype.allocatedResources = null;

            /**
             * GetDatabaseStatusResult registeredResources.
             * @member {Array.<Ydb.Cms.IAllocatedComputationalUnit>} registeredResources
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @instance
             */
            GetDatabaseStatusResult.prototype.registeredResources = $util.emptyArray;

            /**
             * GetDatabaseStatusResult generation.
             * @member {number|Long} generation
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @instance
             */
            GetDatabaseStatusResult.prototype.generation = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetDatabaseStatusResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @static
             * @param {Ydb.Cms.IGetDatabaseStatusResult=} [properties] Properties to set
             * @returns {Ydb.Cms.GetDatabaseStatusResult} GetDatabaseStatusResult instance
             */
            GetDatabaseStatusResult.create = function create(properties) {
                return new GetDatabaseStatusResult(properties);
            };

            /**
             * Encodes the specified GetDatabaseStatusResult message. Does not implicitly {@link Ydb.Cms.GetDatabaseStatusResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @static
             * @param {Ydb.Cms.IGetDatabaseStatusResult} message GetDatabaseStatusResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDatabaseStatusResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.state != null && message.hasOwnProperty("state"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                if (message.requiredResources != null && message.hasOwnProperty("requiredResources"))
                    $root.Ydb.Cms.Resources.encode(message.requiredResources, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.allocatedResources != null && message.hasOwnProperty("allocatedResources"))
                    $root.Ydb.Cms.Resources.encode(message.allocatedResources, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.registeredResources != null && message.registeredResources.length)
                    for (var i = 0; i < message.registeredResources.length; ++i)
                        $root.Ydb.Cms.AllocatedComputationalUnit.encode(message.registeredResources[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.generation != null && message.hasOwnProperty("generation"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.generation);
                return writer;
            };

            /**
             * Encodes the specified GetDatabaseStatusResult message, length delimited. Does not implicitly {@link Ydb.Cms.GetDatabaseStatusResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @static
             * @param {Ydb.Cms.IGetDatabaseStatusResult} message GetDatabaseStatusResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDatabaseStatusResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDatabaseStatusResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.GetDatabaseStatusResult} GetDatabaseStatusResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDatabaseStatusResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.GetDatabaseStatusResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.state = reader.int32();
                        break;
                    case 3:
                        message.requiredResources = $root.Ydb.Cms.Resources.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.allocatedResources = $root.Ydb.Cms.Resources.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.registeredResources && message.registeredResources.length))
                            message.registeredResources = [];
                        message.registeredResources.push($root.Ydb.Cms.AllocatedComputationalUnit.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.generation = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDatabaseStatusResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.GetDatabaseStatusResult} GetDatabaseStatusResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDatabaseStatusResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDatabaseStatusResult message.
             * @function verify
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDatabaseStatusResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.requiredResources != null && message.hasOwnProperty("requiredResources")) {
                    var error = $root.Ydb.Cms.Resources.verify(message.requiredResources);
                    if (error)
                        return "requiredResources." + error;
                }
                if (message.allocatedResources != null && message.hasOwnProperty("allocatedResources")) {
                    var error = $root.Ydb.Cms.Resources.verify(message.allocatedResources);
                    if (error)
                        return "allocatedResources." + error;
                }
                if (message.registeredResources != null && message.hasOwnProperty("registeredResources")) {
                    if (!Array.isArray(message.registeredResources))
                        return "registeredResources: array expected";
                    for (var i = 0; i < message.registeredResources.length; ++i) {
                        var error = $root.Ydb.Cms.AllocatedComputationalUnit.verify(message.registeredResources[i]);
                        if (error)
                            return "registeredResources." + error;
                    }
                }
                if (message.generation != null && message.hasOwnProperty("generation"))
                    if (!$util.isInteger(message.generation) && !(message.generation && $util.isInteger(message.generation.low) && $util.isInteger(message.generation.high)))
                        return "generation: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetDatabaseStatusResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.GetDatabaseStatusResult} GetDatabaseStatusResult
             */
            GetDatabaseStatusResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.GetDatabaseStatusResult)
                    return object;
                var message = new $root.Ydb.Cms.GetDatabaseStatusResult();
                if (object.path != null)
                    message.path = String(object.path);
                switch (object.state) {
                case "STATE_UNSPECIFIED":
                case 0:
                    message.state = 0;
                    break;
                case "CREATING":
                case 1:
                    message.state = 1;
                    break;
                case "RUNNING":
                case 2:
                    message.state = 2;
                    break;
                case "REMOVING":
                case 3:
                    message.state = 3;
                    break;
                case "PENDING_RESOURCES":
                case 4:
                    message.state = 4;
                    break;
                }
                if (object.requiredResources != null) {
                    if (typeof object.requiredResources !== "object")
                        throw TypeError(".Ydb.Cms.GetDatabaseStatusResult.requiredResources: object expected");
                    message.requiredResources = $root.Ydb.Cms.Resources.fromObject(object.requiredResources);
                }
                if (object.allocatedResources != null) {
                    if (typeof object.allocatedResources !== "object")
                        throw TypeError(".Ydb.Cms.GetDatabaseStatusResult.allocatedResources: object expected");
                    message.allocatedResources = $root.Ydb.Cms.Resources.fromObject(object.allocatedResources);
                }
                if (object.registeredResources) {
                    if (!Array.isArray(object.registeredResources))
                        throw TypeError(".Ydb.Cms.GetDatabaseStatusResult.registeredResources: array expected");
                    message.registeredResources = [];
                    for (var i = 0; i < object.registeredResources.length; ++i) {
                        if (typeof object.registeredResources[i] !== "object")
                            throw TypeError(".Ydb.Cms.GetDatabaseStatusResult.registeredResources: object expected");
                        message.registeredResources[i] = $root.Ydb.Cms.AllocatedComputationalUnit.fromObject(object.registeredResources[i]);
                    }
                }
                if (object.generation != null)
                    if ($util.Long)
                        (message.generation = $util.Long.fromValue(object.generation)).unsigned = true;
                    else if (typeof object.generation === "string")
                        message.generation = parseInt(object.generation, 10);
                    else if (typeof object.generation === "number")
                        message.generation = object.generation;
                    else if (typeof object.generation === "object")
                        message.generation = new $util.LongBits(object.generation.low >>> 0, object.generation.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetDatabaseStatusResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @static
             * @param {Ydb.Cms.GetDatabaseStatusResult} message GetDatabaseStatusResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDatabaseStatusResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.registeredResources = [];
                if (options.defaults) {
                    object.path = "";
                    object.state = options.enums === String ? "STATE_UNSPECIFIED" : 0;
                    object.requiredResources = null;
                    object.allocatedResources = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.generation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.generation = options.longs === String ? "0" : 0;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.Ydb.Cms.GetDatabaseStatusResult.State[message.state] : message.state;
                if (message.requiredResources != null && message.hasOwnProperty("requiredResources"))
                    object.requiredResources = $root.Ydb.Cms.Resources.toObject(message.requiredResources, options);
                if (message.allocatedResources != null && message.hasOwnProperty("allocatedResources"))
                    object.allocatedResources = $root.Ydb.Cms.Resources.toObject(message.allocatedResources, options);
                if (message.registeredResources && message.registeredResources.length) {
                    object.registeredResources = [];
                    for (var j = 0; j < message.registeredResources.length; ++j)
                        object.registeredResources[j] = $root.Ydb.Cms.AllocatedComputationalUnit.toObject(message.registeredResources[j], options);
                }
                if (message.generation != null && message.hasOwnProperty("generation"))
                    if (typeof message.generation === "number")
                        object.generation = options.longs === String ? String(message.generation) : message.generation;
                    else
                        object.generation = options.longs === String ? $util.Long.prototype.toString.call(message.generation) : options.longs === Number ? new $util.LongBits(message.generation.low >>> 0, message.generation.high >>> 0).toNumber(true) : message.generation;
                return object;
            };

            /**
             * Converts this GetDatabaseStatusResult to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.GetDatabaseStatusResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDatabaseStatusResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * State enum.
             * @name Ydb.Cms.GetDatabaseStatusResult.State
             * @enum {string}
             * @property {number} STATE_UNSPECIFIED=0 STATE_UNSPECIFIED value
             * @property {number} CREATING=1 CREATING value
             * @property {number} RUNNING=2 RUNNING value
             * @property {number} REMOVING=3 REMOVING value
             * @property {number} PENDING_RESOURCES=4 PENDING_RESOURCES value
             */
            GetDatabaseStatusResult.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STATE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "CREATING"] = 1;
                values[valuesById[2] = "RUNNING"] = 2;
                values[valuesById[3] = "REMOVING"] = 3;
                values[valuesById[4] = "PENDING_RESOURCES"] = 4;
                return values;
            })();

            return GetDatabaseStatusResult;
        })();

        Cms.AlterDatabaseRequest = (function() {

            /**
             * Properties of an AlterDatabaseRequest.
             * @memberof Ydb.Cms
             * @interface IAlterDatabaseRequest
             * @property {string|null} [path] AlterDatabaseRequest path
             * @property {Array.<Ydb.Cms.IComputationalUnits>|null} [computationalUnitsToAdd] AlterDatabaseRequest computationalUnitsToAdd
             * @property {Array.<Ydb.Cms.IComputationalUnits>|null} [computationalUnitsToRemove] AlterDatabaseRequest computationalUnitsToRemove
             * @property {Array.<Ydb.Cms.IStorageUnits>|null} [storageUnitsToAdd] AlterDatabaseRequest storageUnitsToAdd
             * @property {Array.<Ydb.Cms.IAllocatedComputationalUnit>|null} [computationalUnitsToRegister] AlterDatabaseRequest computationalUnitsToRegister
             * @property {Array.<Ydb.Cms.IAllocatedComputationalUnit>|null} [computationalUnitsToDeregister] AlterDatabaseRequest computationalUnitsToDeregister
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] AlterDatabaseRequest operationParams
             * @property {number|Long|null} [generation] AlterDatabaseRequest generation
             */

            /**
             * Constructs a new AlterDatabaseRequest.
             * @memberof Ydb.Cms
             * @classdesc Represents an AlterDatabaseRequest.
             * @implements IAlterDatabaseRequest
             * @constructor
             * @param {Ydb.Cms.IAlterDatabaseRequest=} [properties] Properties to set
             */
            function AlterDatabaseRequest(properties) {
                this.computationalUnitsToAdd = [];
                this.computationalUnitsToRemove = [];
                this.storageUnitsToAdd = [];
                this.computationalUnitsToRegister = [];
                this.computationalUnitsToDeregister = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterDatabaseRequest path.
             * @member {string} path
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @instance
             */
            AlterDatabaseRequest.prototype.path = "";

            /**
             * AlterDatabaseRequest computationalUnitsToAdd.
             * @member {Array.<Ydb.Cms.IComputationalUnits>} computationalUnitsToAdd
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @instance
             */
            AlterDatabaseRequest.prototype.computationalUnitsToAdd = $util.emptyArray;

            /**
             * AlterDatabaseRequest computationalUnitsToRemove.
             * @member {Array.<Ydb.Cms.IComputationalUnits>} computationalUnitsToRemove
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @instance
             */
            AlterDatabaseRequest.prototype.computationalUnitsToRemove = $util.emptyArray;

            /**
             * AlterDatabaseRequest storageUnitsToAdd.
             * @member {Array.<Ydb.Cms.IStorageUnits>} storageUnitsToAdd
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @instance
             */
            AlterDatabaseRequest.prototype.storageUnitsToAdd = $util.emptyArray;

            /**
             * AlterDatabaseRequest computationalUnitsToRegister.
             * @member {Array.<Ydb.Cms.IAllocatedComputationalUnit>} computationalUnitsToRegister
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @instance
             */
            AlterDatabaseRequest.prototype.computationalUnitsToRegister = $util.emptyArray;

            /**
             * AlterDatabaseRequest computationalUnitsToDeregister.
             * @member {Array.<Ydb.Cms.IAllocatedComputationalUnit>} computationalUnitsToDeregister
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @instance
             */
            AlterDatabaseRequest.prototype.computationalUnitsToDeregister = $util.emptyArray;

            /**
             * AlterDatabaseRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @instance
             */
            AlterDatabaseRequest.prototype.operationParams = null;

            /**
             * AlterDatabaseRequest generation.
             * @member {number|Long} generation
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @instance
             */
            AlterDatabaseRequest.prototype.generation = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new AlterDatabaseRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @static
             * @param {Ydb.Cms.IAlterDatabaseRequest=} [properties] Properties to set
             * @returns {Ydb.Cms.AlterDatabaseRequest} AlterDatabaseRequest instance
             */
            AlterDatabaseRequest.create = function create(properties) {
                return new AlterDatabaseRequest(properties);
            };

            /**
             * Encodes the specified AlterDatabaseRequest message. Does not implicitly {@link Ydb.Cms.AlterDatabaseRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @static
             * @param {Ydb.Cms.IAlterDatabaseRequest} message AlterDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterDatabaseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.computationalUnitsToAdd != null && message.computationalUnitsToAdd.length)
                    for (var i = 0; i < message.computationalUnitsToAdd.length; ++i)
                        $root.Ydb.Cms.ComputationalUnits.encode(message.computationalUnitsToAdd[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.computationalUnitsToRemove != null && message.computationalUnitsToRemove.length)
                    for (var i = 0; i < message.computationalUnitsToRemove.length; ++i)
                        $root.Ydb.Cms.ComputationalUnits.encode(message.computationalUnitsToRemove[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.storageUnitsToAdd != null && message.storageUnitsToAdd.length)
                    for (var i = 0; i < message.storageUnitsToAdd.length; ++i)
                        $root.Ydb.Cms.StorageUnits.encode(message.storageUnitsToAdd[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.computationalUnitsToRegister != null && message.computationalUnitsToRegister.length)
                    for (var i = 0; i < message.computationalUnitsToRegister.length; ++i)
                        $root.Ydb.Cms.AllocatedComputationalUnit.encode(message.computationalUnitsToRegister[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.computationalUnitsToDeregister != null && message.computationalUnitsToDeregister.length)
                    for (var i = 0; i < message.computationalUnitsToDeregister.length; ++i)
                        $root.Ydb.Cms.AllocatedComputationalUnit.encode(message.computationalUnitsToDeregister[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.generation != null && message.hasOwnProperty("generation"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.generation);
                return writer;
            };

            /**
             * Encodes the specified AlterDatabaseRequest message, length delimited. Does not implicitly {@link Ydb.Cms.AlterDatabaseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @static
             * @param {Ydb.Cms.IAlterDatabaseRequest} message AlterDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterDatabaseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterDatabaseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.AlterDatabaseRequest} AlterDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterDatabaseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.AlterDatabaseRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        if (!(message.computationalUnitsToAdd && message.computationalUnitsToAdd.length))
                            message.computationalUnitsToAdd = [];
                        message.computationalUnitsToAdd.push($root.Ydb.Cms.ComputationalUnits.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.computationalUnitsToRemove && message.computationalUnitsToRemove.length))
                            message.computationalUnitsToRemove = [];
                        message.computationalUnitsToRemove.push($root.Ydb.Cms.ComputationalUnits.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.storageUnitsToAdd && message.storageUnitsToAdd.length))
                            message.storageUnitsToAdd = [];
                        message.storageUnitsToAdd.push($root.Ydb.Cms.StorageUnits.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.computationalUnitsToRegister && message.computationalUnitsToRegister.length))
                            message.computationalUnitsToRegister = [];
                        message.computationalUnitsToRegister.push($root.Ydb.Cms.AllocatedComputationalUnit.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.computationalUnitsToDeregister && message.computationalUnitsToDeregister.length))
                            message.computationalUnitsToDeregister = [];
                        message.computationalUnitsToDeregister.push($root.Ydb.Cms.AllocatedComputationalUnit.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.generation = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterDatabaseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.AlterDatabaseRequest} AlterDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterDatabaseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterDatabaseRequest message.
             * @function verify
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterDatabaseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.computationalUnitsToAdd != null && message.hasOwnProperty("computationalUnitsToAdd")) {
                    if (!Array.isArray(message.computationalUnitsToAdd))
                        return "computationalUnitsToAdd: array expected";
                    for (var i = 0; i < message.computationalUnitsToAdd.length; ++i) {
                        var error = $root.Ydb.Cms.ComputationalUnits.verify(message.computationalUnitsToAdd[i]);
                        if (error)
                            return "computationalUnitsToAdd." + error;
                    }
                }
                if (message.computationalUnitsToRemove != null && message.hasOwnProperty("computationalUnitsToRemove")) {
                    if (!Array.isArray(message.computationalUnitsToRemove))
                        return "computationalUnitsToRemove: array expected";
                    for (var i = 0; i < message.computationalUnitsToRemove.length; ++i) {
                        var error = $root.Ydb.Cms.ComputationalUnits.verify(message.computationalUnitsToRemove[i]);
                        if (error)
                            return "computationalUnitsToRemove." + error;
                    }
                }
                if (message.storageUnitsToAdd != null && message.hasOwnProperty("storageUnitsToAdd")) {
                    if (!Array.isArray(message.storageUnitsToAdd))
                        return "storageUnitsToAdd: array expected";
                    for (var i = 0; i < message.storageUnitsToAdd.length; ++i) {
                        var error = $root.Ydb.Cms.StorageUnits.verify(message.storageUnitsToAdd[i]);
                        if (error)
                            return "storageUnitsToAdd." + error;
                    }
                }
                if (message.computationalUnitsToRegister != null && message.hasOwnProperty("computationalUnitsToRegister")) {
                    if (!Array.isArray(message.computationalUnitsToRegister))
                        return "computationalUnitsToRegister: array expected";
                    for (var i = 0; i < message.computationalUnitsToRegister.length; ++i) {
                        var error = $root.Ydb.Cms.AllocatedComputationalUnit.verify(message.computationalUnitsToRegister[i]);
                        if (error)
                            return "computationalUnitsToRegister." + error;
                    }
                }
                if (message.computationalUnitsToDeregister != null && message.hasOwnProperty("computationalUnitsToDeregister")) {
                    if (!Array.isArray(message.computationalUnitsToDeregister))
                        return "computationalUnitsToDeregister: array expected";
                    for (var i = 0; i < message.computationalUnitsToDeregister.length; ++i) {
                        var error = $root.Ydb.Cms.AllocatedComputationalUnit.verify(message.computationalUnitsToDeregister[i]);
                        if (error)
                            return "computationalUnitsToDeregister." + error;
                    }
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.generation != null && message.hasOwnProperty("generation"))
                    if (!$util.isInteger(message.generation) && !(message.generation && $util.isInteger(message.generation.low) && $util.isInteger(message.generation.high)))
                        return "generation: integer|Long expected";
                return null;
            };

            /**
             * Creates an AlterDatabaseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.AlterDatabaseRequest} AlterDatabaseRequest
             */
            AlterDatabaseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.AlterDatabaseRequest)
                    return object;
                var message = new $root.Ydb.Cms.AlterDatabaseRequest();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.computationalUnitsToAdd) {
                    if (!Array.isArray(object.computationalUnitsToAdd))
                        throw TypeError(".Ydb.Cms.AlterDatabaseRequest.computationalUnitsToAdd: array expected");
                    message.computationalUnitsToAdd = [];
                    for (var i = 0; i < object.computationalUnitsToAdd.length; ++i) {
                        if (typeof object.computationalUnitsToAdd[i] !== "object")
                            throw TypeError(".Ydb.Cms.AlterDatabaseRequest.computationalUnitsToAdd: object expected");
                        message.computationalUnitsToAdd[i] = $root.Ydb.Cms.ComputationalUnits.fromObject(object.computationalUnitsToAdd[i]);
                    }
                }
                if (object.computationalUnitsToRemove) {
                    if (!Array.isArray(object.computationalUnitsToRemove))
                        throw TypeError(".Ydb.Cms.AlterDatabaseRequest.computationalUnitsToRemove: array expected");
                    message.computationalUnitsToRemove = [];
                    for (var i = 0; i < object.computationalUnitsToRemove.length; ++i) {
                        if (typeof object.computationalUnitsToRemove[i] !== "object")
                            throw TypeError(".Ydb.Cms.AlterDatabaseRequest.computationalUnitsToRemove: object expected");
                        message.computationalUnitsToRemove[i] = $root.Ydb.Cms.ComputationalUnits.fromObject(object.computationalUnitsToRemove[i]);
                    }
                }
                if (object.storageUnitsToAdd) {
                    if (!Array.isArray(object.storageUnitsToAdd))
                        throw TypeError(".Ydb.Cms.AlterDatabaseRequest.storageUnitsToAdd: array expected");
                    message.storageUnitsToAdd = [];
                    for (var i = 0; i < object.storageUnitsToAdd.length; ++i) {
                        if (typeof object.storageUnitsToAdd[i] !== "object")
                            throw TypeError(".Ydb.Cms.AlterDatabaseRequest.storageUnitsToAdd: object expected");
                        message.storageUnitsToAdd[i] = $root.Ydb.Cms.StorageUnits.fromObject(object.storageUnitsToAdd[i]);
                    }
                }
                if (object.computationalUnitsToRegister) {
                    if (!Array.isArray(object.computationalUnitsToRegister))
                        throw TypeError(".Ydb.Cms.AlterDatabaseRequest.computationalUnitsToRegister: array expected");
                    message.computationalUnitsToRegister = [];
                    for (var i = 0; i < object.computationalUnitsToRegister.length; ++i) {
                        if (typeof object.computationalUnitsToRegister[i] !== "object")
                            throw TypeError(".Ydb.Cms.AlterDatabaseRequest.computationalUnitsToRegister: object expected");
                        message.computationalUnitsToRegister[i] = $root.Ydb.Cms.AllocatedComputationalUnit.fromObject(object.computationalUnitsToRegister[i]);
                    }
                }
                if (object.computationalUnitsToDeregister) {
                    if (!Array.isArray(object.computationalUnitsToDeregister))
                        throw TypeError(".Ydb.Cms.AlterDatabaseRequest.computationalUnitsToDeregister: array expected");
                    message.computationalUnitsToDeregister = [];
                    for (var i = 0; i < object.computationalUnitsToDeregister.length; ++i) {
                        if (typeof object.computationalUnitsToDeregister[i] !== "object")
                            throw TypeError(".Ydb.Cms.AlterDatabaseRequest.computationalUnitsToDeregister: object expected");
                        message.computationalUnitsToDeregister[i] = $root.Ydb.Cms.AllocatedComputationalUnit.fromObject(object.computationalUnitsToDeregister[i]);
                    }
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Cms.AlterDatabaseRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.generation != null)
                    if ($util.Long)
                        (message.generation = $util.Long.fromValue(object.generation)).unsigned = true;
                    else if (typeof object.generation === "string")
                        message.generation = parseInt(object.generation, 10);
                    else if (typeof object.generation === "number")
                        message.generation = object.generation;
                    else if (typeof object.generation === "object")
                        message.generation = new $util.LongBits(object.generation.low >>> 0, object.generation.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an AlterDatabaseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @static
             * @param {Ydb.Cms.AlterDatabaseRequest} message AlterDatabaseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterDatabaseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.computationalUnitsToAdd = [];
                    object.computationalUnitsToRemove = [];
                    object.storageUnitsToAdd = [];
                    object.computationalUnitsToRegister = [];
                    object.computationalUnitsToDeregister = [];
                }
                if (options.defaults) {
                    object.path = "";
                    object.operationParams = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.generation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.generation = options.longs === String ? "0" : 0;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.computationalUnitsToAdd && message.computationalUnitsToAdd.length) {
                    object.computationalUnitsToAdd = [];
                    for (var j = 0; j < message.computationalUnitsToAdd.length; ++j)
                        object.computationalUnitsToAdd[j] = $root.Ydb.Cms.ComputationalUnits.toObject(message.computationalUnitsToAdd[j], options);
                }
                if (message.computationalUnitsToRemove && message.computationalUnitsToRemove.length) {
                    object.computationalUnitsToRemove = [];
                    for (var j = 0; j < message.computationalUnitsToRemove.length; ++j)
                        object.computationalUnitsToRemove[j] = $root.Ydb.Cms.ComputationalUnits.toObject(message.computationalUnitsToRemove[j], options);
                }
                if (message.storageUnitsToAdd && message.storageUnitsToAdd.length) {
                    object.storageUnitsToAdd = [];
                    for (var j = 0; j < message.storageUnitsToAdd.length; ++j)
                        object.storageUnitsToAdd[j] = $root.Ydb.Cms.StorageUnits.toObject(message.storageUnitsToAdd[j], options);
                }
                if (message.computationalUnitsToRegister && message.computationalUnitsToRegister.length) {
                    object.computationalUnitsToRegister = [];
                    for (var j = 0; j < message.computationalUnitsToRegister.length; ++j)
                        object.computationalUnitsToRegister[j] = $root.Ydb.Cms.AllocatedComputationalUnit.toObject(message.computationalUnitsToRegister[j], options);
                }
                if (message.computationalUnitsToDeregister && message.computationalUnitsToDeregister.length) {
                    object.computationalUnitsToDeregister = [];
                    for (var j = 0; j < message.computationalUnitsToDeregister.length; ++j)
                        object.computationalUnitsToDeregister[j] = $root.Ydb.Cms.AllocatedComputationalUnit.toObject(message.computationalUnitsToDeregister[j], options);
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.generation != null && message.hasOwnProperty("generation"))
                    if (typeof message.generation === "number")
                        object.generation = options.longs === String ? String(message.generation) : message.generation;
                    else
                        object.generation = options.longs === String ? $util.Long.prototype.toString.call(message.generation) : options.longs === Number ? new $util.LongBits(message.generation.low >>> 0, message.generation.high >>> 0).toNumber(true) : message.generation;
                return object;
            };

            /**
             * Converts this AlterDatabaseRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.AlterDatabaseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterDatabaseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterDatabaseRequest;
        })();

        Cms.AlterDatabaseResponse = (function() {

            /**
             * Properties of an AlterDatabaseResponse.
             * @memberof Ydb.Cms
             * @interface IAlterDatabaseResponse
             * @property {Ydb.Operations.IOperation|null} [operation] AlterDatabaseResponse operation
             */

            /**
             * Constructs a new AlterDatabaseResponse.
             * @memberof Ydb.Cms
             * @classdesc Represents an AlterDatabaseResponse.
             * @implements IAlterDatabaseResponse
             * @constructor
             * @param {Ydb.Cms.IAlterDatabaseResponse=} [properties] Properties to set
             */
            function AlterDatabaseResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterDatabaseResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @instance
             */
            AlterDatabaseResponse.prototype.operation = null;

            /**
             * Creates a new AlterDatabaseResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @static
             * @param {Ydb.Cms.IAlterDatabaseResponse=} [properties] Properties to set
             * @returns {Ydb.Cms.AlterDatabaseResponse} AlterDatabaseResponse instance
             */
            AlterDatabaseResponse.create = function create(properties) {
                return new AlterDatabaseResponse(properties);
            };

            /**
             * Encodes the specified AlterDatabaseResponse message. Does not implicitly {@link Ydb.Cms.AlterDatabaseResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @static
             * @param {Ydb.Cms.IAlterDatabaseResponse} message AlterDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterDatabaseResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlterDatabaseResponse message, length delimited. Does not implicitly {@link Ydb.Cms.AlterDatabaseResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @static
             * @param {Ydb.Cms.IAlterDatabaseResponse} message AlterDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterDatabaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterDatabaseResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.AlterDatabaseResponse} AlterDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterDatabaseResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.AlterDatabaseResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterDatabaseResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.AlterDatabaseResponse} AlterDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterDatabaseResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterDatabaseResponse message.
             * @function verify
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterDatabaseResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an AlterDatabaseResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.AlterDatabaseResponse} AlterDatabaseResponse
             */
            AlterDatabaseResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.AlterDatabaseResponse)
                    return object;
                var message = new $root.Ydb.Cms.AlterDatabaseResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Cms.AlterDatabaseResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlterDatabaseResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @static
             * @param {Ydb.Cms.AlterDatabaseResponse} message AlterDatabaseResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterDatabaseResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this AlterDatabaseResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.AlterDatabaseResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterDatabaseResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterDatabaseResponse;
        })();

        Cms.ListDatabasesRequest = (function() {

            /**
             * Properties of a ListDatabasesRequest.
             * @memberof Ydb.Cms
             * @interface IListDatabasesRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ListDatabasesRequest operationParams
             */

            /**
             * Constructs a new ListDatabasesRequest.
             * @memberof Ydb.Cms
             * @classdesc Represents a ListDatabasesRequest.
             * @implements IListDatabasesRequest
             * @constructor
             * @param {Ydb.Cms.IListDatabasesRequest=} [properties] Properties to set
             */
            function ListDatabasesRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListDatabasesRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @instance
             */
            ListDatabasesRequest.prototype.operationParams = null;

            /**
             * Creates a new ListDatabasesRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @static
             * @param {Ydb.Cms.IListDatabasesRequest=} [properties] Properties to set
             * @returns {Ydb.Cms.ListDatabasesRequest} ListDatabasesRequest instance
             */
            ListDatabasesRequest.create = function create(properties) {
                return new ListDatabasesRequest(properties);
            };

            /**
             * Encodes the specified ListDatabasesRequest message. Does not implicitly {@link Ydb.Cms.ListDatabasesRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @static
             * @param {Ydb.Cms.IListDatabasesRequest} message ListDatabasesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDatabasesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListDatabasesRequest message, length delimited. Does not implicitly {@link Ydb.Cms.ListDatabasesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @static
             * @param {Ydb.Cms.IListDatabasesRequest} message ListDatabasesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDatabasesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListDatabasesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.ListDatabasesRequest} ListDatabasesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDatabasesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.ListDatabasesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListDatabasesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.ListDatabasesRequest} ListDatabasesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDatabasesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListDatabasesRequest message.
             * @function verify
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListDatabasesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a ListDatabasesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.ListDatabasesRequest} ListDatabasesRequest
             */
            ListDatabasesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.ListDatabasesRequest)
                    return object;
                var message = new $root.Ydb.Cms.ListDatabasesRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Cms.ListDatabasesRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListDatabasesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @static
             * @param {Ydb.Cms.ListDatabasesRequest} message ListDatabasesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListDatabasesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operationParams = null;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this ListDatabasesRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.ListDatabasesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListDatabasesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListDatabasesRequest;
        })();

        Cms.ListDatabasesResponse = (function() {

            /**
             * Properties of a ListDatabasesResponse.
             * @memberof Ydb.Cms
             * @interface IListDatabasesResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ListDatabasesResponse operation
             */

            /**
             * Constructs a new ListDatabasesResponse.
             * @memberof Ydb.Cms
             * @classdesc Represents a ListDatabasesResponse.
             * @implements IListDatabasesResponse
             * @constructor
             * @param {Ydb.Cms.IListDatabasesResponse=} [properties] Properties to set
             */
            function ListDatabasesResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListDatabasesResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @instance
             */
            ListDatabasesResponse.prototype.operation = null;

            /**
             * Creates a new ListDatabasesResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @static
             * @param {Ydb.Cms.IListDatabasesResponse=} [properties] Properties to set
             * @returns {Ydb.Cms.ListDatabasesResponse} ListDatabasesResponse instance
             */
            ListDatabasesResponse.create = function create(properties) {
                return new ListDatabasesResponse(properties);
            };

            /**
             * Encodes the specified ListDatabasesResponse message. Does not implicitly {@link Ydb.Cms.ListDatabasesResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @static
             * @param {Ydb.Cms.IListDatabasesResponse} message ListDatabasesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDatabasesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListDatabasesResponse message, length delimited. Does not implicitly {@link Ydb.Cms.ListDatabasesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @static
             * @param {Ydb.Cms.IListDatabasesResponse} message ListDatabasesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDatabasesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListDatabasesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.ListDatabasesResponse} ListDatabasesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDatabasesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.ListDatabasesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListDatabasesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.ListDatabasesResponse} ListDatabasesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDatabasesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListDatabasesResponse message.
             * @function verify
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListDatabasesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a ListDatabasesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.ListDatabasesResponse} ListDatabasesResponse
             */
            ListDatabasesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.ListDatabasesResponse)
                    return object;
                var message = new $root.Ydb.Cms.ListDatabasesResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Cms.ListDatabasesResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListDatabasesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @static
             * @param {Ydb.Cms.ListDatabasesResponse} message ListDatabasesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListDatabasesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ListDatabasesResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.ListDatabasesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListDatabasesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListDatabasesResponse;
        })();

        Cms.ListDatabasesResult = (function() {

            /**
             * Properties of a ListDatabasesResult.
             * @memberof Ydb.Cms
             * @interface IListDatabasesResult
             * @property {Array.<string>|null} [paths] ListDatabasesResult paths
             */

            /**
             * Constructs a new ListDatabasesResult.
             * @memberof Ydb.Cms
             * @classdesc Represents a ListDatabasesResult.
             * @implements IListDatabasesResult
             * @constructor
             * @param {Ydb.Cms.IListDatabasesResult=} [properties] Properties to set
             */
            function ListDatabasesResult(properties) {
                this.paths = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListDatabasesResult paths.
             * @member {Array.<string>} paths
             * @memberof Ydb.Cms.ListDatabasesResult
             * @instance
             */
            ListDatabasesResult.prototype.paths = $util.emptyArray;

            /**
             * Creates a new ListDatabasesResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.ListDatabasesResult
             * @static
             * @param {Ydb.Cms.IListDatabasesResult=} [properties] Properties to set
             * @returns {Ydb.Cms.ListDatabasesResult} ListDatabasesResult instance
             */
            ListDatabasesResult.create = function create(properties) {
                return new ListDatabasesResult(properties);
            };

            /**
             * Encodes the specified ListDatabasesResult message. Does not implicitly {@link Ydb.Cms.ListDatabasesResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.ListDatabasesResult
             * @static
             * @param {Ydb.Cms.IListDatabasesResult} message ListDatabasesResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDatabasesResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.paths != null && message.paths.length)
                    for (var i = 0; i < message.paths.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.paths[i]);
                return writer;
            };

            /**
             * Encodes the specified ListDatabasesResult message, length delimited. Does not implicitly {@link Ydb.Cms.ListDatabasesResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.ListDatabasesResult
             * @static
             * @param {Ydb.Cms.IListDatabasesResult} message ListDatabasesResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDatabasesResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListDatabasesResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.ListDatabasesResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.ListDatabasesResult} ListDatabasesResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDatabasesResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.ListDatabasesResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.paths && message.paths.length))
                            message.paths = [];
                        message.paths.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListDatabasesResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.ListDatabasesResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.ListDatabasesResult} ListDatabasesResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDatabasesResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListDatabasesResult message.
             * @function verify
             * @memberof Ydb.Cms.ListDatabasesResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListDatabasesResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.paths != null && message.hasOwnProperty("paths")) {
                    if (!Array.isArray(message.paths))
                        return "paths: array expected";
                    for (var i = 0; i < message.paths.length; ++i)
                        if (!$util.isString(message.paths[i]))
                            return "paths: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ListDatabasesResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.ListDatabasesResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.ListDatabasesResult} ListDatabasesResult
             */
            ListDatabasesResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.ListDatabasesResult)
                    return object;
                var message = new $root.Ydb.Cms.ListDatabasesResult();
                if (object.paths) {
                    if (!Array.isArray(object.paths))
                        throw TypeError(".Ydb.Cms.ListDatabasesResult.paths: array expected");
                    message.paths = [];
                    for (var i = 0; i < object.paths.length; ++i)
                        message.paths[i] = String(object.paths[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListDatabasesResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.ListDatabasesResult
             * @static
             * @param {Ydb.Cms.ListDatabasesResult} message ListDatabasesResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListDatabasesResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.paths = [];
                if (message.paths && message.paths.length) {
                    object.paths = [];
                    for (var j = 0; j < message.paths.length; ++j)
                        object.paths[j] = message.paths[j];
                }
                return object;
            };

            /**
             * Converts this ListDatabasesResult to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.ListDatabasesResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListDatabasesResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListDatabasesResult;
        })();

        Cms.RemoveDatabaseRequest = (function() {

            /**
             * Properties of a RemoveDatabaseRequest.
             * @memberof Ydb.Cms
             * @interface IRemoveDatabaseRequest
             * @property {string|null} [path] RemoveDatabaseRequest path
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] RemoveDatabaseRequest operationParams
             */

            /**
             * Constructs a new RemoveDatabaseRequest.
             * @memberof Ydb.Cms
             * @classdesc Represents a RemoveDatabaseRequest.
             * @implements IRemoveDatabaseRequest
             * @constructor
             * @param {Ydb.Cms.IRemoveDatabaseRequest=} [properties] Properties to set
             */
            function RemoveDatabaseRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RemoveDatabaseRequest path.
             * @member {string} path
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @instance
             */
            RemoveDatabaseRequest.prototype.path = "";

            /**
             * RemoveDatabaseRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @instance
             */
            RemoveDatabaseRequest.prototype.operationParams = null;

            /**
             * Creates a new RemoveDatabaseRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @static
             * @param {Ydb.Cms.IRemoveDatabaseRequest=} [properties] Properties to set
             * @returns {Ydb.Cms.RemoveDatabaseRequest} RemoveDatabaseRequest instance
             */
            RemoveDatabaseRequest.create = function create(properties) {
                return new RemoveDatabaseRequest(properties);
            };

            /**
             * Encodes the specified RemoveDatabaseRequest message. Does not implicitly {@link Ydb.Cms.RemoveDatabaseRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @static
             * @param {Ydb.Cms.IRemoveDatabaseRequest} message RemoveDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDatabaseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RemoveDatabaseRequest message, length delimited. Does not implicitly {@link Ydb.Cms.RemoveDatabaseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @static
             * @param {Ydb.Cms.IRemoveDatabaseRequest} message RemoveDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDatabaseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RemoveDatabaseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.RemoveDatabaseRequest} RemoveDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDatabaseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.RemoveDatabaseRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RemoveDatabaseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.RemoveDatabaseRequest} RemoveDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDatabaseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RemoveDatabaseRequest message.
             * @function verify
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoveDatabaseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a RemoveDatabaseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.RemoveDatabaseRequest} RemoveDatabaseRequest
             */
            RemoveDatabaseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.RemoveDatabaseRequest)
                    return object;
                var message = new $root.Ydb.Cms.RemoveDatabaseRequest();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Cms.RemoveDatabaseRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a RemoveDatabaseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @static
             * @param {Ydb.Cms.RemoveDatabaseRequest} message RemoveDatabaseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoveDatabaseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.operationParams = null;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this RemoveDatabaseRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.RemoveDatabaseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoveDatabaseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RemoveDatabaseRequest;
        })();

        Cms.RemoveDatabaseResponse = (function() {

            /**
             * Properties of a RemoveDatabaseResponse.
             * @memberof Ydb.Cms
             * @interface IRemoveDatabaseResponse
             * @property {Ydb.Operations.IOperation|null} [operation] RemoveDatabaseResponse operation
             */

            /**
             * Constructs a new RemoveDatabaseResponse.
             * @memberof Ydb.Cms
             * @classdesc Represents a RemoveDatabaseResponse.
             * @implements IRemoveDatabaseResponse
             * @constructor
             * @param {Ydb.Cms.IRemoveDatabaseResponse=} [properties] Properties to set
             */
            function RemoveDatabaseResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RemoveDatabaseResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @instance
             */
            RemoveDatabaseResponse.prototype.operation = null;

            /**
             * Creates a new RemoveDatabaseResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @static
             * @param {Ydb.Cms.IRemoveDatabaseResponse=} [properties] Properties to set
             * @returns {Ydb.Cms.RemoveDatabaseResponse} RemoveDatabaseResponse instance
             */
            RemoveDatabaseResponse.create = function create(properties) {
                return new RemoveDatabaseResponse(properties);
            };

            /**
             * Encodes the specified RemoveDatabaseResponse message. Does not implicitly {@link Ydb.Cms.RemoveDatabaseResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @static
             * @param {Ydb.Cms.IRemoveDatabaseResponse} message RemoveDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDatabaseResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RemoveDatabaseResponse message, length delimited. Does not implicitly {@link Ydb.Cms.RemoveDatabaseResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @static
             * @param {Ydb.Cms.IRemoveDatabaseResponse} message RemoveDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDatabaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RemoveDatabaseResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.RemoveDatabaseResponse} RemoveDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDatabaseResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.RemoveDatabaseResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RemoveDatabaseResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.RemoveDatabaseResponse} RemoveDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDatabaseResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RemoveDatabaseResponse message.
             * @function verify
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoveDatabaseResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a RemoveDatabaseResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.RemoveDatabaseResponse} RemoveDatabaseResponse
             */
            RemoveDatabaseResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.RemoveDatabaseResponse)
                    return object;
                var message = new $root.Ydb.Cms.RemoveDatabaseResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Cms.RemoveDatabaseResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a RemoveDatabaseResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @static
             * @param {Ydb.Cms.RemoveDatabaseResponse} message RemoveDatabaseResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoveDatabaseResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this RemoveDatabaseResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.RemoveDatabaseResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoveDatabaseResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RemoveDatabaseResponse;
        })();

        Cms.StorageUnitDescription = (function() {

            /**
             * Properties of a StorageUnitDescription.
             * @memberof Ydb.Cms
             * @interface IStorageUnitDescription
             * @property {string|null} [kind] StorageUnitDescription kind
             * @property {Object.<string,string>|null} [labels] StorageUnitDescription labels
             */

            /**
             * Constructs a new StorageUnitDescription.
             * @memberof Ydb.Cms
             * @classdesc Represents a StorageUnitDescription.
             * @implements IStorageUnitDescription
             * @constructor
             * @param {Ydb.Cms.IStorageUnitDescription=} [properties] Properties to set
             */
            function StorageUnitDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StorageUnitDescription kind.
             * @member {string} kind
             * @memberof Ydb.Cms.StorageUnitDescription
             * @instance
             */
            StorageUnitDescription.prototype.kind = "";

            /**
             * StorageUnitDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Cms.StorageUnitDescription
             * @instance
             */
            StorageUnitDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new StorageUnitDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.StorageUnitDescription
             * @static
             * @param {Ydb.Cms.IStorageUnitDescription=} [properties] Properties to set
             * @returns {Ydb.Cms.StorageUnitDescription} StorageUnitDescription instance
             */
            StorageUnitDescription.create = function create(properties) {
                return new StorageUnitDescription(properties);
            };

            /**
             * Encodes the specified StorageUnitDescription message. Does not implicitly {@link Ydb.Cms.StorageUnitDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.StorageUnitDescription
             * @static
             * @param {Ydb.Cms.IStorageUnitDescription} message StorageUnitDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageUnitDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StorageUnitDescription message, length delimited. Does not implicitly {@link Ydb.Cms.StorageUnitDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.StorageUnitDescription
             * @static
             * @param {Ydb.Cms.IStorageUnitDescription} message StorageUnitDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageUnitDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StorageUnitDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.StorageUnitDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.StorageUnitDescription} StorageUnitDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageUnitDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.StorageUnitDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StorageUnitDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.StorageUnitDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.StorageUnitDescription} StorageUnitDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageUnitDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StorageUnitDescription message.
             * @function verify
             * @memberof Ydb.Cms.StorageUnitDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageUnitDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a StorageUnitDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.StorageUnitDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.StorageUnitDescription} StorageUnitDescription
             */
            StorageUnitDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.StorageUnitDescription)
                    return object;
                var message = new $root.Ydb.Cms.StorageUnitDescription();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Cms.StorageUnitDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a StorageUnitDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.StorageUnitDescription
             * @static
             * @param {Ydb.Cms.StorageUnitDescription} message StorageUnitDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageUnitDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.kind = "";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this StorageUnitDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.StorageUnitDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageUnitDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StorageUnitDescription;
        })();

        Cms.AvailabilityZoneDescription = (function() {

            /**
             * Properties of an AvailabilityZoneDescription.
             * @memberof Ydb.Cms
             * @interface IAvailabilityZoneDescription
             * @property {string|null} [name] AvailabilityZoneDescription name
             * @property {Object.<string,string>|null} [labels] AvailabilityZoneDescription labels
             */

            /**
             * Constructs a new AvailabilityZoneDescription.
             * @memberof Ydb.Cms
             * @classdesc Represents an AvailabilityZoneDescription.
             * @implements IAvailabilityZoneDescription
             * @constructor
             * @param {Ydb.Cms.IAvailabilityZoneDescription=} [properties] Properties to set
             */
            function AvailabilityZoneDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AvailabilityZoneDescription name.
             * @member {string} name
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @instance
             */
            AvailabilityZoneDescription.prototype.name = "";

            /**
             * AvailabilityZoneDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @instance
             */
            AvailabilityZoneDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new AvailabilityZoneDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @static
             * @param {Ydb.Cms.IAvailabilityZoneDescription=} [properties] Properties to set
             * @returns {Ydb.Cms.AvailabilityZoneDescription} AvailabilityZoneDescription instance
             */
            AvailabilityZoneDescription.create = function create(properties) {
                return new AvailabilityZoneDescription(properties);
            };

            /**
             * Encodes the specified AvailabilityZoneDescription message. Does not implicitly {@link Ydb.Cms.AvailabilityZoneDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @static
             * @param {Ydb.Cms.IAvailabilityZoneDescription} message AvailabilityZoneDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvailabilityZoneDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AvailabilityZoneDescription message, length delimited. Does not implicitly {@link Ydb.Cms.AvailabilityZoneDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @static
             * @param {Ydb.Cms.IAvailabilityZoneDescription} message AvailabilityZoneDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvailabilityZoneDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AvailabilityZoneDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.AvailabilityZoneDescription} AvailabilityZoneDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvailabilityZoneDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.AvailabilityZoneDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AvailabilityZoneDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.AvailabilityZoneDescription} AvailabilityZoneDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvailabilityZoneDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AvailabilityZoneDescription message.
             * @function verify
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AvailabilityZoneDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an AvailabilityZoneDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.AvailabilityZoneDescription} AvailabilityZoneDescription
             */
            AvailabilityZoneDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.AvailabilityZoneDescription)
                    return object;
                var message = new $root.Ydb.Cms.AvailabilityZoneDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Cms.AvailabilityZoneDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from an AvailabilityZoneDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @static
             * @param {Ydb.Cms.AvailabilityZoneDescription} message AvailabilityZoneDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AvailabilityZoneDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this AvailabilityZoneDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.AvailabilityZoneDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AvailabilityZoneDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AvailabilityZoneDescription;
        })();

        Cms.ComputationalUnitDescription = (function() {

            /**
             * Properties of a ComputationalUnitDescription.
             * @memberof Ydb.Cms
             * @interface IComputationalUnitDescription
             * @property {string|null} [kind] ComputationalUnitDescription kind
             * @property {Object.<string,string>|null} [labels] ComputationalUnitDescription labels
             * @property {Array.<string>|null} [allowedAvailabilityZones] ComputationalUnitDescription allowedAvailabilityZones
             */

            /**
             * Constructs a new ComputationalUnitDescription.
             * @memberof Ydb.Cms
             * @classdesc Represents a ComputationalUnitDescription.
             * @implements IComputationalUnitDescription
             * @constructor
             * @param {Ydb.Cms.IComputationalUnitDescription=} [properties] Properties to set
             */
            function ComputationalUnitDescription(properties) {
                this.labels = {};
                this.allowedAvailabilityZones = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComputationalUnitDescription kind.
             * @member {string} kind
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @instance
             */
            ComputationalUnitDescription.prototype.kind = "";

            /**
             * ComputationalUnitDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @instance
             */
            ComputationalUnitDescription.prototype.labels = $util.emptyObject;

            /**
             * ComputationalUnitDescription allowedAvailabilityZones.
             * @member {Array.<string>} allowedAvailabilityZones
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @instance
             */
            ComputationalUnitDescription.prototype.allowedAvailabilityZones = $util.emptyArray;

            /**
             * Creates a new ComputationalUnitDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @static
             * @param {Ydb.Cms.IComputationalUnitDescription=} [properties] Properties to set
             * @returns {Ydb.Cms.ComputationalUnitDescription} ComputationalUnitDescription instance
             */
            ComputationalUnitDescription.create = function create(properties) {
                return new ComputationalUnitDescription(properties);
            };

            /**
             * Encodes the specified ComputationalUnitDescription message. Does not implicitly {@link Ydb.Cms.ComputationalUnitDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @static
             * @param {Ydb.Cms.IComputationalUnitDescription} message ComputationalUnitDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputationalUnitDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                if (message.allowedAvailabilityZones != null && message.allowedAvailabilityZones.length)
                    for (var i = 0; i < message.allowedAvailabilityZones.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.allowedAvailabilityZones[i]);
                return writer;
            };

            /**
             * Encodes the specified ComputationalUnitDescription message, length delimited. Does not implicitly {@link Ydb.Cms.ComputationalUnitDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @static
             * @param {Ydb.Cms.IComputationalUnitDescription} message ComputationalUnitDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputationalUnitDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComputationalUnitDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.ComputationalUnitDescription} ComputationalUnitDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputationalUnitDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.ComputationalUnitDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    case 3:
                        if (!(message.allowedAvailabilityZones && message.allowedAvailabilityZones.length))
                            message.allowedAvailabilityZones = [];
                        message.allowedAvailabilityZones.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ComputationalUnitDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.ComputationalUnitDescription} ComputationalUnitDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputationalUnitDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComputationalUnitDescription message.
             * @function verify
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComputationalUnitDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                if (message.allowedAvailabilityZones != null && message.hasOwnProperty("allowedAvailabilityZones")) {
                    if (!Array.isArray(message.allowedAvailabilityZones))
                        return "allowedAvailabilityZones: array expected";
                    for (var i = 0; i < message.allowedAvailabilityZones.length; ++i)
                        if (!$util.isString(message.allowedAvailabilityZones[i]))
                            return "allowedAvailabilityZones: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ComputationalUnitDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.ComputationalUnitDescription} ComputationalUnitDescription
             */
            ComputationalUnitDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.ComputationalUnitDescription)
                    return object;
                var message = new $root.Ydb.Cms.ComputationalUnitDescription();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Cms.ComputationalUnitDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                if (object.allowedAvailabilityZones) {
                    if (!Array.isArray(object.allowedAvailabilityZones))
                        throw TypeError(".Ydb.Cms.ComputationalUnitDescription.allowedAvailabilityZones: array expected");
                    message.allowedAvailabilityZones = [];
                    for (var i = 0; i < object.allowedAvailabilityZones.length; ++i)
                        message.allowedAvailabilityZones[i] = String(object.allowedAvailabilityZones[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ComputationalUnitDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @static
             * @param {Ydb.Cms.ComputationalUnitDescription} message ComputationalUnitDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComputationalUnitDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.allowedAvailabilityZones = [];
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.kind = "";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                if (message.allowedAvailabilityZones && message.allowedAvailabilityZones.length) {
                    object.allowedAvailabilityZones = [];
                    for (var j = 0; j < message.allowedAvailabilityZones.length; ++j)
                        object.allowedAvailabilityZones[j] = message.allowedAvailabilityZones[j];
                }
                return object;
            };

            /**
             * Converts this ComputationalUnitDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.ComputationalUnitDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComputationalUnitDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ComputationalUnitDescription;
        })();

        Cms.DescribeDatabaseOptionsRequest = (function() {

            /**
             * Properties of a DescribeDatabaseOptionsRequest.
             * @memberof Ydb.Cms
             * @interface IDescribeDatabaseOptionsRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DescribeDatabaseOptionsRequest operationParams
             */

            /**
             * Constructs a new DescribeDatabaseOptionsRequest.
             * @memberof Ydb.Cms
             * @classdesc Represents a DescribeDatabaseOptionsRequest.
             * @implements IDescribeDatabaseOptionsRequest
             * @constructor
             * @param {Ydb.Cms.IDescribeDatabaseOptionsRequest=} [properties] Properties to set
             */
            function DescribeDatabaseOptionsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeDatabaseOptionsRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @instance
             */
            DescribeDatabaseOptionsRequest.prototype.operationParams = null;

            /**
             * Creates a new DescribeDatabaseOptionsRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @static
             * @param {Ydb.Cms.IDescribeDatabaseOptionsRequest=} [properties] Properties to set
             * @returns {Ydb.Cms.DescribeDatabaseOptionsRequest} DescribeDatabaseOptionsRequest instance
             */
            DescribeDatabaseOptionsRequest.create = function create(properties) {
                return new DescribeDatabaseOptionsRequest(properties);
            };

            /**
             * Encodes the specified DescribeDatabaseOptionsRequest message. Does not implicitly {@link Ydb.Cms.DescribeDatabaseOptionsRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @static
             * @param {Ydb.Cms.IDescribeDatabaseOptionsRequest} message DescribeDatabaseOptionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeDatabaseOptionsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeDatabaseOptionsRequest message, length delimited. Does not implicitly {@link Ydb.Cms.DescribeDatabaseOptionsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @static
             * @param {Ydb.Cms.IDescribeDatabaseOptionsRequest} message DescribeDatabaseOptionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeDatabaseOptionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeDatabaseOptionsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.DescribeDatabaseOptionsRequest} DescribeDatabaseOptionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeDatabaseOptionsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.DescribeDatabaseOptionsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeDatabaseOptionsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.DescribeDatabaseOptionsRequest} DescribeDatabaseOptionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeDatabaseOptionsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeDatabaseOptionsRequest message.
             * @function verify
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeDatabaseOptionsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeDatabaseOptionsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.DescribeDatabaseOptionsRequest} DescribeDatabaseOptionsRequest
             */
            DescribeDatabaseOptionsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.DescribeDatabaseOptionsRequest)
                    return object;
                var message = new $root.Ydb.Cms.DescribeDatabaseOptionsRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Cms.DescribeDatabaseOptionsRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeDatabaseOptionsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @static
             * @param {Ydb.Cms.DescribeDatabaseOptionsRequest} message DescribeDatabaseOptionsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeDatabaseOptionsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operationParams = null;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this DescribeDatabaseOptionsRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.DescribeDatabaseOptionsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeDatabaseOptionsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeDatabaseOptionsRequest;
        })();

        Cms.DescribeDatabaseOptionsResponse = (function() {

            /**
             * Properties of a DescribeDatabaseOptionsResponse.
             * @memberof Ydb.Cms
             * @interface IDescribeDatabaseOptionsResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DescribeDatabaseOptionsResponse operation
             */

            /**
             * Constructs a new DescribeDatabaseOptionsResponse.
             * @memberof Ydb.Cms
             * @classdesc Represents a DescribeDatabaseOptionsResponse.
             * @implements IDescribeDatabaseOptionsResponse
             * @constructor
             * @param {Ydb.Cms.IDescribeDatabaseOptionsResponse=} [properties] Properties to set
             */
            function DescribeDatabaseOptionsResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeDatabaseOptionsResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @instance
             */
            DescribeDatabaseOptionsResponse.prototype.operation = null;

            /**
             * Creates a new DescribeDatabaseOptionsResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @static
             * @param {Ydb.Cms.IDescribeDatabaseOptionsResponse=} [properties] Properties to set
             * @returns {Ydb.Cms.DescribeDatabaseOptionsResponse} DescribeDatabaseOptionsResponse instance
             */
            DescribeDatabaseOptionsResponse.create = function create(properties) {
                return new DescribeDatabaseOptionsResponse(properties);
            };

            /**
             * Encodes the specified DescribeDatabaseOptionsResponse message. Does not implicitly {@link Ydb.Cms.DescribeDatabaseOptionsResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @static
             * @param {Ydb.Cms.IDescribeDatabaseOptionsResponse} message DescribeDatabaseOptionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeDatabaseOptionsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeDatabaseOptionsResponse message, length delimited. Does not implicitly {@link Ydb.Cms.DescribeDatabaseOptionsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @static
             * @param {Ydb.Cms.IDescribeDatabaseOptionsResponse} message DescribeDatabaseOptionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeDatabaseOptionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeDatabaseOptionsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.DescribeDatabaseOptionsResponse} DescribeDatabaseOptionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeDatabaseOptionsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.DescribeDatabaseOptionsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeDatabaseOptionsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.DescribeDatabaseOptionsResponse} DescribeDatabaseOptionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeDatabaseOptionsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeDatabaseOptionsResponse message.
             * @function verify
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeDatabaseOptionsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeDatabaseOptionsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.DescribeDatabaseOptionsResponse} DescribeDatabaseOptionsResponse
             */
            DescribeDatabaseOptionsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.DescribeDatabaseOptionsResponse)
                    return object;
                var message = new $root.Ydb.Cms.DescribeDatabaseOptionsResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Cms.DescribeDatabaseOptionsResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeDatabaseOptionsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @static
             * @param {Ydb.Cms.DescribeDatabaseOptionsResponse} message DescribeDatabaseOptionsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeDatabaseOptionsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DescribeDatabaseOptionsResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeDatabaseOptionsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeDatabaseOptionsResponse;
        })();

        Cms.DescribeDatabaseOptionsResult = (function() {

            /**
             * Properties of a DescribeDatabaseOptionsResult.
             * @memberof Ydb.Cms
             * @interface IDescribeDatabaseOptionsResult
             * @property {Array.<Ydb.Cms.IStorageUnitDescription>|null} [storageUnits] DescribeDatabaseOptionsResult storageUnits
             * @property {Array.<Ydb.Cms.IAvailabilityZoneDescription>|null} [availabilityZones] DescribeDatabaseOptionsResult availabilityZones
             * @property {Array.<Ydb.Cms.IComputationalUnitDescription>|null} [computationalUnits] DescribeDatabaseOptionsResult computationalUnits
             */

            /**
             * Constructs a new DescribeDatabaseOptionsResult.
             * @memberof Ydb.Cms
             * @classdesc Represents a DescribeDatabaseOptionsResult.
             * @implements IDescribeDatabaseOptionsResult
             * @constructor
             * @param {Ydb.Cms.IDescribeDatabaseOptionsResult=} [properties] Properties to set
             */
            function DescribeDatabaseOptionsResult(properties) {
                this.storageUnits = [];
                this.availabilityZones = [];
                this.computationalUnits = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeDatabaseOptionsResult storageUnits.
             * @member {Array.<Ydb.Cms.IStorageUnitDescription>} storageUnits
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @instance
             */
            DescribeDatabaseOptionsResult.prototype.storageUnits = $util.emptyArray;

            /**
             * DescribeDatabaseOptionsResult availabilityZones.
             * @member {Array.<Ydb.Cms.IAvailabilityZoneDescription>} availabilityZones
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @instance
             */
            DescribeDatabaseOptionsResult.prototype.availabilityZones = $util.emptyArray;

            /**
             * DescribeDatabaseOptionsResult computationalUnits.
             * @member {Array.<Ydb.Cms.IComputationalUnitDescription>} computationalUnits
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @instance
             */
            DescribeDatabaseOptionsResult.prototype.computationalUnits = $util.emptyArray;

            /**
             * Creates a new DescribeDatabaseOptionsResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @static
             * @param {Ydb.Cms.IDescribeDatabaseOptionsResult=} [properties] Properties to set
             * @returns {Ydb.Cms.DescribeDatabaseOptionsResult} DescribeDatabaseOptionsResult instance
             */
            DescribeDatabaseOptionsResult.create = function create(properties) {
                return new DescribeDatabaseOptionsResult(properties);
            };

            /**
             * Encodes the specified DescribeDatabaseOptionsResult message. Does not implicitly {@link Ydb.Cms.DescribeDatabaseOptionsResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @static
             * @param {Ydb.Cms.IDescribeDatabaseOptionsResult} message DescribeDatabaseOptionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeDatabaseOptionsResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.storageUnits != null && message.storageUnits.length)
                    for (var i = 0; i < message.storageUnits.length; ++i)
                        $root.Ydb.Cms.StorageUnitDescription.encode(message.storageUnits[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.availabilityZones != null && message.availabilityZones.length)
                    for (var i = 0; i < message.availabilityZones.length; ++i)
                        $root.Ydb.Cms.AvailabilityZoneDescription.encode(message.availabilityZones[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.computationalUnits != null && message.computationalUnits.length)
                    for (var i = 0; i < message.computationalUnits.length; ++i)
                        $root.Ydb.Cms.ComputationalUnitDescription.encode(message.computationalUnits[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeDatabaseOptionsResult message, length delimited. Does not implicitly {@link Ydb.Cms.DescribeDatabaseOptionsResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @static
             * @param {Ydb.Cms.IDescribeDatabaseOptionsResult} message DescribeDatabaseOptionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeDatabaseOptionsResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeDatabaseOptionsResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Cms.DescribeDatabaseOptionsResult} DescribeDatabaseOptionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeDatabaseOptionsResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Cms.DescribeDatabaseOptionsResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.storageUnits && message.storageUnits.length))
                            message.storageUnits = [];
                        message.storageUnits.push($root.Ydb.Cms.StorageUnitDescription.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.availabilityZones && message.availabilityZones.length))
                            message.availabilityZones = [];
                        message.availabilityZones.push($root.Ydb.Cms.AvailabilityZoneDescription.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.computationalUnits && message.computationalUnits.length))
                            message.computationalUnits = [];
                        message.computationalUnits.push($root.Ydb.Cms.ComputationalUnitDescription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeDatabaseOptionsResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Cms.DescribeDatabaseOptionsResult} DescribeDatabaseOptionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeDatabaseOptionsResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeDatabaseOptionsResult message.
             * @function verify
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeDatabaseOptionsResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.storageUnits != null && message.hasOwnProperty("storageUnits")) {
                    if (!Array.isArray(message.storageUnits))
                        return "storageUnits: array expected";
                    for (var i = 0; i < message.storageUnits.length; ++i) {
                        var error = $root.Ydb.Cms.StorageUnitDescription.verify(message.storageUnits[i]);
                        if (error)
                            return "storageUnits." + error;
                    }
                }
                if (message.availabilityZones != null && message.hasOwnProperty("availabilityZones")) {
                    if (!Array.isArray(message.availabilityZones))
                        return "availabilityZones: array expected";
                    for (var i = 0; i < message.availabilityZones.length; ++i) {
                        var error = $root.Ydb.Cms.AvailabilityZoneDescription.verify(message.availabilityZones[i]);
                        if (error)
                            return "availabilityZones." + error;
                    }
                }
                if (message.computationalUnits != null && message.hasOwnProperty("computationalUnits")) {
                    if (!Array.isArray(message.computationalUnits))
                        return "computationalUnits: array expected";
                    for (var i = 0; i < message.computationalUnits.length; ++i) {
                        var error = $root.Ydb.Cms.ComputationalUnitDescription.verify(message.computationalUnits[i]);
                        if (error)
                            return "computationalUnits." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DescribeDatabaseOptionsResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Cms.DescribeDatabaseOptionsResult} DescribeDatabaseOptionsResult
             */
            DescribeDatabaseOptionsResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Cms.DescribeDatabaseOptionsResult)
                    return object;
                var message = new $root.Ydb.Cms.DescribeDatabaseOptionsResult();
                if (object.storageUnits) {
                    if (!Array.isArray(object.storageUnits))
                        throw TypeError(".Ydb.Cms.DescribeDatabaseOptionsResult.storageUnits: array expected");
                    message.storageUnits = [];
                    for (var i = 0; i < object.storageUnits.length; ++i) {
                        if (typeof object.storageUnits[i] !== "object")
                            throw TypeError(".Ydb.Cms.DescribeDatabaseOptionsResult.storageUnits: object expected");
                        message.storageUnits[i] = $root.Ydb.Cms.StorageUnitDescription.fromObject(object.storageUnits[i]);
                    }
                }
                if (object.availabilityZones) {
                    if (!Array.isArray(object.availabilityZones))
                        throw TypeError(".Ydb.Cms.DescribeDatabaseOptionsResult.availabilityZones: array expected");
                    message.availabilityZones = [];
                    for (var i = 0; i < object.availabilityZones.length; ++i) {
                        if (typeof object.availabilityZones[i] !== "object")
                            throw TypeError(".Ydb.Cms.DescribeDatabaseOptionsResult.availabilityZones: object expected");
                        message.availabilityZones[i] = $root.Ydb.Cms.AvailabilityZoneDescription.fromObject(object.availabilityZones[i]);
                    }
                }
                if (object.computationalUnits) {
                    if (!Array.isArray(object.computationalUnits))
                        throw TypeError(".Ydb.Cms.DescribeDatabaseOptionsResult.computationalUnits: array expected");
                    message.computationalUnits = [];
                    for (var i = 0; i < object.computationalUnits.length; ++i) {
                        if (typeof object.computationalUnits[i] !== "object")
                            throw TypeError(".Ydb.Cms.DescribeDatabaseOptionsResult.computationalUnits: object expected");
                        message.computationalUnits[i] = $root.Ydb.Cms.ComputationalUnitDescription.fromObject(object.computationalUnits[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeDatabaseOptionsResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @static
             * @param {Ydb.Cms.DescribeDatabaseOptionsResult} message DescribeDatabaseOptionsResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeDatabaseOptionsResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.storageUnits = [];
                    object.availabilityZones = [];
                    object.computationalUnits = [];
                }
                if (message.storageUnits && message.storageUnits.length) {
                    object.storageUnits = [];
                    for (var j = 0; j < message.storageUnits.length; ++j)
                        object.storageUnits[j] = $root.Ydb.Cms.StorageUnitDescription.toObject(message.storageUnits[j], options);
                }
                if (message.availabilityZones && message.availabilityZones.length) {
                    object.availabilityZones = [];
                    for (var j = 0; j < message.availabilityZones.length; ++j)
                        object.availabilityZones[j] = $root.Ydb.Cms.AvailabilityZoneDescription.toObject(message.availabilityZones[j], options);
                }
                if (message.computationalUnits && message.computationalUnits.length) {
                    object.computationalUnits = [];
                    for (var j = 0; j < message.computationalUnits.length; ++j)
                        object.computationalUnits[j] = $root.Ydb.Cms.ComputationalUnitDescription.toObject(message.computationalUnits[j], options);
                }
                return object;
            };

            /**
             * Converts this DescribeDatabaseOptionsResult to JSON.
             * @function toJSON
             * @memberof Ydb.Cms.DescribeDatabaseOptionsResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeDatabaseOptionsResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeDatabaseOptionsResult;
        })();

        return Cms;
    })();

    Ydb.Operations = (function() {

        /**
         * Namespace Operations.
         * @memberof Ydb
         * @namespace
         */
        var Operations = {};

        Operations.OperationParams = (function() {

            /**
             * Properties of an OperationParams.
             * @memberof Ydb.Operations
             * @interface IOperationParams
             * @property {Ydb.Operations.OperationParams.OperationMode|null} [operationMode] OperationParams operationMode
             * @property {google.protobuf.IDuration|null} [operationTimeout] OperationParams operationTimeout
             * @property {google.protobuf.IDuration|null} [cancelAfter] OperationParams cancelAfter
             * @property {Object.<string,string>|null} [labels] OperationParams labels
             */

            /**
             * Constructs a new OperationParams.
             * @memberof Ydb.Operations
             * @classdesc Represents an OperationParams.
             * @implements IOperationParams
             * @constructor
             * @param {Ydb.Operations.IOperationParams=} [properties] Properties to set
             */
            function OperationParams(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OperationParams operationMode.
             * @member {Ydb.Operations.OperationParams.OperationMode} operationMode
             * @memberof Ydb.Operations.OperationParams
             * @instance
             */
            OperationParams.prototype.operationMode = 0;

            /**
             * OperationParams operationTimeout.
             * @member {google.protobuf.IDuration|null|undefined} operationTimeout
             * @memberof Ydb.Operations.OperationParams
             * @instance
             */
            OperationParams.prototype.operationTimeout = null;

            /**
             * OperationParams cancelAfter.
             * @member {google.protobuf.IDuration|null|undefined} cancelAfter
             * @memberof Ydb.Operations.OperationParams
             * @instance
             */
            OperationParams.prototype.cancelAfter = null;

            /**
             * OperationParams labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Operations.OperationParams
             * @instance
             */
            OperationParams.prototype.labels = $util.emptyObject;

            /**
             * Creates a new OperationParams instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Ydb.Operations.IOperationParams=} [properties] Properties to set
             * @returns {Ydb.Operations.OperationParams} OperationParams instance
             */
            OperationParams.create = function create(properties) {
                return new OperationParams(properties);
            };

            /**
             * Encodes the specified OperationParams message. Does not implicitly {@link Ydb.Operations.OperationParams.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Ydb.Operations.IOperationParams} message OperationParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationParams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationMode != null && message.hasOwnProperty("operationMode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operationMode);
                if (message.operationTimeout != null && message.hasOwnProperty("operationTimeout"))
                    $root.google.protobuf.Duration.encode(message.operationTimeout, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cancelAfter != null && message.hasOwnProperty("cancelAfter"))
                    $root.google.protobuf.Duration.encode(message.cancelAfter, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OperationParams message, length delimited. Does not implicitly {@link Ydb.Operations.OperationParams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Ydb.Operations.IOperationParams} message OperationParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationParams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OperationParams message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.OperationParams} OperationParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationParams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.OperationParams(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationMode = reader.int32();
                        break;
                    case 2:
                        message.operationTimeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.cancelAfter = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    case 4:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OperationParams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.OperationParams} OperationParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationParams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OperationParams message.
             * @function verify
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OperationParams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationMode != null && message.hasOwnProperty("operationMode"))
                    switch (message.operationMode) {
                    default:
                        return "operationMode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.operationTimeout != null && message.hasOwnProperty("operationTimeout")) {
                    var error = $root.google.protobuf.Duration.verify(message.operationTimeout);
                    if (error)
                        return "operationTimeout." + error;
                }
                if (message.cancelAfter != null && message.hasOwnProperty("cancelAfter")) {
                    var error = $root.google.protobuf.Duration.verify(message.cancelAfter);
                    if (error)
                        return "cancelAfter." + error;
                }
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an OperationParams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.OperationParams} OperationParams
             */
            OperationParams.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.OperationParams)
                    return object;
                var message = new $root.Ydb.Operations.OperationParams();
                switch (object.operationMode) {
                case "OPERATION_MODE_UNSPECIFIED":
                case 0:
                    message.operationMode = 0;
                    break;
                case "SYNC":
                case 1:
                    message.operationMode = 1;
                    break;
                case "ASYNC":
                case 2:
                    message.operationMode = 2;
                    break;
                }
                if (object.operationTimeout != null) {
                    if (typeof object.operationTimeout !== "object")
                        throw TypeError(".Ydb.Operations.OperationParams.operationTimeout: object expected");
                    message.operationTimeout = $root.google.protobuf.Duration.fromObject(object.operationTimeout);
                }
                if (object.cancelAfter != null) {
                    if (typeof object.cancelAfter !== "object")
                        throw TypeError(".Ydb.Operations.OperationParams.cancelAfter: object expected");
                    message.cancelAfter = $root.google.protobuf.Duration.fromObject(object.cancelAfter);
                }
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Operations.OperationParams.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from an OperationParams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Ydb.Operations.OperationParams} message OperationParams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OperationParams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults) {
                    object.operationMode = options.enums === String ? "OPERATION_MODE_UNSPECIFIED" : 0;
                    object.operationTimeout = null;
                    object.cancelAfter = null;
                }
                if (message.operationMode != null && message.hasOwnProperty("operationMode"))
                    object.operationMode = options.enums === String ? $root.Ydb.Operations.OperationParams.OperationMode[message.operationMode] : message.operationMode;
                if (message.operationTimeout != null && message.hasOwnProperty("operationTimeout"))
                    object.operationTimeout = $root.google.protobuf.Duration.toObject(message.operationTimeout, options);
                if (message.cancelAfter != null && message.hasOwnProperty("cancelAfter"))
                    object.cancelAfter = $root.google.protobuf.Duration.toObject(message.cancelAfter, options);
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this OperationParams to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.OperationParams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OperationParams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OperationMode enum.
             * @name Ydb.Operations.OperationParams.OperationMode
             * @enum {string}
             * @property {number} OPERATION_MODE_UNSPECIFIED=0 OPERATION_MODE_UNSPECIFIED value
             * @property {number} SYNC=1 SYNC value
             * @property {number} ASYNC=2 ASYNC value
             */
            OperationParams.OperationMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OPERATION_MODE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "SYNC"] = 1;
                values[valuesById[2] = "ASYNC"] = 2;
                return values;
            })();

            return OperationParams;
        })();

        Operations.GetOperationRequest = (function() {

            /**
             * Properties of a GetOperationRequest.
             * @memberof Ydb.Operations
             * @interface IGetOperationRequest
             * @property {string|null} [id] GetOperationRequest id
             */

            /**
             * Constructs a new GetOperationRequest.
             * @memberof Ydb.Operations
             * @classdesc Represents a GetOperationRequest.
             * @implements IGetOperationRequest
             * @constructor
             * @param {Ydb.Operations.IGetOperationRequest=} [properties] Properties to set
             */
            function GetOperationRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetOperationRequest id.
             * @member {string} id
             * @memberof Ydb.Operations.GetOperationRequest
             * @instance
             */
            GetOperationRequest.prototype.id = "";

            /**
             * Creates a new GetOperationRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Ydb.Operations.IGetOperationRequest=} [properties] Properties to set
             * @returns {Ydb.Operations.GetOperationRequest} GetOperationRequest instance
             */
            GetOperationRequest.create = function create(properties) {
                return new GetOperationRequest(properties);
            };

            /**
             * Encodes the specified GetOperationRequest message. Does not implicitly {@link Ydb.Operations.GetOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Ydb.Operations.IGetOperationRequest} message GetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified GetOperationRequest message, length delimited. Does not implicitly {@link Ydb.Operations.GetOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Ydb.Operations.IGetOperationRequest} message GetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.GetOperationRequest} GetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.GetOperationRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.GetOperationRequest} GetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetOperationRequest message.
             * @function verify
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a GetOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.GetOperationRequest} GetOperationRequest
             */
            GetOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.GetOperationRequest)
                    return object;
                var message = new $root.Ydb.Operations.GetOperationRequest();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a GetOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Ydb.Operations.GetOperationRequest} message GetOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this GetOperationRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.GetOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetOperationRequest;
        })();

        Operations.GetOperationResponse = (function() {

            /**
             * Properties of a GetOperationResponse.
             * @memberof Ydb.Operations
             * @interface IGetOperationResponse
             * @property {Ydb.Operations.IOperation|null} [operation] GetOperationResponse operation
             */

            /**
             * Constructs a new GetOperationResponse.
             * @memberof Ydb.Operations
             * @classdesc Represents a GetOperationResponse.
             * @implements IGetOperationResponse
             * @constructor
             * @param {Ydb.Operations.IGetOperationResponse=} [properties] Properties to set
             */
            function GetOperationResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetOperationResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Operations.GetOperationResponse
             * @instance
             */
            GetOperationResponse.prototype.operation = null;

            /**
             * Creates a new GetOperationResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Ydb.Operations.IGetOperationResponse=} [properties] Properties to set
             * @returns {Ydb.Operations.GetOperationResponse} GetOperationResponse instance
             */
            GetOperationResponse.create = function create(properties) {
                return new GetOperationResponse(properties);
            };

            /**
             * Encodes the specified GetOperationResponse message. Does not implicitly {@link Ydb.Operations.GetOperationResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Ydb.Operations.IGetOperationResponse} message GetOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetOperationResponse message, length delimited. Does not implicitly {@link Ydb.Operations.GetOperationResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Ydb.Operations.IGetOperationResponse} message GetOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetOperationResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.GetOperationResponse} GetOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.GetOperationResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetOperationResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.GetOperationResponse} GetOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetOperationResponse message.
             * @function verify
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetOperationResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a GetOperationResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.GetOperationResponse} GetOperationResponse
             */
            GetOperationResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.GetOperationResponse)
                    return object;
                var message = new $root.Ydb.Operations.GetOperationResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Operations.GetOperationResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetOperationResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Ydb.Operations.GetOperationResponse} message GetOperationResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetOperationResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this GetOperationResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.GetOperationResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetOperationResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetOperationResponse;
        })();

        Operations.CancelOperationRequest = (function() {

            /**
             * Properties of a CancelOperationRequest.
             * @memberof Ydb.Operations
             * @interface ICancelOperationRequest
             * @property {string|null} [id] CancelOperationRequest id
             */

            /**
             * Constructs a new CancelOperationRequest.
             * @memberof Ydb.Operations
             * @classdesc Represents a CancelOperationRequest.
             * @implements ICancelOperationRequest
             * @constructor
             * @param {Ydb.Operations.ICancelOperationRequest=} [properties] Properties to set
             */
            function CancelOperationRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CancelOperationRequest id.
             * @member {string} id
             * @memberof Ydb.Operations.CancelOperationRequest
             * @instance
             */
            CancelOperationRequest.prototype.id = "";

            /**
             * Creates a new CancelOperationRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Ydb.Operations.ICancelOperationRequest=} [properties] Properties to set
             * @returns {Ydb.Operations.CancelOperationRequest} CancelOperationRequest instance
             */
            CancelOperationRequest.create = function create(properties) {
                return new CancelOperationRequest(properties);
            };

            /**
             * Encodes the specified CancelOperationRequest message. Does not implicitly {@link Ydb.Operations.CancelOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Ydb.Operations.ICancelOperationRequest} message CancelOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified CancelOperationRequest message, length delimited. Does not implicitly {@link Ydb.Operations.CancelOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Ydb.Operations.ICancelOperationRequest} message CancelOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CancelOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.CancelOperationRequest} CancelOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.CancelOperationRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CancelOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.CancelOperationRequest} CancelOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CancelOperationRequest message.
             * @function verify
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CancelOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a CancelOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.CancelOperationRequest} CancelOperationRequest
             */
            CancelOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.CancelOperationRequest)
                    return object;
                var message = new $root.Ydb.Operations.CancelOperationRequest();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a CancelOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Ydb.Operations.CancelOperationRequest} message CancelOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CancelOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this CancelOperationRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.CancelOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CancelOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CancelOperationRequest;
        })();

        Operations.CancelOperationResponse = (function() {

            /**
             * Properties of a CancelOperationResponse.
             * @memberof Ydb.Operations
             * @interface ICancelOperationResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] CancelOperationResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] CancelOperationResponse issues
             */

            /**
             * Constructs a new CancelOperationResponse.
             * @memberof Ydb.Operations
             * @classdesc Represents a CancelOperationResponse.
             * @implements ICancelOperationResponse
             * @constructor
             * @param {Ydb.Operations.ICancelOperationResponse=} [properties] Properties to set
             */
            function CancelOperationResponse(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CancelOperationResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Operations.CancelOperationResponse
             * @instance
             */
            CancelOperationResponse.prototype.status = 0;

            /**
             * CancelOperationResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Operations.CancelOperationResponse
             * @instance
             */
            CancelOperationResponse.prototype.issues = $util.emptyArray;

            /**
             * Creates a new CancelOperationResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Ydb.Operations.ICancelOperationResponse=} [properties] Properties to set
             * @returns {Ydb.Operations.CancelOperationResponse} CancelOperationResponse instance
             */
            CancelOperationResponse.create = function create(properties) {
                return new CancelOperationResponse(properties);
            };

            /**
             * Encodes the specified CancelOperationResponse message. Does not implicitly {@link Ydb.Operations.CancelOperationResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Ydb.Operations.ICancelOperationResponse} message CancelOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CancelOperationResponse message, length delimited. Does not implicitly {@link Ydb.Operations.CancelOperationResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Ydb.Operations.ICancelOperationResponse} message CancelOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CancelOperationResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.CancelOperationResponse} CancelOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.CancelOperationResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CancelOperationResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.CancelOperationResponse} CancelOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CancelOperationResponse message.
             * @function verify
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CancelOperationResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CancelOperationResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.CancelOperationResponse} CancelOperationResponse
             */
            CancelOperationResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.CancelOperationResponse)
                    return object;
                var message = new $root.Ydb.Operations.CancelOperationResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Operations.CancelOperationResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Operations.CancelOperationResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CancelOperationResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Ydb.Operations.CancelOperationResponse} message CancelOperationResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CancelOperationResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults)
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                return object;
            };

            /**
             * Converts this CancelOperationResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.CancelOperationResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CancelOperationResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CancelOperationResponse;
        })();

        Operations.ForgetOperationRequest = (function() {

            /**
             * Properties of a ForgetOperationRequest.
             * @memberof Ydb.Operations
             * @interface IForgetOperationRequest
             * @property {string|null} [id] ForgetOperationRequest id
             */

            /**
             * Constructs a new ForgetOperationRequest.
             * @memberof Ydb.Operations
             * @classdesc Represents a ForgetOperationRequest.
             * @implements IForgetOperationRequest
             * @constructor
             * @param {Ydb.Operations.IForgetOperationRequest=} [properties] Properties to set
             */
            function ForgetOperationRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForgetOperationRequest id.
             * @member {string} id
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @instance
             */
            ForgetOperationRequest.prototype.id = "";

            /**
             * Creates a new ForgetOperationRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Ydb.Operations.IForgetOperationRequest=} [properties] Properties to set
             * @returns {Ydb.Operations.ForgetOperationRequest} ForgetOperationRequest instance
             */
            ForgetOperationRequest.create = function create(properties) {
                return new ForgetOperationRequest(properties);
            };

            /**
             * Encodes the specified ForgetOperationRequest message. Does not implicitly {@link Ydb.Operations.ForgetOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Ydb.Operations.IForgetOperationRequest} message ForgetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForgetOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified ForgetOperationRequest message, length delimited. Does not implicitly {@link Ydb.Operations.ForgetOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Ydb.Operations.IForgetOperationRequest} message ForgetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForgetOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForgetOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.ForgetOperationRequest} ForgetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForgetOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.ForgetOperationRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForgetOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.ForgetOperationRequest} ForgetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForgetOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForgetOperationRequest message.
             * @function verify
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForgetOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a ForgetOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.ForgetOperationRequest} ForgetOperationRequest
             */
            ForgetOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.ForgetOperationRequest)
                    return object;
                var message = new $root.Ydb.Operations.ForgetOperationRequest();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a ForgetOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Ydb.Operations.ForgetOperationRequest} message ForgetOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForgetOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this ForgetOperationRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForgetOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ForgetOperationRequest;
        })();

        Operations.ForgetOperationResponse = (function() {

            /**
             * Properties of a ForgetOperationResponse.
             * @memberof Ydb.Operations
             * @interface IForgetOperationResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] ForgetOperationResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ForgetOperationResponse issues
             */

            /**
             * Constructs a new ForgetOperationResponse.
             * @memberof Ydb.Operations
             * @classdesc Represents a ForgetOperationResponse.
             * @implements IForgetOperationResponse
             * @constructor
             * @param {Ydb.Operations.IForgetOperationResponse=} [properties] Properties to set
             */
            function ForgetOperationResponse(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForgetOperationResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @instance
             */
            ForgetOperationResponse.prototype.status = 0;

            /**
             * ForgetOperationResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @instance
             */
            ForgetOperationResponse.prototype.issues = $util.emptyArray;

            /**
             * Creates a new ForgetOperationResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Ydb.Operations.IForgetOperationResponse=} [properties] Properties to set
             * @returns {Ydb.Operations.ForgetOperationResponse} ForgetOperationResponse instance
             */
            ForgetOperationResponse.create = function create(properties) {
                return new ForgetOperationResponse(properties);
            };

            /**
             * Encodes the specified ForgetOperationResponse message. Does not implicitly {@link Ydb.Operations.ForgetOperationResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Ydb.Operations.IForgetOperationResponse} message ForgetOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForgetOperationResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ForgetOperationResponse message, length delimited. Does not implicitly {@link Ydb.Operations.ForgetOperationResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Ydb.Operations.IForgetOperationResponse} message ForgetOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForgetOperationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForgetOperationResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.ForgetOperationResponse} ForgetOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForgetOperationResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.ForgetOperationResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForgetOperationResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.ForgetOperationResponse} ForgetOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForgetOperationResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForgetOperationResponse message.
             * @function verify
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForgetOperationResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ForgetOperationResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.ForgetOperationResponse} ForgetOperationResponse
             */
            ForgetOperationResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.ForgetOperationResponse)
                    return object;
                var message = new $root.Ydb.Operations.ForgetOperationResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Operations.ForgetOperationResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Operations.ForgetOperationResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ForgetOperationResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Ydb.Operations.ForgetOperationResponse} message ForgetOperationResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForgetOperationResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults)
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                return object;
            };

            /**
             * Converts this ForgetOperationResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForgetOperationResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ForgetOperationResponse;
        })();

        Operations.ListOperationsRequest = (function() {

            /**
             * Properties of a ListOperationsRequest.
             * @memberof Ydb.Operations
             * @interface IListOperationsRequest
             * @property {string|null} [kind] ListOperationsRequest kind
             * @property {number|Long|null} [pageSize] ListOperationsRequest pageSize
             * @property {string|null} [pageToken] ListOperationsRequest pageToken
             */

            /**
             * Constructs a new ListOperationsRequest.
             * @memberof Ydb.Operations
             * @classdesc Represents a ListOperationsRequest.
             * @implements IListOperationsRequest
             * @constructor
             * @param {Ydb.Operations.IListOperationsRequest=} [properties] Properties to set
             */
            function ListOperationsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListOperationsRequest kind.
             * @member {string} kind
             * @memberof Ydb.Operations.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.kind = "";

            /**
             * ListOperationsRequest pageSize.
             * @member {number|Long} pageSize
             * @memberof Ydb.Operations.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.pageSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ListOperationsRequest pageToken.
             * @member {string} pageToken
             * @memberof Ydb.Operations.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.pageToken = "";

            /**
             * Creates a new ListOperationsRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Ydb.Operations.IListOperationsRequest=} [properties] Properties to set
             * @returns {Ydb.Operations.ListOperationsRequest} ListOperationsRequest instance
             */
            ListOperationsRequest.create = function create(properties) {
                return new ListOperationsRequest(properties);
            };

            /**
             * Encodes the specified ListOperationsRequest message. Does not implicitly {@link Ydb.Operations.ListOperationsRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Ydb.Operations.IListOperationsRequest} message ListOperationsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.pageSize);
                if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.pageToken);
                return writer;
            };

            /**
             * Encodes the specified ListOperationsRequest message, length delimited. Does not implicitly {@link Ydb.Operations.ListOperationsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Ydb.Operations.IListOperationsRequest} message ListOperationsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListOperationsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.ListOperationsRequest} ListOperationsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.ListOperationsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        message.pageSize = reader.uint64();
                        break;
                    case 3:
                        message.pageToken = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListOperationsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.ListOperationsRequest} ListOperationsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListOperationsRequest message.
             * @function verify
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListOperationsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (!$util.isInteger(message.pageSize) && !(message.pageSize && $util.isInteger(message.pageSize.low) && $util.isInteger(message.pageSize.high)))
                        return "pageSize: integer|Long expected";
                if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                    if (!$util.isString(message.pageToken))
                        return "pageToken: string expected";
                return null;
            };

            /**
             * Creates a ListOperationsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.ListOperationsRequest} ListOperationsRequest
             */
            ListOperationsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.ListOperationsRequest)
                    return object;
                var message = new $root.Ydb.Operations.ListOperationsRequest();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.pageSize != null)
                    if ($util.Long)
                        (message.pageSize = $util.Long.fromValue(object.pageSize)).unsigned = true;
                    else if (typeof object.pageSize === "string")
                        message.pageSize = parseInt(object.pageSize, 10);
                    else if (typeof object.pageSize === "number")
                        message.pageSize = object.pageSize;
                    else if (typeof object.pageSize === "object")
                        message.pageSize = new $util.LongBits(object.pageSize.low >>> 0, object.pageSize.high >>> 0).toNumber(true);
                if (object.pageToken != null)
                    message.pageToken = String(object.pageToken);
                return message;
            };

            /**
             * Creates a plain object from a ListOperationsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Ydb.Operations.ListOperationsRequest} message ListOperationsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListOperationsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.pageSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.pageSize = options.longs === String ? "0" : 0;
                    object.pageToken = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (typeof message.pageSize === "number")
                        object.pageSize = options.longs === String ? String(message.pageSize) : message.pageSize;
                    else
                        object.pageSize = options.longs === String ? $util.Long.prototype.toString.call(message.pageSize) : options.longs === Number ? new $util.LongBits(message.pageSize.low >>> 0, message.pageSize.high >>> 0).toNumber(true) : message.pageSize;
                if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                    object.pageToken = message.pageToken;
                return object;
            };

            /**
             * Converts this ListOperationsRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.ListOperationsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListOperationsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListOperationsRequest;
        })();

        Operations.ListOperationsResponse = (function() {

            /**
             * Properties of a ListOperationsResponse.
             * @memberof Ydb.Operations
             * @interface IListOperationsResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] ListOperationsResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ListOperationsResponse issues
             * @property {Array.<Ydb.Operations.IOperation>|null} [operations] ListOperationsResponse operations
             * @property {string|null} [nextPageToken] ListOperationsResponse nextPageToken
             */

            /**
             * Constructs a new ListOperationsResponse.
             * @memberof Ydb.Operations
             * @classdesc Represents a ListOperationsResponse.
             * @implements IListOperationsResponse
             * @constructor
             * @param {Ydb.Operations.IListOperationsResponse=} [properties] Properties to set
             */
            function ListOperationsResponse(properties) {
                this.issues = [];
                this.operations = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListOperationsResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.status = 0;

            /**
             * ListOperationsResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.issues = $util.emptyArray;

            /**
             * ListOperationsResponse operations.
             * @member {Array.<Ydb.Operations.IOperation>} operations
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.operations = $util.emptyArray;

            /**
             * ListOperationsResponse nextPageToken.
             * @member {string} nextPageToken
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.nextPageToken = "";

            /**
             * Creates a new ListOperationsResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Ydb.Operations.IListOperationsResponse=} [properties] Properties to set
             * @returns {Ydb.Operations.ListOperationsResponse} ListOperationsResponse instance
             */
            ListOperationsResponse.create = function create(properties) {
                return new ListOperationsResponse(properties);
            };

            /**
             * Encodes the specified ListOperationsResponse message. Does not implicitly {@link Ydb.Operations.ListOperationsResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Ydb.Operations.IListOperationsResponse} message ListOperationsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.operations != null && message.operations.length)
                    for (var i = 0; i < message.operations.length; ++i)
                        $root.Ydb.Operations.Operation.encode(message.operations[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.nextPageToken);
                return writer;
            };

            /**
             * Encodes the specified ListOperationsResponse message, length delimited. Does not implicitly {@link Ydb.Operations.ListOperationsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Ydb.Operations.IListOperationsResponse} message ListOperationsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListOperationsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.ListOperationsResponse} ListOperationsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.ListOperationsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.operations && message.operations.length))
                            message.operations = [];
                        message.operations.push($root.Ydb.Operations.Operation.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.nextPageToken = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListOperationsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.ListOperationsResponse} ListOperationsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListOperationsResponse message.
             * @function verify
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListOperationsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                if (message.operations != null && message.hasOwnProperty("operations")) {
                    if (!Array.isArray(message.operations))
                        return "operations: array expected";
                    for (var i = 0; i < message.operations.length; ++i) {
                        var error = $root.Ydb.Operations.Operation.verify(message.operations[i]);
                        if (error)
                            return "operations." + error;
                    }
                }
                if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                    if (!$util.isString(message.nextPageToken))
                        return "nextPageToken: string expected";
                return null;
            };

            /**
             * Creates a ListOperationsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.ListOperationsResponse} ListOperationsResponse
             */
            ListOperationsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.ListOperationsResponse)
                    return object;
                var message = new $root.Ydb.Operations.ListOperationsResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Operations.ListOperationsResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Operations.ListOperationsResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                if (object.operations) {
                    if (!Array.isArray(object.operations))
                        throw TypeError(".Ydb.Operations.ListOperationsResponse.operations: array expected");
                    message.operations = [];
                    for (var i = 0; i < object.operations.length; ++i) {
                        if (typeof object.operations[i] !== "object")
                            throw TypeError(".Ydb.Operations.ListOperationsResponse.operations: object expected");
                        message.operations[i] = $root.Ydb.Operations.Operation.fromObject(object.operations[i]);
                    }
                }
                if (object.nextPageToken != null)
                    message.nextPageToken = String(object.nextPageToken);
                return message;
            };

            /**
             * Creates a plain object from a ListOperationsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Ydb.Operations.ListOperationsResponse} message ListOperationsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListOperationsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.issues = [];
                    object.operations = [];
                }
                if (options.defaults) {
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    object.nextPageToken = "";
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                if (message.operations && message.operations.length) {
                    object.operations = [];
                    for (var j = 0; j < message.operations.length; ++j)
                        object.operations[j] = $root.Ydb.Operations.Operation.toObject(message.operations[j], options);
                }
                if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                    object.nextPageToken = message.nextPageToken;
                return object;
            };

            /**
             * Converts this ListOperationsResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListOperationsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListOperationsResponse;
        })();

        Operations.Operation = (function() {

            /**
             * Properties of an Operation.
             * @memberof Ydb.Operations
             * @interface IOperation
             * @property {string|null} [id] Operation id
             * @property {boolean|null} [ready] Operation ready
             * @property {Ydb.StatusIds.StatusCode|null} [status] Operation status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] Operation issues
             * @property {google.protobuf.IAny|null} [result] Operation result
             * @property {google.protobuf.IAny|null} [metadata] Operation metadata
             */

            /**
             * Constructs a new Operation.
             * @memberof Ydb.Operations
             * @classdesc Represents an Operation.
             * @implements IOperation
             * @constructor
             * @param {Ydb.Operations.IOperation=} [properties] Properties to set
             */
            function Operation(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Operation id.
             * @member {string} id
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.id = "";

            /**
             * Operation ready.
             * @member {boolean} ready
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.ready = false;

            /**
             * Operation status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.status = 0;

            /**
             * Operation issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.issues = $util.emptyArray;

            /**
             * Operation result.
             * @member {google.protobuf.IAny|null|undefined} result
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.result = null;

            /**
             * Operation metadata.
             * @member {google.protobuf.IAny|null|undefined} metadata
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.metadata = null;

            /**
             * Creates a new Operation instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Ydb.Operations.IOperation=} [properties] Properties to set
             * @returns {Ydb.Operations.Operation} Operation instance
             */
            Operation.create = function create(properties) {
                return new Operation(properties);
            };

            /**
             * Encodes the specified Operation message. Does not implicitly {@link Ydb.Operations.Operation.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Ydb.Operations.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.ready != null && message.hasOwnProperty("ready"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ready);
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.result != null && message.hasOwnProperty("result"))
                    $root.google.protobuf.Any.encode(message.result, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.google.protobuf.Any.encode(message.metadata, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Operation message, length delimited. Does not implicitly {@link Ydb.Operations.Operation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Ydb.Operations.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Operation message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.Operation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.ready = reader.bool();
                        break;
                    case 3:
                        message.status = reader.int32();
                        break;
                    case 4:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.result = $root.google.protobuf.Any.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.metadata = $root.google.protobuf.Any.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Operation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Operation message.
             * @function verify
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Operation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.ready != null && message.hasOwnProperty("ready"))
                    if (typeof message.ready !== "boolean")
                        return "ready: boolean expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    var error = $root.google.protobuf.Any.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    var error = $root.google.protobuf.Any.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            /**
             * Creates an Operation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.Operation} Operation
             */
            Operation.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.Operation)
                    return object;
                var message = new $root.Ydb.Operations.Operation();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.ready != null)
                    message.ready = Boolean(object.ready);
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Operations.Operation.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Operations.Operation.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".Ydb.Operations.Operation.result: object expected");
                    message.result = $root.google.protobuf.Any.fromObject(object.result);
                }
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".Ydb.Operations.Operation.metadata: object expected");
                    message.metadata = $root.google.protobuf.Any.fromObject(object.metadata);
                }
                return message;
            };

            /**
             * Creates a plain object from an Operation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Ydb.Operations.Operation} message Operation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Operation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults) {
                    object.id = "";
                    object.ready = false;
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    object.result = null;
                    object.metadata = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.ready != null && message.hasOwnProperty("ready"))
                    object.ready = message.ready;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.google.protobuf.Any.toObject(message.result, options);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.google.protobuf.Any.toObject(message.metadata, options);
                return object;
            };

            /**
             * Converts this Operation to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.Operation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Operation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Operation;
        })();

        return Operations;
    })();

    Ydb.Limit = (function() {

        /**
         * Properties of a Limit.
         * @memberof Ydb
         * @interface ILimit
         * @property {Ydb.Limit.IRange|null} [range] Limit range
         * @property {number|null} [lt] Limit lt
         * @property {number|null} [le] Limit le
         * @property {number|null} [eq] Limit eq
         * @property {number|null} [ge] Limit ge
         * @property {number|null} [gt] Limit gt
         */

        /**
         * Constructs a new Limit.
         * @memberof Ydb
         * @classdesc Represents a Limit.
         * @implements ILimit
         * @constructor
         * @param {Ydb.ILimit=} [properties] Properties to set
         */
        function Limit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Limit range.
         * @member {Ydb.Limit.IRange|null|undefined} range
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.range = null;

        /**
         * Limit lt.
         * @member {number} lt
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.lt = 0;

        /**
         * Limit le.
         * @member {number} le
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.le = 0;

        /**
         * Limit eq.
         * @member {number} eq
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.eq = 0;

        /**
         * Limit ge.
         * @member {number} ge
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.ge = 0;

        /**
         * Limit gt.
         * @member {number} gt
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.gt = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Limit kind.
         * @member {"range"|"lt"|"le"|"eq"|"ge"|"gt"|undefined} kind
         * @memberof Ydb.Limit
         * @instance
         */
        Object.defineProperty(Limit.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["range", "lt", "le", "eq", "ge", "gt"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Limit instance using the specified properties.
         * @function create
         * @memberof Ydb.Limit
         * @static
         * @param {Ydb.ILimit=} [properties] Properties to set
         * @returns {Ydb.Limit} Limit instance
         */
        Limit.create = function create(properties) {
            return new Limit(properties);
        };

        /**
         * Encodes the specified Limit message. Does not implicitly {@link Ydb.Limit.verify|verify} messages.
         * @function encode
         * @memberof Ydb.Limit
         * @static
         * @param {Ydb.ILimit} message Limit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Limit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.range != null && message.hasOwnProperty("range"))
                $root.Ydb.Limit.Range.encode(message.range, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lt != null && message.hasOwnProperty("lt"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lt);
            if (message.le != null && message.hasOwnProperty("le"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.le);
            if (message.eq != null && message.hasOwnProperty("eq"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.eq);
            if (message.ge != null && message.hasOwnProperty("ge"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.ge);
            if (message.gt != null && message.hasOwnProperty("gt"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.gt);
            return writer;
        };

        /**
         * Encodes the specified Limit message, length delimited. Does not implicitly {@link Ydb.Limit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.Limit
         * @static
         * @param {Ydb.ILimit} message Limit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Limit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Limit message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.Limit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.Limit} Limit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Limit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Limit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.range = $root.Ydb.Limit.Range.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.lt = reader.uint32();
                    break;
                case 3:
                    message.le = reader.uint32();
                    break;
                case 4:
                    message.eq = reader.uint32();
                    break;
                case 5:
                    message.ge = reader.uint32();
                    break;
                case 6:
                    message.gt = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Limit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.Limit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.Limit} Limit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Limit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Limit message.
         * @function verify
         * @memberof Ydb.Limit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Limit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.range != null && message.hasOwnProperty("range")) {
                properties.kind = 1;
                {
                    var error = $root.Ydb.Limit.Range.verify(message.range);
                    if (error)
                        return "range." + error;
                }
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            }
            if (message.le != null && message.hasOwnProperty("le")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.le))
                    return "le: integer expected";
            }
            if (message.eq != null && message.hasOwnProperty("eq")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.eq))
                    return "eq: integer expected";
            }
            if (message.ge != null && message.hasOwnProperty("ge")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.ge))
                    return "ge: integer expected";
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            }
            return null;
        };

        /**
         * Creates a Limit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.Limit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.Limit} Limit
         */
        Limit.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.Limit)
                return object;
            var message = new $root.Ydb.Limit();
            if (object.range != null) {
                if (typeof object.range !== "object")
                    throw TypeError(".Ydb.Limit.range: object expected");
                message.range = $root.Ydb.Limit.Range.fromObject(object.range);
            }
            if (object.lt != null)
                message.lt = object.lt >>> 0;
            if (object.le != null)
                message.le = object.le >>> 0;
            if (object.eq != null)
                message.eq = object.eq >>> 0;
            if (object.ge != null)
                message.ge = object.ge >>> 0;
            if (object.gt != null)
                message.gt = object.gt >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Limit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.Limit
         * @static
         * @param {Ydb.Limit} message Limit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Limit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.range != null && message.hasOwnProperty("range")) {
                object.range = $root.Ydb.Limit.Range.toObject(message.range, options);
                if (options.oneofs)
                    object.kind = "range";
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                object.lt = message.lt;
                if (options.oneofs)
                    object.kind = "lt";
            }
            if (message.le != null && message.hasOwnProperty("le")) {
                object.le = message.le;
                if (options.oneofs)
                    object.kind = "le";
            }
            if (message.eq != null && message.hasOwnProperty("eq")) {
                object.eq = message.eq;
                if (options.oneofs)
                    object.kind = "eq";
            }
            if (message.ge != null && message.hasOwnProperty("ge")) {
                object.ge = message.ge;
                if (options.oneofs)
                    object.kind = "ge";
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                object.gt = message.gt;
                if (options.oneofs)
                    object.kind = "gt";
            }
            return object;
        };

        /**
         * Converts this Limit to JSON.
         * @function toJSON
         * @memberof Ydb.Limit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Limit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Limit.Range = (function() {

            /**
             * Properties of a Range.
             * @memberof Ydb.Limit
             * @interface IRange
             * @property {number|null} [min] Range min
             * @property {number|null} [max] Range max
             */

            /**
             * Constructs a new Range.
             * @memberof Ydb.Limit
             * @classdesc Represents a Range.
             * @implements IRange
             * @constructor
             * @param {Ydb.Limit.IRange=} [properties] Properties to set
             */
            function Range(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Range min.
             * @member {number} min
             * @memberof Ydb.Limit.Range
             * @instance
             */
            Range.prototype.min = 0;

            /**
             * Range max.
             * @member {number} max
             * @memberof Ydb.Limit.Range
             * @instance
             */
            Range.prototype.max = 0;

            /**
             * Creates a new Range instance using the specified properties.
             * @function create
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Ydb.Limit.IRange=} [properties] Properties to set
             * @returns {Ydb.Limit.Range} Range instance
             */
            Range.create = function create(properties) {
                return new Range(properties);
            };

            /**
             * Encodes the specified Range message. Does not implicitly {@link Ydb.Limit.Range.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Ydb.Limit.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.min != null && message.hasOwnProperty("min"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.min);
                if (message.max != null && message.hasOwnProperty("max"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.max);
                return writer;
            };

            /**
             * Encodes the specified Range message, length delimited. Does not implicitly {@link Ydb.Limit.Range.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Ydb.Limit.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Range message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Limit.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Limit.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Limit.Range();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.min = reader.uint32();
                        break;
                    case 2:
                        message.max = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Range message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Limit.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Limit.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Range message.
             * @function verify
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Range.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.min != null && message.hasOwnProperty("min"))
                    if (!$util.isInteger(message.min))
                        return "min: integer expected";
                if (message.max != null && message.hasOwnProperty("max"))
                    if (!$util.isInteger(message.max))
                        return "max: integer expected";
                return null;
            };

            /**
             * Creates a Range message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Limit.Range} Range
             */
            Range.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Limit.Range)
                    return object;
                var message = new $root.Ydb.Limit.Range();
                if (object.min != null)
                    message.min = object.min >>> 0;
                if (object.max != null)
                    message.max = object.max >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Range message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Ydb.Limit.Range} message Range
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Range.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.min = 0;
                    object.max = 0;
                }
                if (message.min != null && message.hasOwnProperty("min"))
                    object.min = message.min;
                if (message.max != null && message.hasOwnProperty("max"))
                    object.max = message.max;
                return object;
            };

            /**
             * Converts this Range to JSON.
             * @function toJSON
             * @memberof Ydb.Limit.Range
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Range.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Range;
        })();

        return Limit;
    })();

    Ydb.MapKey = (function() {

        /**
         * Properties of a MapKey.
         * @memberof Ydb
         * @interface IMapKey
         * @property {Ydb.ILimit|null} [length] MapKey length
         */

        /**
         * Constructs a new MapKey.
         * @memberof Ydb
         * @classdesc Represents a MapKey.
         * @implements IMapKey
         * @constructor
         * @param {Ydb.IMapKey=} [properties] Properties to set
         */
        function MapKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapKey length.
         * @member {Ydb.ILimit|null|undefined} length
         * @memberof Ydb.MapKey
         * @instance
         */
        MapKey.prototype.length = null;

        /**
         * Creates a new MapKey instance using the specified properties.
         * @function create
         * @memberof Ydb.MapKey
         * @static
         * @param {Ydb.IMapKey=} [properties] Properties to set
         * @returns {Ydb.MapKey} MapKey instance
         */
        MapKey.create = function create(properties) {
            return new MapKey(properties);
        };

        /**
         * Encodes the specified MapKey message. Does not implicitly {@link Ydb.MapKey.verify|verify} messages.
         * @function encode
         * @memberof Ydb.MapKey
         * @static
         * @param {Ydb.IMapKey} message MapKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.length != null && message.hasOwnProperty("length"))
                $root.Ydb.Limit.encode(message.length, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MapKey message, length delimited. Does not implicitly {@link Ydb.MapKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.MapKey
         * @static
         * @param {Ydb.IMapKey} message MapKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapKey message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.MapKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.MapKey} MapKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.MapKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.length = $root.Ydb.Limit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MapKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.MapKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.MapKey} MapKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapKey message.
         * @function verify
         * @memberof Ydb.MapKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.length != null && message.hasOwnProperty("length")) {
                var error = $root.Ydb.Limit.verify(message.length);
                if (error)
                    return "length." + error;
            }
            return null;
        };

        /**
         * Creates a MapKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.MapKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.MapKey} MapKey
         */
        MapKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.MapKey)
                return object;
            var message = new $root.Ydb.MapKey();
            if (object.length != null) {
                if (typeof object.length !== "object")
                    throw TypeError(".Ydb.MapKey.length: object expected");
                message.length = $root.Ydb.Limit.fromObject(object.length);
            }
            return message;
        };

        /**
         * Creates a plain object from a MapKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.MapKey
         * @static
         * @param {Ydb.MapKey} message MapKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.length = null;
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = $root.Ydb.Limit.toObject(message.length, options);
            return object;
        };

        /**
         * Converts this MapKey to JSON.
         * @function toJSON
         * @memberof Ydb.MapKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapKey;
    })();

    Ydb.Issue = (function() {

        /**
         * Namespace Issue.
         * @memberof Ydb
         * @namespace
         */
        var Issue = {};

        Issue.IssueMessage = (function() {

            /**
             * Properties of an IssueMessage.
             * @memberof Ydb.Issue
             * @interface IIssueMessage
             * @property {Ydb.Issue.IssueMessage.IPosition|null} [position] IssueMessage position
             * @property {string|null} [message] IssueMessage message
             * @property {Ydb.Issue.IssueMessage.IPosition|null} [endPosition] IssueMessage endPosition
             * @property {number|null} [issueCode] IssueMessage issueCode
             * @property {number|null} [severity] IssueMessage severity
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] IssueMessage issues
             */

            /**
             * Constructs a new IssueMessage.
             * @memberof Ydb.Issue
             * @classdesc Represents an IssueMessage.
             * @implements IIssueMessage
             * @constructor
             * @param {Ydb.Issue.IIssueMessage=} [properties] Properties to set
             */
            function IssueMessage(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IssueMessage position.
             * @member {Ydb.Issue.IssueMessage.IPosition|null|undefined} position
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.position = null;

            /**
             * IssueMessage message.
             * @member {string} message
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.message = "";

            /**
             * IssueMessage endPosition.
             * @member {Ydb.Issue.IssueMessage.IPosition|null|undefined} endPosition
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.endPosition = null;

            /**
             * IssueMessage issueCode.
             * @member {number} issueCode
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.issueCode = 0;

            /**
             * IssueMessage severity.
             * @member {number} severity
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.severity = 0;

            /**
             * IssueMessage issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.issues = $util.emptyArray;

            /**
             * Creates a new IssueMessage instance using the specified properties.
             * @function create
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Ydb.Issue.IIssueMessage=} [properties] Properties to set
             * @returns {Ydb.Issue.IssueMessage} IssueMessage instance
             */
            IssueMessage.create = function create(properties) {
                return new IssueMessage(properties);
            };

            /**
             * Encodes the specified IssueMessage message. Does not implicitly {@link Ydb.Issue.IssueMessage.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Ydb.Issue.IIssueMessage} message IssueMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IssueMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && message.hasOwnProperty("position"))
                    $root.Ydb.Issue.IssueMessage.Position.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.endPosition != null && message.hasOwnProperty("endPosition"))
                    $root.Ydb.Issue.IssueMessage.Position.encode(message.endPosition, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.issueCode != null && message.hasOwnProperty("issueCode"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.issueCode);
                if (message.severity != null && message.hasOwnProperty("severity"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.severity);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IssueMessage message, length delimited. Does not implicitly {@link Ydb.Issue.IssueMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Ydb.Issue.IIssueMessage} message IssueMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IssueMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IssueMessage message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Issue.IssueMessage} IssueMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IssueMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Issue.IssueMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.Ydb.Issue.IssueMessage.Position.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.endPosition = $root.Ydb.Issue.IssueMessage.Position.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.issueCode = reader.uint32();
                        break;
                    case 5:
                        message.severity = reader.uint32();
                        break;
                    case 6:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IssueMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Issue.IssueMessage} IssueMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IssueMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IssueMessage message.
             * @function verify
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IssueMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.Ydb.Issue.IssueMessage.Position.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.endPosition != null && message.hasOwnProperty("endPosition")) {
                    var error = $root.Ydb.Issue.IssueMessage.Position.verify(message.endPosition);
                    if (error)
                        return "endPosition." + error;
                }
                if (message.issueCode != null && message.hasOwnProperty("issueCode"))
                    if (!$util.isInteger(message.issueCode))
                        return "issueCode: integer expected";
                if (message.severity != null && message.hasOwnProperty("severity"))
                    if (!$util.isInteger(message.severity))
                        return "severity: integer expected";
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an IssueMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Issue.IssueMessage} IssueMessage
             */
            IssueMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Issue.IssueMessage)
                    return object;
                var message = new $root.Ydb.Issue.IssueMessage();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".Ydb.Issue.IssueMessage.position: object expected");
                    message.position = $root.Ydb.Issue.IssueMessage.Position.fromObject(object.position);
                }
                if (object.message != null)
                    message.message = String(object.message);
                if (object.endPosition != null) {
                    if (typeof object.endPosition !== "object")
                        throw TypeError(".Ydb.Issue.IssueMessage.endPosition: object expected");
                    message.endPosition = $root.Ydb.Issue.IssueMessage.Position.fromObject(object.endPosition);
                }
                if (object.issueCode != null)
                    message.issueCode = object.issueCode >>> 0;
                if (object.severity != null)
                    message.severity = object.severity >>> 0;
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Issue.IssueMessage.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Issue.IssueMessage.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an IssueMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Ydb.Issue.IssueMessage} message IssueMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IssueMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults) {
                    object.position = null;
                    object.message = "";
                    object.endPosition = null;
                    object.issueCode = 0;
                    object.severity = 0;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.Ydb.Issue.IssueMessage.Position.toObject(message.position, options);
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.endPosition != null && message.hasOwnProperty("endPosition"))
                    object.endPosition = $root.Ydb.Issue.IssueMessage.Position.toObject(message.endPosition, options);
                if (message.issueCode != null && message.hasOwnProperty("issueCode"))
                    object.issueCode = message.issueCode;
                if (message.severity != null && message.hasOwnProperty("severity"))
                    object.severity = message.severity;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                return object;
            };

            /**
             * Converts this IssueMessage to JSON.
             * @function toJSON
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IssueMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            IssueMessage.Position = (function() {

                /**
                 * Properties of a Position.
                 * @memberof Ydb.Issue.IssueMessage
                 * @interface IPosition
                 * @property {number|null} [row] Position row
                 * @property {number|null} [column] Position column
                 * @property {string|null} [file] Position file
                 */

                /**
                 * Constructs a new Position.
                 * @memberof Ydb.Issue.IssueMessage
                 * @classdesc Represents a Position.
                 * @implements IPosition
                 * @constructor
                 * @param {Ydb.Issue.IssueMessage.IPosition=} [properties] Properties to set
                 */
                function Position(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Position row.
                 * @member {number} row
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @instance
                 */
                Position.prototype.row = 0;

                /**
                 * Position column.
                 * @member {number} column
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @instance
                 */
                Position.prototype.column = 0;

                /**
                 * Position file.
                 * @member {string} file
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @instance
                 */
                Position.prototype.file = "";

                /**
                 * Creates a new Position instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Ydb.Issue.IssueMessage.IPosition=} [properties] Properties to set
                 * @returns {Ydb.Issue.IssueMessage.Position} Position instance
                 */
                Position.create = function create(properties) {
                    return new Position(properties);
                };

                /**
                 * Encodes the specified Position message. Does not implicitly {@link Ydb.Issue.IssueMessage.Position.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Ydb.Issue.IssueMessage.IPosition} message Position message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Position.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.row != null && message.hasOwnProperty("row"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.row);
                    if (message.column != null && message.hasOwnProperty("column"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.column);
                    if (message.file != null && message.hasOwnProperty("file"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.file);
                    return writer;
                };

                /**
                 * Encodes the specified Position message, length delimited. Does not implicitly {@link Ydb.Issue.IssueMessage.Position.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Ydb.Issue.IssueMessage.IPosition} message Position message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Position.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Position message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Issue.IssueMessage.Position} Position
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Position.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Issue.IssueMessage.Position();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.row = reader.uint32();
                            break;
                        case 2:
                            message.column = reader.uint32();
                            break;
                        case 3:
                            message.file = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Position message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Issue.IssueMessage.Position} Position
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Position.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Position message.
                 * @function verify
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Position.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.row != null && message.hasOwnProperty("row"))
                        if (!$util.isInteger(message.row))
                            return "row: integer expected";
                    if (message.column != null && message.hasOwnProperty("column"))
                        if (!$util.isInteger(message.column))
                            return "column: integer expected";
                    if (message.file != null && message.hasOwnProperty("file"))
                        if (!$util.isString(message.file))
                            return "file: string expected";
                    return null;
                };

                /**
                 * Creates a Position message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Issue.IssueMessage.Position} Position
                 */
                Position.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Issue.IssueMessage.Position)
                        return object;
                    var message = new $root.Ydb.Issue.IssueMessage.Position();
                    if (object.row != null)
                        message.row = object.row >>> 0;
                    if (object.column != null)
                        message.column = object.column >>> 0;
                    if (object.file != null)
                        message.file = String(object.file);
                    return message;
                };

                /**
                 * Creates a plain object from a Position message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Ydb.Issue.IssueMessage.Position} message Position
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Position.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.row = 0;
                        object.column = 0;
                        object.file = "";
                    }
                    if (message.row != null && message.hasOwnProperty("row"))
                        object.row = message.row;
                    if (message.column != null && message.hasOwnProperty("column"))
                        object.column = message.column;
                    if (message.file != null && message.hasOwnProperty("file"))
                        object.file = message.file;
                    return object;
                };

                /**
                 * Converts this Position to JSON.
                 * @function toJSON
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Position.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Position;
            })();

            return IssueMessage;
        })();

        return Issue;
    })();

    Ydb.StatusIds = (function() {

        /**
         * Properties of a StatusIds.
         * @memberof Ydb
         * @interface IStatusIds
         */

        /**
         * Constructs a new StatusIds.
         * @memberof Ydb
         * @classdesc Represents a StatusIds.
         * @implements IStatusIds
         * @constructor
         * @param {Ydb.IStatusIds=} [properties] Properties to set
         */
        function StatusIds(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StatusIds instance using the specified properties.
         * @function create
         * @memberof Ydb.StatusIds
         * @static
         * @param {Ydb.IStatusIds=} [properties] Properties to set
         * @returns {Ydb.StatusIds} StatusIds instance
         */
        StatusIds.create = function create(properties) {
            return new StatusIds(properties);
        };

        /**
         * Encodes the specified StatusIds message. Does not implicitly {@link Ydb.StatusIds.verify|verify} messages.
         * @function encode
         * @memberof Ydb.StatusIds
         * @static
         * @param {Ydb.IStatusIds} message StatusIds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusIds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StatusIds message, length delimited. Does not implicitly {@link Ydb.StatusIds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.StatusIds
         * @static
         * @param {Ydb.IStatusIds} message StatusIds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusIds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StatusIds message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.StatusIds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.StatusIds} StatusIds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusIds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.StatusIds();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StatusIds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.StatusIds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.StatusIds} StatusIds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusIds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StatusIds message.
         * @function verify
         * @memberof Ydb.StatusIds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StatusIds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StatusIds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.StatusIds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.StatusIds} StatusIds
         */
        StatusIds.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.StatusIds)
                return object;
            return new $root.Ydb.StatusIds();
        };

        /**
         * Creates a plain object from a StatusIds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.StatusIds
         * @static
         * @param {Ydb.StatusIds} message StatusIds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StatusIds.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StatusIds to JSON.
         * @function toJSON
         * @memberof Ydb.StatusIds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StatusIds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * StatusCode enum.
         * @name Ydb.StatusIds.StatusCode
         * @enum {string}
         * @property {number} STATUS_CODE_UNSPECIFIED=0 STATUS_CODE_UNSPECIFIED value
         * @property {number} SUCCESS=400000 SUCCESS value
         * @property {number} BAD_REQUEST=400010 BAD_REQUEST value
         * @property {number} UNAUTHORIZED=400020 UNAUTHORIZED value
         * @property {number} INTERNAL_ERROR=400030 INTERNAL_ERROR value
         * @property {number} ABORTED=400040 ABORTED value
         * @property {number} UNAVAILABLE=400050 UNAVAILABLE value
         * @property {number} OVERLOADED=400060 OVERLOADED value
         * @property {number} SCHEME_ERROR=400070 SCHEME_ERROR value
         * @property {number} GENERIC_ERROR=400080 GENERIC_ERROR value
         * @property {number} TIMEOUT=400090 TIMEOUT value
         * @property {number} BAD_SESSION=400100 BAD_SESSION value
         * @property {number} PRECONDITION_FAILED=400120 PRECONDITION_FAILED value
         * @property {number} ALREADY_EXISTS=400130 ALREADY_EXISTS value
         * @property {number} NOT_FOUND=400140 NOT_FOUND value
         * @property {number} SESSION_EXPIRED=400150 SESSION_EXPIRED value
         * @property {number} CANCELLED=400160 CANCELLED value
         * @property {number} UNDETERMINED=400170 UNDETERMINED value
         * @property {number} UNSUPPORTED=400180 UNSUPPORTED value
         * @property {number} SESSION_BUSY=400190 SESSION_BUSY value
         */
        StatusIds.StatusCode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STATUS_CODE_UNSPECIFIED"] = 0;
            values[valuesById[400000] = "SUCCESS"] = 400000;
            values[valuesById[400010] = "BAD_REQUEST"] = 400010;
            values[valuesById[400020] = "UNAUTHORIZED"] = 400020;
            values[valuesById[400030] = "INTERNAL_ERROR"] = 400030;
            values[valuesById[400040] = "ABORTED"] = 400040;
            values[valuesById[400050] = "UNAVAILABLE"] = 400050;
            values[valuesById[400060] = "OVERLOADED"] = 400060;
            values[valuesById[400070] = "SCHEME_ERROR"] = 400070;
            values[valuesById[400080] = "GENERIC_ERROR"] = 400080;
            values[valuesById[400090] = "TIMEOUT"] = 400090;
            values[valuesById[400100] = "BAD_SESSION"] = 400100;
            values[valuesById[400120] = "PRECONDITION_FAILED"] = 400120;
            values[valuesById[400130] = "ALREADY_EXISTS"] = 400130;
            values[valuesById[400140] = "NOT_FOUND"] = 400140;
            values[valuesById[400150] = "SESSION_EXPIRED"] = 400150;
            values[valuesById[400160] = "CANCELLED"] = 400160;
            values[valuesById[400170] = "UNDETERMINED"] = 400170;
            values[valuesById[400180] = "UNSUPPORTED"] = 400180;
            values[valuesById[400190] = "SESSION_BUSY"] = 400190;
            return values;
        })();

        return StatusIds;
    })();

    Ydb.Coordination = (function() {

        /**
         * Namespace Coordination.
         * @memberof Ydb
         * @namespace
         */
        var Coordination = {};

        Coordination.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Coordination
             * @namespace
             */
            var V1 = {};

            V1.CoordinationService = (function() {

                /**
                 * Constructs a new CoordinationService service.
                 * @memberof Ydb.Coordination.V1
                 * @classdesc Represents a CoordinationService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function CoordinationService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (CoordinationService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CoordinationService;

                /**
                 * Creates new CoordinationService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {CoordinationService} RPC service. Useful where requests and/or responses are streamed.
                 */
                CoordinationService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Coordination.V1.CoordinationService#session}.
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @typedef SessionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Coordination.SessionResponse} [response] SessionResponse
                 */

                /**
                 * Bidirectional stream used to establish a session with a coordination node
                 * 
                 * Relevant APIs for managing semaphores, distributed locking, creating or
                 * restoring a previously established session are described using nested
                 * messages in SessionRequest and SessionResponse. Session is established
                 * with a specific coordination node (previously created using CreateNode
                 * below) and semaphores are local to that coordination node.
                 * @function session
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.ISessionRequest} request SessionRequest message or plain object
                 * @param {Ydb.Coordination.V1.CoordinationService.SessionCallback} callback Node-style callback called with the error, if any, and SessionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CoordinationService.prototype.session = function session(request, callback) {
                    return this.rpcCall(session, $root.Ydb.Coordination.SessionRequest, $root.Ydb.Coordination.SessionResponse, request, callback);
                }, "name", { value: "Session" });

                /**
                 * Bidirectional stream used to establish a session with a coordination node
                 * 
                 * Relevant APIs for managing semaphores, distributed locking, creating or
                 * restoring a previously established session are described using nested
                 * messages in SessionRequest and SessionResponse. Session is established
                 * with a specific coordination node (previously created using CreateNode
                 * below) and semaphores are local to that coordination node.
                 * @function session
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.ISessionRequest} request SessionRequest message or plain object
                 * @returns {Promise<Ydb.Coordination.SessionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Coordination.V1.CoordinationService#createNode}.
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @typedef CreateNodeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Coordination.CreateNodeResponse} [response] CreateNodeResponse
                 */

                /**
                 * Calls CreateNode.
                 * @function createNode
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.ICreateNodeRequest} request CreateNodeRequest message or plain object
                 * @param {Ydb.Coordination.V1.CoordinationService.CreateNodeCallback} callback Node-style callback called with the error, if any, and CreateNodeResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CoordinationService.prototype.createNode = function createNode(request, callback) {
                    return this.rpcCall(createNode, $root.Ydb.Coordination.CreateNodeRequest, $root.Ydb.Coordination.CreateNodeResponse, request, callback);
                }, "name", { value: "CreateNode" });

                /**
                 * Calls CreateNode.
                 * @function createNode
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.ICreateNodeRequest} request CreateNodeRequest message or plain object
                 * @returns {Promise<Ydb.Coordination.CreateNodeResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Coordination.V1.CoordinationService#alterNode}.
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @typedef AlterNodeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Coordination.AlterNodeResponse} [response] AlterNodeResponse
                 */

                /**
                 * Calls AlterNode.
                 * @function alterNode
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.IAlterNodeRequest} request AlterNodeRequest message or plain object
                 * @param {Ydb.Coordination.V1.CoordinationService.AlterNodeCallback} callback Node-style callback called with the error, if any, and AlterNodeResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CoordinationService.prototype.alterNode = function alterNode(request, callback) {
                    return this.rpcCall(alterNode, $root.Ydb.Coordination.AlterNodeRequest, $root.Ydb.Coordination.AlterNodeResponse, request, callback);
                }, "name", { value: "AlterNode" });

                /**
                 * Calls AlterNode.
                 * @function alterNode
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.IAlterNodeRequest} request AlterNodeRequest message or plain object
                 * @returns {Promise<Ydb.Coordination.AlterNodeResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Coordination.V1.CoordinationService#dropNode}.
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @typedef DropNodeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Coordination.DropNodeResponse} [response] DropNodeResponse
                 */

                /**
                 * Calls DropNode.
                 * @function dropNode
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.IDropNodeRequest} request DropNodeRequest message or plain object
                 * @param {Ydb.Coordination.V1.CoordinationService.DropNodeCallback} callback Node-style callback called with the error, if any, and DropNodeResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CoordinationService.prototype.dropNode = function dropNode(request, callback) {
                    return this.rpcCall(dropNode, $root.Ydb.Coordination.DropNodeRequest, $root.Ydb.Coordination.DropNodeResponse, request, callback);
                }, "name", { value: "DropNode" });

                /**
                 * Calls DropNode.
                 * @function dropNode
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.IDropNodeRequest} request DropNodeRequest message or plain object
                 * @returns {Promise<Ydb.Coordination.DropNodeResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Coordination.V1.CoordinationService#describeNode}.
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @typedef DescribeNodeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Coordination.DescribeNodeResponse} [response] DescribeNodeResponse
                 */

                /**
                 * Calls DescribeNode.
                 * @function describeNode
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.IDescribeNodeRequest} request DescribeNodeRequest message or plain object
                 * @param {Ydb.Coordination.V1.CoordinationService.DescribeNodeCallback} callback Node-style callback called with the error, if any, and DescribeNodeResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(CoordinationService.prototype.describeNode = function describeNode(request, callback) {
                    return this.rpcCall(describeNode, $root.Ydb.Coordination.DescribeNodeRequest, $root.Ydb.Coordination.DescribeNodeResponse, request, callback);
                }, "name", { value: "DescribeNode" });

                /**
                 * Calls DescribeNode.
                 * @function describeNode
                 * @memberof Ydb.Coordination.V1.CoordinationService
                 * @instance
                 * @param {Ydb.Coordination.IDescribeNodeRequest} request DescribeNodeRequest message or plain object
                 * @returns {Promise<Ydb.Coordination.DescribeNodeResponse>} Promise
                 * @variation 2
                 */

                return CoordinationService;
            })();

            return V1;
        })();

        Coordination.Unsupported = (function() {

            /**
             * Properties of an Unsupported.
             * @memberof Ydb.Coordination
             * @interface IUnsupported
             */

            /**
             * Constructs a new Unsupported.
             * @memberof Ydb.Coordination
             * @classdesc Stub for unsupported messages
             * @implements IUnsupported
             * @constructor
             * @param {Ydb.Coordination.IUnsupported=} [properties] Properties to set
             */
            function Unsupported(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Unsupported instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.Unsupported
             * @static
             * @param {Ydb.Coordination.IUnsupported=} [properties] Properties to set
             * @returns {Ydb.Coordination.Unsupported} Unsupported instance
             */
            Unsupported.create = function create(properties) {
                return new Unsupported(properties);
            };

            /**
             * Encodes the specified Unsupported message. Does not implicitly {@link Ydb.Coordination.Unsupported.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.Unsupported
             * @static
             * @param {Ydb.Coordination.IUnsupported} message Unsupported message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Unsupported.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Unsupported message, length delimited. Does not implicitly {@link Ydb.Coordination.Unsupported.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.Unsupported
             * @static
             * @param {Ydb.Coordination.IUnsupported} message Unsupported message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Unsupported.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Unsupported message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.Unsupported
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.Unsupported} Unsupported
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Unsupported.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.Unsupported();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Unsupported message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.Unsupported
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.Unsupported} Unsupported
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Unsupported.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Unsupported message.
             * @function verify
             * @memberof Ydb.Coordination.Unsupported
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Unsupported.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Unsupported message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.Unsupported
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.Unsupported} Unsupported
             */
            Unsupported.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.Unsupported)
                    return object;
                return new $root.Ydb.Coordination.Unsupported();
            };

            /**
             * Creates a plain object from an Unsupported message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.Unsupported
             * @static
             * @param {Ydb.Coordination.Unsupported} message Unsupported
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Unsupported.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Unsupported to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.Unsupported
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Unsupported.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Unsupported;
        })();

        /**
         * Consistency mode
         * @name Ydb.Coordination.ConsistencyMode
         * @enum {string}
         * @property {number} CONSISTENCY_MODE_UNSET=0 CONSISTENCY_MODE_UNSET value
         * @property {number} CONSISTENCY_MODE_STRICT=1 CONSISTENCY_MODE_STRICT value
         * @property {number} CONSISTENCY_MODE_RELAXED=2 CONSISTENCY_MODE_RELAXED value
         */
        Coordination.ConsistencyMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CONSISTENCY_MODE_UNSET"] = 0;
            values[valuesById[1] = "CONSISTENCY_MODE_STRICT"] = 1;
            values[valuesById[2] = "CONSISTENCY_MODE_RELAXED"] = 2;
            return values;
        })();

        /**
         * Counters mode
         * @name Ydb.Coordination.RateLimiterCountersMode
         * @enum {string}
         * @property {number} RATE_LIMITER_COUNTERS_MODE_UNSET=0 RATE_LIMITER_COUNTERS_MODE_UNSET value
         * @property {number} RATE_LIMITER_COUNTERS_MODE_AGGREGATED=1 RATE_LIMITER_COUNTERS_MODE_AGGREGATED value
         * @property {number} RATE_LIMITER_COUNTERS_MODE_DETAILED=2 RATE_LIMITER_COUNTERS_MODE_DETAILED value
         */
        Coordination.RateLimiterCountersMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "RATE_LIMITER_COUNTERS_MODE_UNSET"] = 0;
            values[valuesById[1] = "RATE_LIMITER_COUNTERS_MODE_AGGREGATED"] = 1;
            values[valuesById[2] = "RATE_LIMITER_COUNTERS_MODE_DETAILED"] = 2;
            return values;
        })();

        Coordination.Config = (function() {

            /**
             * Properties of a Config.
             * @memberof Ydb.Coordination
             * @interface IConfig
             * @property {string|null} [path] Config path
             * @property {number|null} [selfCheckPeriodMillis] Config selfCheckPeriodMillis
             * @property {number|null} [sessionGracePeriodMillis] Config sessionGracePeriodMillis
             * @property {Ydb.Coordination.ConsistencyMode|null} [readConsistencyMode] Config readConsistencyMode
             * @property {Ydb.Coordination.ConsistencyMode|null} [attachConsistencyMode] Config attachConsistencyMode
             * @property {Ydb.Coordination.RateLimiterCountersMode|null} [rateLimiterCountersMode] Config rateLimiterCountersMode
             */

            /**
             * Constructs a new Config.
             * @memberof Ydb.Coordination
             * @classdesc Configuration settings for a coordination node
             * @implements IConfig
             * @constructor
             * @param {Ydb.Coordination.IConfig=} [properties] Properties to set
             */
            function Config(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Config path.
             * @member {string} path
             * @memberof Ydb.Coordination.Config
             * @instance
             */
            Config.prototype.path = "";

            /**
             * Config selfCheckPeriodMillis.
             * @member {number} selfCheckPeriodMillis
             * @memberof Ydb.Coordination.Config
             * @instance
             */
            Config.prototype.selfCheckPeriodMillis = 0;

            /**
             * Config sessionGracePeriodMillis.
             * @member {number} sessionGracePeriodMillis
             * @memberof Ydb.Coordination.Config
             * @instance
             */
            Config.prototype.sessionGracePeriodMillis = 0;

            /**
             * Config readConsistencyMode.
             * @member {Ydb.Coordination.ConsistencyMode} readConsistencyMode
             * @memberof Ydb.Coordination.Config
             * @instance
             */
            Config.prototype.readConsistencyMode = 0;

            /**
             * Config attachConsistencyMode.
             * @member {Ydb.Coordination.ConsistencyMode} attachConsistencyMode
             * @memberof Ydb.Coordination.Config
             * @instance
             */
            Config.prototype.attachConsistencyMode = 0;

            /**
             * Config rateLimiterCountersMode.
             * @member {Ydb.Coordination.RateLimiterCountersMode} rateLimiterCountersMode
             * @memberof Ydb.Coordination.Config
             * @instance
             */
            Config.prototype.rateLimiterCountersMode = 0;

            /**
             * Creates a new Config instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.Config
             * @static
             * @param {Ydb.Coordination.IConfig=} [properties] Properties to set
             * @returns {Ydb.Coordination.Config} Config instance
             */
            Config.create = function create(properties) {
                return new Config(properties);
            };

            /**
             * Encodes the specified Config message. Does not implicitly {@link Ydb.Coordination.Config.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.Config
             * @static
             * @param {Ydb.Coordination.IConfig} message Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Config.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.selfCheckPeriodMillis != null && message.hasOwnProperty("selfCheckPeriodMillis"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.selfCheckPeriodMillis);
                if (message.sessionGracePeriodMillis != null && message.hasOwnProperty("sessionGracePeriodMillis"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sessionGracePeriodMillis);
                if (message.readConsistencyMode != null && message.hasOwnProperty("readConsistencyMode"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.readConsistencyMode);
                if (message.attachConsistencyMode != null && message.hasOwnProperty("attachConsistencyMode"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.attachConsistencyMode);
                if (message.rateLimiterCountersMode != null && message.hasOwnProperty("rateLimiterCountersMode"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.rateLimiterCountersMode);
                return writer;
            };

            /**
             * Encodes the specified Config message, length delimited. Does not implicitly {@link Ydb.Coordination.Config.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.Config
             * @static
             * @param {Ydb.Coordination.IConfig} message Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Config.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Config message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.Config} Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Config.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.Config();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.selfCheckPeriodMillis = reader.uint32();
                        break;
                    case 3:
                        message.sessionGracePeriodMillis = reader.uint32();
                        break;
                    case 4:
                        message.readConsistencyMode = reader.int32();
                        break;
                    case 5:
                        message.attachConsistencyMode = reader.int32();
                        break;
                    case 6:
                        message.rateLimiterCountersMode = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Config message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.Config} Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Config.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Config message.
             * @function verify
             * @memberof Ydb.Coordination.Config
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Config.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.selfCheckPeriodMillis != null && message.hasOwnProperty("selfCheckPeriodMillis"))
                    if (!$util.isInteger(message.selfCheckPeriodMillis))
                        return "selfCheckPeriodMillis: integer expected";
                if (message.sessionGracePeriodMillis != null && message.hasOwnProperty("sessionGracePeriodMillis"))
                    if (!$util.isInteger(message.sessionGracePeriodMillis))
                        return "sessionGracePeriodMillis: integer expected";
                if (message.readConsistencyMode != null && message.hasOwnProperty("readConsistencyMode"))
                    switch (message.readConsistencyMode) {
                    default:
                        return "readConsistencyMode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.attachConsistencyMode != null && message.hasOwnProperty("attachConsistencyMode"))
                    switch (message.attachConsistencyMode) {
                    default:
                        return "attachConsistencyMode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.rateLimiterCountersMode != null && message.hasOwnProperty("rateLimiterCountersMode"))
                    switch (message.rateLimiterCountersMode) {
                    default:
                        return "rateLimiterCountersMode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Config message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.Config
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.Config} Config
             */
            Config.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.Config)
                    return object;
                var message = new $root.Ydb.Coordination.Config();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.selfCheckPeriodMillis != null)
                    message.selfCheckPeriodMillis = object.selfCheckPeriodMillis >>> 0;
                if (object.sessionGracePeriodMillis != null)
                    message.sessionGracePeriodMillis = object.sessionGracePeriodMillis >>> 0;
                switch (object.readConsistencyMode) {
                case "CONSISTENCY_MODE_UNSET":
                case 0:
                    message.readConsistencyMode = 0;
                    break;
                case "CONSISTENCY_MODE_STRICT":
                case 1:
                    message.readConsistencyMode = 1;
                    break;
                case "CONSISTENCY_MODE_RELAXED":
                case 2:
                    message.readConsistencyMode = 2;
                    break;
                }
                switch (object.attachConsistencyMode) {
                case "CONSISTENCY_MODE_UNSET":
                case 0:
                    message.attachConsistencyMode = 0;
                    break;
                case "CONSISTENCY_MODE_STRICT":
                case 1:
                    message.attachConsistencyMode = 1;
                    break;
                case "CONSISTENCY_MODE_RELAXED":
                case 2:
                    message.attachConsistencyMode = 2;
                    break;
                }
                switch (object.rateLimiterCountersMode) {
                case "RATE_LIMITER_COUNTERS_MODE_UNSET":
                case 0:
                    message.rateLimiterCountersMode = 0;
                    break;
                case "RATE_LIMITER_COUNTERS_MODE_AGGREGATED":
                case 1:
                    message.rateLimiterCountersMode = 1;
                    break;
                case "RATE_LIMITER_COUNTERS_MODE_DETAILED":
                case 2:
                    message.rateLimiterCountersMode = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Config message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.Config
             * @static
             * @param {Ydb.Coordination.Config} message Config
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Config.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.selfCheckPeriodMillis = 0;
                    object.sessionGracePeriodMillis = 0;
                    object.readConsistencyMode = options.enums === String ? "CONSISTENCY_MODE_UNSET" : 0;
                    object.attachConsistencyMode = options.enums === String ? "CONSISTENCY_MODE_UNSET" : 0;
                    object.rateLimiterCountersMode = options.enums === String ? "RATE_LIMITER_COUNTERS_MODE_UNSET" : 0;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.selfCheckPeriodMillis != null && message.hasOwnProperty("selfCheckPeriodMillis"))
                    object.selfCheckPeriodMillis = message.selfCheckPeriodMillis;
                if (message.sessionGracePeriodMillis != null && message.hasOwnProperty("sessionGracePeriodMillis"))
                    object.sessionGracePeriodMillis = message.sessionGracePeriodMillis;
                if (message.readConsistencyMode != null && message.hasOwnProperty("readConsistencyMode"))
                    object.readConsistencyMode = options.enums === String ? $root.Ydb.Coordination.ConsistencyMode[message.readConsistencyMode] : message.readConsistencyMode;
                if (message.attachConsistencyMode != null && message.hasOwnProperty("attachConsistencyMode"))
                    object.attachConsistencyMode = options.enums === String ? $root.Ydb.Coordination.ConsistencyMode[message.attachConsistencyMode] : message.attachConsistencyMode;
                if (message.rateLimiterCountersMode != null && message.hasOwnProperty("rateLimiterCountersMode"))
                    object.rateLimiterCountersMode = options.enums === String ? $root.Ydb.Coordination.RateLimiterCountersMode[message.rateLimiterCountersMode] : message.rateLimiterCountersMode;
                return object;
            };

            /**
             * Converts this Config to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.Config
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Config.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Config;
        })();

        Coordination.SessionDescription = (function() {

            /**
             * Properties of a SessionDescription.
             * @memberof Ydb.Coordination
             * @interface ISessionDescription
             * @property {number|Long|null} [sessionId] SessionDescription sessionId
             * @property {number|Long|null} [timeoutMillis] SessionDescription timeoutMillis
             * @property {string|null} [description] SessionDescription description
             * @property {boolean|null} [attached] SessionDescription attached
             */

            /**
             * Constructs a new SessionDescription.
             * @memberof Ydb.Coordination
             * @classdesc Describes an active client session
             * @implements ISessionDescription
             * @constructor
             * @param {Ydb.Coordination.ISessionDescription=} [properties] Properties to set
             */
            function SessionDescription(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SessionDescription sessionId.
             * @member {number|Long} sessionId
             * @memberof Ydb.Coordination.SessionDescription
             * @instance
             */
            SessionDescription.prototype.sessionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SessionDescription timeoutMillis.
             * @member {number|Long} timeoutMillis
             * @memberof Ydb.Coordination.SessionDescription
             * @instance
             */
            SessionDescription.prototype.timeoutMillis = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SessionDescription description.
             * @member {string} description
             * @memberof Ydb.Coordination.SessionDescription
             * @instance
             */
            SessionDescription.prototype.description = "";

            /**
             * SessionDescription attached.
             * @member {boolean} attached
             * @memberof Ydb.Coordination.SessionDescription
             * @instance
             */
            SessionDescription.prototype.attached = false;

            /**
             * Creates a new SessionDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.SessionDescription
             * @static
             * @param {Ydb.Coordination.ISessionDescription=} [properties] Properties to set
             * @returns {Ydb.Coordination.SessionDescription} SessionDescription instance
             */
            SessionDescription.create = function create(properties) {
                return new SessionDescription(properties);
            };

            /**
             * Encodes the specified SessionDescription message. Does not implicitly {@link Ydb.Coordination.SessionDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.SessionDescription
             * @static
             * @param {Ydb.Coordination.ISessionDescription} message SessionDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sessionId);
                if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timeoutMillis);
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                if (message.attached != null && message.hasOwnProperty("attached"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.attached);
                return writer;
            };

            /**
             * Encodes the specified SessionDescription message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.SessionDescription
             * @static
             * @param {Ydb.Coordination.ISessionDescription} message SessionDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SessionDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.SessionDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.SessionDescription} SessionDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionDescription();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.uint64();
                        break;
                    case 2:
                        message.timeoutMillis = reader.uint64();
                        break;
                    case 3:
                        message.description = reader.string();
                        break;
                    case 4:
                        message.attached = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SessionDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.SessionDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.SessionDescription} SessionDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SessionDescription message.
             * @function verify
             * @memberof Ydb.Coordination.SessionDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SessionDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isInteger(message.sessionId) && !(message.sessionId && $util.isInteger(message.sessionId.low) && $util.isInteger(message.sessionId.high)))
                        return "sessionId: integer|Long expected";
                if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                    if (!$util.isInteger(message.timeoutMillis) && !(message.timeoutMillis && $util.isInteger(message.timeoutMillis.low) && $util.isInteger(message.timeoutMillis.high)))
                        return "timeoutMillis: integer|Long expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.attached != null && message.hasOwnProperty("attached"))
                    if (typeof message.attached !== "boolean")
                        return "attached: boolean expected";
                return null;
            };

            /**
             * Creates a SessionDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.SessionDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.SessionDescription} SessionDescription
             */
            SessionDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.SessionDescription)
                    return object;
                var message = new $root.Ydb.Coordination.SessionDescription();
                if (object.sessionId != null)
                    if ($util.Long)
                        (message.sessionId = $util.Long.fromValue(object.sessionId)).unsigned = true;
                    else if (typeof object.sessionId === "string")
                        message.sessionId = parseInt(object.sessionId, 10);
                    else if (typeof object.sessionId === "number")
                        message.sessionId = object.sessionId;
                    else if (typeof object.sessionId === "object")
                        message.sessionId = new $util.LongBits(object.sessionId.low >>> 0, object.sessionId.high >>> 0).toNumber(true);
                if (object.timeoutMillis != null)
                    if ($util.Long)
                        (message.timeoutMillis = $util.Long.fromValue(object.timeoutMillis)).unsigned = true;
                    else if (typeof object.timeoutMillis === "string")
                        message.timeoutMillis = parseInt(object.timeoutMillis, 10);
                    else if (typeof object.timeoutMillis === "number")
                        message.timeoutMillis = object.timeoutMillis;
                    else if (typeof object.timeoutMillis === "object")
                        message.timeoutMillis = new $util.LongBits(object.timeoutMillis.low >>> 0, object.timeoutMillis.high >>> 0).toNumber(true);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.attached != null)
                    message.attached = Boolean(object.attached);
                return message;
            };

            /**
             * Creates a plain object from a SessionDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.SessionDescription
             * @static
             * @param {Ydb.Coordination.SessionDescription} message SessionDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SessionDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.sessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sessionId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.timeoutMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timeoutMillis = options.longs === String ? "0" : 0;
                    object.description = "";
                    object.attached = false;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (typeof message.sessionId === "number")
                        object.sessionId = options.longs === String ? String(message.sessionId) : message.sessionId;
                    else
                        object.sessionId = options.longs === String ? $util.Long.prototype.toString.call(message.sessionId) : options.longs === Number ? new $util.LongBits(message.sessionId.low >>> 0, message.sessionId.high >>> 0).toNumber(true) : message.sessionId;
                if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                    if (typeof message.timeoutMillis === "number")
                        object.timeoutMillis = options.longs === String ? String(message.timeoutMillis) : message.timeoutMillis;
                    else
                        object.timeoutMillis = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutMillis) : options.longs === Number ? new $util.LongBits(message.timeoutMillis.low >>> 0, message.timeoutMillis.high >>> 0).toNumber(true) : message.timeoutMillis;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.attached != null && message.hasOwnProperty("attached"))
                    object.attached = message.attached;
                return object;
            };

            /**
             * Converts this SessionDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.SessionDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SessionDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SessionDescription;
        })();

        Coordination.SemaphoreSession = (function() {

            /**
             * Properties of a SemaphoreSession.
             * @memberof Ydb.Coordination
             * @interface ISemaphoreSession
             * @property {number|Long|null} [orderId] SemaphoreSession orderId
             * @property {number|Long|null} [sessionId] SemaphoreSession sessionId
             * @property {number|Long|null} [timeoutMillis] SemaphoreSession timeoutMillis
             * @property {number|Long|null} [count] SemaphoreSession count
             * @property {Uint8Array|null} [data] SemaphoreSession data
             */

            /**
             * Constructs a new SemaphoreSession.
             * @memberof Ydb.Coordination
             * @classdesc Describes an owner or a waiter of this semaphore
             * @implements ISemaphoreSession
             * @constructor
             * @param {Ydb.Coordination.ISemaphoreSession=} [properties] Properties to set
             */
            function SemaphoreSession(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SemaphoreSession orderId.
             * @member {number|Long} orderId
             * @memberof Ydb.Coordination.SemaphoreSession
             * @instance
             */
            SemaphoreSession.prototype.orderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SemaphoreSession sessionId.
             * @member {number|Long} sessionId
             * @memberof Ydb.Coordination.SemaphoreSession
             * @instance
             */
            SemaphoreSession.prototype.sessionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SemaphoreSession timeoutMillis.
             * @member {number|Long} timeoutMillis
             * @memberof Ydb.Coordination.SemaphoreSession
             * @instance
             */
            SemaphoreSession.prototype.timeoutMillis = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SemaphoreSession count.
             * @member {number|Long} count
             * @memberof Ydb.Coordination.SemaphoreSession
             * @instance
             */
            SemaphoreSession.prototype.count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SemaphoreSession data.
             * @member {Uint8Array} data
             * @memberof Ydb.Coordination.SemaphoreSession
             * @instance
             */
            SemaphoreSession.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new SemaphoreSession instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.SemaphoreSession
             * @static
             * @param {Ydb.Coordination.ISemaphoreSession=} [properties] Properties to set
             * @returns {Ydb.Coordination.SemaphoreSession} SemaphoreSession instance
             */
            SemaphoreSession.create = function create(properties) {
                return new SemaphoreSession(properties);
            };

            /**
             * Encodes the specified SemaphoreSession message. Does not implicitly {@link Ydb.Coordination.SemaphoreSession.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.SemaphoreSession
             * @static
             * @param {Ydb.Coordination.ISemaphoreSession} message SemaphoreSession message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SemaphoreSession.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sessionId);
                if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timeoutMillis);
                if (message.count != null && message.hasOwnProperty("count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.count);
                if (message.data != null && message.hasOwnProperty("data"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
                if (message.orderId != null && message.hasOwnProperty("orderId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.orderId);
                return writer;
            };

            /**
             * Encodes the specified SemaphoreSession message, length delimited. Does not implicitly {@link Ydb.Coordination.SemaphoreSession.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.SemaphoreSession
             * @static
             * @param {Ydb.Coordination.ISemaphoreSession} message SemaphoreSession message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SemaphoreSession.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SemaphoreSession message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.SemaphoreSession
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.SemaphoreSession} SemaphoreSession
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SemaphoreSession.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SemaphoreSession();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 5:
                        message.orderId = reader.uint64();
                        break;
                    case 1:
                        message.sessionId = reader.uint64();
                        break;
                    case 2:
                        message.timeoutMillis = reader.uint64();
                        break;
                    case 3:
                        message.count = reader.uint64();
                        break;
                    case 4:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SemaphoreSession message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.SemaphoreSession
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.SemaphoreSession} SemaphoreSession
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SemaphoreSession.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SemaphoreSession message.
             * @function verify
             * @memberof Ydb.Coordination.SemaphoreSession
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SemaphoreSession.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.orderId != null && message.hasOwnProperty("orderId"))
                    if (!$util.isInteger(message.orderId) && !(message.orderId && $util.isInteger(message.orderId.low) && $util.isInteger(message.orderId.high)))
                        return "orderId: integer|Long expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isInteger(message.sessionId) && !(message.sessionId && $util.isInteger(message.sessionId.low) && $util.isInteger(message.sessionId.high)))
                        return "sessionId: integer|Long expected";
                if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                    if (!$util.isInteger(message.timeoutMillis) && !(message.timeoutMillis && $util.isInteger(message.timeoutMillis.low) && $util.isInteger(message.timeoutMillis.high)))
                        return "timeoutMillis: integer|Long expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                        return "count: integer|Long expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };

            /**
             * Creates a SemaphoreSession message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.SemaphoreSession
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.SemaphoreSession} SemaphoreSession
             */
            SemaphoreSession.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.SemaphoreSession)
                    return object;
                var message = new $root.Ydb.Coordination.SemaphoreSession();
                if (object.orderId != null)
                    if ($util.Long)
                        (message.orderId = $util.Long.fromValue(object.orderId)).unsigned = true;
                    else if (typeof object.orderId === "string")
                        message.orderId = parseInt(object.orderId, 10);
                    else if (typeof object.orderId === "number")
                        message.orderId = object.orderId;
                    else if (typeof object.orderId === "object")
                        message.orderId = new $util.LongBits(object.orderId.low >>> 0, object.orderId.high >>> 0).toNumber(true);
                if (object.sessionId != null)
                    if ($util.Long)
                        (message.sessionId = $util.Long.fromValue(object.sessionId)).unsigned = true;
                    else if (typeof object.sessionId === "string")
                        message.sessionId = parseInt(object.sessionId, 10);
                    else if (typeof object.sessionId === "number")
                        message.sessionId = object.sessionId;
                    else if (typeof object.sessionId === "object")
                        message.sessionId = new $util.LongBits(object.sessionId.low >>> 0, object.sessionId.high >>> 0).toNumber(true);
                if (object.timeoutMillis != null)
                    if ($util.Long)
                        (message.timeoutMillis = $util.Long.fromValue(object.timeoutMillis)).unsigned = true;
                    else if (typeof object.timeoutMillis === "string")
                        message.timeoutMillis = parseInt(object.timeoutMillis, 10);
                    else if (typeof object.timeoutMillis === "number")
                        message.timeoutMillis = object.timeoutMillis;
                    else if (typeof object.timeoutMillis === "object")
                        message.timeoutMillis = new $util.LongBits(object.timeoutMillis.low >>> 0, object.timeoutMillis.high >>> 0).toNumber(true);
                if (object.count != null)
                    if ($util.Long)
                        (message.count = $util.Long.fromValue(object.count)).unsigned = true;
                    else if (typeof object.count === "string")
                        message.count = parseInt(object.count, 10);
                    else if (typeof object.count === "number")
                        message.count = object.count;
                    else if (typeof object.count === "object")
                        message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber(true);
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };

            /**
             * Creates a plain object from a SemaphoreSession message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.SemaphoreSession
             * @static
             * @param {Ydb.Coordination.SemaphoreSession} message SemaphoreSession
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SemaphoreSession.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.sessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sessionId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.timeoutMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timeoutMillis = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.count = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.orderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.orderId = options.longs === String ? "0" : 0;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (typeof message.sessionId === "number")
                        object.sessionId = options.longs === String ? String(message.sessionId) : message.sessionId;
                    else
                        object.sessionId = options.longs === String ? $util.Long.prototype.toString.call(message.sessionId) : options.longs === Number ? new $util.LongBits(message.sessionId.low >>> 0, message.sessionId.high >>> 0).toNumber(true) : message.sessionId;
                if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                    if (typeof message.timeoutMillis === "number")
                        object.timeoutMillis = options.longs === String ? String(message.timeoutMillis) : message.timeoutMillis;
                    else
                        object.timeoutMillis = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutMillis) : options.longs === Number ? new $util.LongBits(message.timeoutMillis.low >>> 0, message.timeoutMillis.high >>> 0).toNumber(true) : message.timeoutMillis;
                if (message.count != null && message.hasOwnProperty("count"))
                    if (typeof message.count === "number")
                        object.count = options.longs === String ? String(message.count) : message.count;
                    else
                        object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.orderId != null && message.hasOwnProperty("orderId"))
                    if (typeof message.orderId === "number")
                        object.orderId = options.longs === String ? String(message.orderId) : message.orderId;
                    else
                        object.orderId = options.longs === String ? $util.Long.prototype.toString.call(message.orderId) : options.longs === Number ? new $util.LongBits(message.orderId.low >>> 0, message.orderId.high >>> 0).toNumber(true) : message.orderId;
                return object;
            };

            /**
             * Converts this SemaphoreSession to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.SemaphoreSession
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SemaphoreSession.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SemaphoreSession;
        })();

        Coordination.SemaphoreDescription = (function() {

            /**
             * Properties of a SemaphoreDescription.
             * @memberof Ydb.Coordination
             * @interface ISemaphoreDescription
             * @property {string|null} [name] SemaphoreDescription name
             * @property {Uint8Array|null} [data] SemaphoreDescription data
             * @property {number|Long|null} [count] SemaphoreDescription count
             * @property {number|Long|null} [limit] SemaphoreDescription limit
             * @property {boolean|null} [ephemeral] SemaphoreDescription ephemeral
             * @property {Array.<Ydb.Coordination.ISemaphoreSession>|null} [owners] SemaphoreDescription owners
             * @property {Array.<Ydb.Coordination.ISemaphoreSession>|null} [waiters] SemaphoreDescription waiters
             */

            /**
             * Constructs a new SemaphoreDescription.
             * @memberof Ydb.Coordination
             * @classdesc Describes the state of a semaphore
             * @implements ISemaphoreDescription
             * @constructor
             * @param {Ydb.Coordination.ISemaphoreDescription=} [properties] Properties to set
             */
            function SemaphoreDescription(properties) {
                this.owners = [];
                this.waiters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SemaphoreDescription name.
             * @member {string} name
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @instance
             */
            SemaphoreDescription.prototype.name = "";

            /**
             * SemaphoreDescription data.
             * @member {Uint8Array} data
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @instance
             */
            SemaphoreDescription.prototype.data = $util.newBuffer([]);

            /**
             * SemaphoreDescription count.
             * @member {number|Long} count
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @instance
             */
            SemaphoreDescription.prototype.count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SemaphoreDescription limit.
             * @member {number|Long} limit
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @instance
             */
            SemaphoreDescription.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SemaphoreDescription ephemeral.
             * @member {boolean} ephemeral
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @instance
             */
            SemaphoreDescription.prototype.ephemeral = false;

            /**
             * SemaphoreDescription owners.
             * @member {Array.<Ydb.Coordination.ISemaphoreSession>} owners
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @instance
             */
            SemaphoreDescription.prototype.owners = $util.emptyArray;

            /**
             * SemaphoreDescription waiters.
             * @member {Array.<Ydb.Coordination.ISemaphoreSession>} waiters
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @instance
             */
            SemaphoreDescription.prototype.waiters = $util.emptyArray;

            /**
             * Creates a new SemaphoreDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @static
             * @param {Ydb.Coordination.ISemaphoreDescription=} [properties] Properties to set
             * @returns {Ydb.Coordination.SemaphoreDescription} SemaphoreDescription instance
             */
            SemaphoreDescription.create = function create(properties) {
                return new SemaphoreDescription(properties);
            };

            /**
             * Encodes the specified SemaphoreDescription message. Does not implicitly {@link Ydb.Coordination.SemaphoreDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @static
             * @param {Ydb.Coordination.ISemaphoreDescription} message SemaphoreDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SemaphoreDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && message.hasOwnProperty("data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                if (message.limit != null && message.hasOwnProperty("limit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.limit);
                if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.ephemeral);
                if (message.owners != null && message.owners.length)
                    for (var i = 0; i < message.owners.length; ++i)
                        $root.Ydb.Coordination.SemaphoreSession.encode(message.owners[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.waiters != null && message.waiters.length)
                    for (var i = 0; i < message.waiters.length; ++i)
                        $root.Ydb.Coordination.SemaphoreSession.encode(message.waiters[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.count != null && message.hasOwnProperty("count"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.count);
                return writer;
            };

            /**
             * Encodes the specified SemaphoreDescription message, length delimited. Does not implicitly {@link Ydb.Coordination.SemaphoreDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @static
             * @param {Ydb.Coordination.ISemaphoreDescription} message SemaphoreDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SemaphoreDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SemaphoreDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.SemaphoreDescription} SemaphoreDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SemaphoreDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SemaphoreDescription();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.data = reader.bytes();
                        break;
                    case 7:
                        message.count = reader.uint64();
                        break;
                    case 3:
                        message.limit = reader.uint64();
                        break;
                    case 4:
                        message.ephemeral = reader.bool();
                        break;
                    case 5:
                        if (!(message.owners && message.owners.length))
                            message.owners = [];
                        message.owners.push($root.Ydb.Coordination.SemaphoreSession.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.waiters && message.waiters.length))
                            message.waiters = [];
                        message.waiters.push($root.Ydb.Coordination.SemaphoreSession.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SemaphoreDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.SemaphoreDescription} SemaphoreDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SemaphoreDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SemaphoreDescription message.
             * @function verify
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SemaphoreDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                        return "count: integer|Long expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                        return "limit: integer|Long expected";
                if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                    if (typeof message.ephemeral !== "boolean")
                        return "ephemeral: boolean expected";
                if (message.owners != null && message.hasOwnProperty("owners")) {
                    if (!Array.isArray(message.owners))
                        return "owners: array expected";
                    for (var i = 0; i < message.owners.length; ++i) {
                        var error = $root.Ydb.Coordination.SemaphoreSession.verify(message.owners[i]);
                        if (error)
                            return "owners." + error;
                    }
                }
                if (message.waiters != null && message.hasOwnProperty("waiters")) {
                    if (!Array.isArray(message.waiters))
                        return "waiters: array expected";
                    for (var i = 0; i < message.waiters.length; ++i) {
                        var error = $root.Ydb.Coordination.SemaphoreSession.verify(message.waiters[i]);
                        if (error)
                            return "waiters." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SemaphoreDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.SemaphoreDescription} SemaphoreDescription
             */
            SemaphoreDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.SemaphoreDescription)
                    return object;
                var message = new $root.Ydb.Coordination.SemaphoreDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                if (object.count != null)
                    if ($util.Long)
                        (message.count = $util.Long.fromValue(object.count)).unsigned = true;
                    else if (typeof object.count === "string")
                        message.count = parseInt(object.count, 10);
                    else if (typeof object.count === "number")
                        message.count = object.count;
                    else if (typeof object.count === "object")
                        message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber(true);
                if (object.limit != null)
                    if ($util.Long)
                        (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                    else if (typeof object.limit === "string")
                        message.limit = parseInt(object.limit, 10);
                    else if (typeof object.limit === "number")
                        message.limit = object.limit;
                    else if (typeof object.limit === "object")
                        message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                if (object.ephemeral != null)
                    message.ephemeral = Boolean(object.ephemeral);
                if (object.owners) {
                    if (!Array.isArray(object.owners))
                        throw TypeError(".Ydb.Coordination.SemaphoreDescription.owners: array expected");
                    message.owners = [];
                    for (var i = 0; i < object.owners.length; ++i) {
                        if (typeof object.owners[i] !== "object")
                            throw TypeError(".Ydb.Coordination.SemaphoreDescription.owners: object expected");
                        message.owners[i] = $root.Ydb.Coordination.SemaphoreSession.fromObject(object.owners[i]);
                    }
                }
                if (object.waiters) {
                    if (!Array.isArray(object.waiters))
                        throw TypeError(".Ydb.Coordination.SemaphoreDescription.waiters: array expected");
                    message.waiters = [];
                    for (var i = 0; i < object.waiters.length; ++i) {
                        if (typeof object.waiters[i] !== "object")
                            throw TypeError(".Ydb.Coordination.SemaphoreDescription.waiters: object expected");
                        message.waiters[i] = $root.Ydb.Coordination.SemaphoreSession.fromObject(object.waiters[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SemaphoreDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @static
             * @param {Ydb.Coordination.SemaphoreDescription} message SemaphoreDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SemaphoreDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.owners = [];
                    object.waiters = [];
                }
                if (options.defaults) {
                    object.name = "";
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limit = options.longs === String ? "0" : 0;
                    object.ephemeral = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.count = options.longs === String ? "0" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (typeof message.limit === "number")
                        object.limit = options.longs === String ? String(message.limit) : message.limit;
                    else
                        object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                    object.ephemeral = message.ephemeral;
                if (message.owners && message.owners.length) {
                    object.owners = [];
                    for (var j = 0; j < message.owners.length; ++j)
                        object.owners[j] = $root.Ydb.Coordination.SemaphoreSession.toObject(message.owners[j], options);
                }
                if (message.waiters && message.waiters.length) {
                    object.waiters = [];
                    for (var j = 0; j < message.waiters.length; ++j)
                        object.waiters[j] = $root.Ydb.Coordination.SemaphoreSession.toObject(message.waiters[j], options);
                }
                if (message.count != null && message.hasOwnProperty("count"))
                    if (typeof message.count === "number")
                        object.count = options.longs === String ? String(message.count) : message.count;
                    else
                        object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;
                return object;
            };

            /**
             * Converts this SemaphoreDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.SemaphoreDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SemaphoreDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SemaphoreDescription;
        })();

        Coordination.SessionRequest = (function() {

            /**
             * Properties of a SessionRequest.
             * @memberof Ydb.Coordination
             * @interface ISessionRequest
             * @property {Ydb.Coordination.SessionRequest.IPingPong|null} [ping] SessionRequest ping
             * @property {Ydb.Coordination.SessionRequest.IPingPong|null} [pong] SessionRequest pong
             * @property {Ydb.Coordination.SessionRequest.ISessionStart|null} [sessionStart] SessionRequest sessionStart
             * @property {Ydb.Coordination.SessionRequest.ISessionStop|null} [sessionStop] SessionRequest sessionStop
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_5] SessionRequest unsupported_5
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_6] SessionRequest unsupported_6
             * @property {Ydb.Coordination.SessionRequest.IAcquireSemaphore|null} [acquireSemaphore] SessionRequest acquireSemaphore
             * @property {Ydb.Coordination.SessionRequest.IReleaseSemaphore|null} [releaseSemaphore] SessionRequest releaseSemaphore
             * @property {Ydb.Coordination.SessionRequest.IDescribeSemaphore|null} [describeSemaphore] SessionRequest describeSemaphore
             * @property {Ydb.Coordination.SessionRequest.ICreateSemaphore|null} [createSemaphore] SessionRequest createSemaphore
             * @property {Ydb.Coordination.SessionRequest.IUpdateSemaphore|null} [updateSemaphore] SessionRequest updateSemaphore
             * @property {Ydb.Coordination.SessionRequest.IDeleteSemaphore|null} [deleteSemaphore] SessionRequest deleteSemaphore
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_13] SessionRequest unsupported_13
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_14] SessionRequest unsupported_14
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_15] SessionRequest unsupported_15
             */

            /**
             * Constructs a new SessionRequest.
             * @memberof Ydb.Coordination
             * @classdesc Session request message sent from client to server
             * @implements ISessionRequest
             * @constructor
             * @param {Ydb.Coordination.ISessionRequest=} [properties] Properties to set
             */
            function SessionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SessionRequest ping.
             * @member {Ydb.Coordination.SessionRequest.IPingPong|null|undefined} ping
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.ping = null;

            /**
             * SessionRequest pong.
             * @member {Ydb.Coordination.SessionRequest.IPingPong|null|undefined} pong
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.pong = null;

            /**
             * SessionRequest sessionStart.
             * @member {Ydb.Coordination.SessionRequest.ISessionStart|null|undefined} sessionStart
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.sessionStart = null;

            /**
             * SessionRequest sessionStop.
             * @member {Ydb.Coordination.SessionRequest.ISessionStop|null|undefined} sessionStop
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.sessionStop = null;

            /**
             * SessionRequest unsupported_5.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_5
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.unsupported_5 = null;

            /**
             * SessionRequest unsupported_6.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_6
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.unsupported_6 = null;

            /**
             * SessionRequest acquireSemaphore.
             * @member {Ydb.Coordination.SessionRequest.IAcquireSemaphore|null|undefined} acquireSemaphore
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.acquireSemaphore = null;

            /**
             * SessionRequest releaseSemaphore.
             * @member {Ydb.Coordination.SessionRequest.IReleaseSemaphore|null|undefined} releaseSemaphore
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.releaseSemaphore = null;

            /**
             * SessionRequest describeSemaphore.
             * @member {Ydb.Coordination.SessionRequest.IDescribeSemaphore|null|undefined} describeSemaphore
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.describeSemaphore = null;

            /**
             * SessionRequest createSemaphore.
             * @member {Ydb.Coordination.SessionRequest.ICreateSemaphore|null|undefined} createSemaphore
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.createSemaphore = null;

            /**
             * SessionRequest updateSemaphore.
             * @member {Ydb.Coordination.SessionRequest.IUpdateSemaphore|null|undefined} updateSemaphore
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.updateSemaphore = null;

            /**
             * SessionRequest deleteSemaphore.
             * @member {Ydb.Coordination.SessionRequest.IDeleteSemaphore|null|undefined} deleteSemaphore
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.deleteSemaphore = null;

            /**
             * SessionRequest unsupported_13.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_13
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.unsupported_13 = null;

            /**
             * SessionRequest unsupported_14.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_14
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.unsupported_14 = null;

            /**
             * SessionRequest unsupported_15.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_15
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            SessionRequest.prototype.unsupported_15 = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * SessionRequest request.
             * @member {"ping"|"pong"|"sessionStart"|"sessionStop"|"unsupported_5"|"unsupported_6"|"acquireSemaphore"|"releaseSemaphore"|"describeSemaphore"|"createSemaphore"|"updateSemaphore"|"deleteSemaphore"|"unsupported_13"|"unsupported_14"|"unsupported_15"|undefined} request
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             */
            Object.defineProperty(SessionRequest.prototype, "request", {
                get: $util.oneOfGetter($oneOfFields = ["ping", "pong", "sessionStart", "sessionStop", "unsupported_5", "unsupported_6", "acquireSemaphore", "releaseSemaphore", "describeSemaphore", "createSemaphore", "updateSemaphore", "deleteSemaphore", "unsupported_13", "unsupported_14", "unsupported_15"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SessionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.SessionRequest
             * @static
             * @param {Ydb.Coordination.ISessionRequest=} [properties] Properties to set
             * @returns {Ydb.Coordination.SessionRequest} SessionRequest instance
             */
            SessionRequest.create = function create(properties) {
                return new SessionRequest(properties);
            };

            /**
             * Encodes the specified SessionRequest message. Does not implicitly {@link Ydb.Coordination.SessionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.SessionRequest
             * @static
             * @param {Ydb.Coordination.ISessionRequest} message SessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ping != null && message.hasOwnProperty("ping"))
                    $root.Ydb.Coordination.SessionRequest.PingPong.encode(message.ping, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.pong != null && message.hasOwnProperty("pong"))
                    $root.Ydb.Coordination.SessionRequest.PingPong.encode(message.pong, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.sessionStart != null && message.hasOwnProperty("sessionStart"))
                    $root.Ydb.Coordination.SessionRequest.SessionStart.encode(message.sessionStart, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.sessionStop != null && message.hasOwnProperty("sessionStop"))
                    $root.Ydb.Coordination.SessionRequest.SessionStop.encode(message.sessionStop, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.unsupported_5 != null && message.hasOwnProperty("unsupported_5"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_5, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.unsupported_6 != null && message.hasOwnProperty("unsupported_6"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_6, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.acquireSemaphore != null && message.hasOwnProperty("acquireSemaphore"))
                    $root.Ydb.Coordination.SessionRequest.AcquireSemaphore.encode(message.acquireSemaphore, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.releaseSemaphore != null && message.hasOwnProperty("releaseSemaphore"))
                    $root.Ydb.Coordination.SessionRequest.ReleaseSemaphore.encode(message.releaseSemaphore, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.describeSemaphore != null && message.hasOwnProperty("describeSemaphore"))
                    $root.Ydb.Coordination.SessionRequest.DescribeSemaphore.encode(message.describeSemaphore, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.createSemaphore != null && message.hasOwnProperty("createSemaphore"))
                    $root.Ydb.Coordination.SessionRequest.CreateSemaphore.encode(message.createSemaphore, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.updateSemaphore != null && message.hasOwnProperty("updateSemaphore"))
                    $root.Ydb.Coordination.SessionRequest.UpdateSemaphore.encode(message.updateSemaphore, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.deleteSemaphore != null && message.hasOwnProperty("deleteSemaphore"))
                    $root.Ydb.Coordination.SessionRequest.DeleteSemaphore.encode(message.deleteSemaphore, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.unsupported_13 != null && message.hasOwnProperty("unsupported_13"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_13, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.unsupported_14 != null && message.hasOwnProperty("unsupported_14"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_14, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.unsupported_15 != null && message.hasOwnProperty("unsupported_15"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_15, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SessionRequest message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.SessionRequest
             * @static
             * @param {Ydb.Coordination.ISessionRequest} message SessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SessionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.SessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.SessionRequest} SessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ping = $root.Ydb.Coordination.SessionRequest.PingPong.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.pong = $root.Ydb.Coordination.SessionRequest.PingPong.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.sessionStart = $root.Ydb.Coordination.SessionRequest.SessionStart.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.sessionStop = $root.Ydb.Coordination.SessionRequest.SessionStop.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.unsupported_5 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.unsupported_6 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.acquireSemaphore = $root.Ydb.Coordination.SessionRequest.AcquireSemaphore.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.releaseSemaphore = $root.Ydb.Coordination.SessionRequest.ReleaseSemaphore.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.describeSemaphore = $root.Ydb.Coordination.SessionRequest.DescribeSemaphore.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.createSemaphore = $root.Ydb.Coordination.SessionRequest.CreateSemaphore.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.updateSemaphore = $root.Ydb.Coordination.SessionRequest.UpdateSemaphore.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.deleteSemaphore = $root.Ydb.Coordination.SessionRequest.DeleteSemaphore.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.unsupported_13 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.unsupported_14 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.unsupported_15 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SessionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.SessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.SessionRequest} SessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SessionRequest message.
             * @function verify
             * @memberof Ydb.Coordination.SessionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SessionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.ping != null && message.hasOwnProperty("ping")) {
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.PingPong.verify(message.ping);
                        if (error)
                            return "ping." + error;
                    }
                }
                if (message.pong != null && message.hasOwnProperty("pong")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.PingPong.verify(message.pong);
                        if (error)
                            return "pong." + error;
                    }
                }
                if (message.sessionStart != null && message.hasOwnProperty("sessionStart")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.SessionStart.verify(message.sessionStart);
                        if (error)
                            return "sessionStart." + error;
                    }
                }
                if (message.sessionStop != null && message.hasOwnProperty("sessionStop")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.SessionStop.verify(message.sessionStop);
                        if (error)
                            return "sessionStop." + error;
                    }
                }
                if (message.unsupported_5 != null && message.hasOwnProperty("unsupported_5")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_5);
                        if (error)
                            return "unsupported_5." + error;
                    }
                }
                if (message.unsupported_6 != null && message.hasOwnProperty("unsupported_6")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_6);
                        if (error)
                            return "unsupported_6." + error;
                    }
                }
                if (message.acquireSemaphore != null && message.hasOwnProperty("acquireSemaphore")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.AcquireSemaphore.verify(message.acquireSemaphore);
                        if (error)
                            return "acquireSemaphore." + error;
                    }
                }
                if (message.releaseSemaphore != null && message.hasOwnProperty("releaseSemaphore")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.ReleaseSemaphore.verify(message.releaseSemaphore);
                        if (error)
                            return "releaseSemaphore." + error;
                    }
                }
                if (message.describeSemaphore != null && message.hasOwnProperty("describeSemaphore")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.DescribeSemaphore.verify(message.describeSemaphore);
                        if (error)
                            return "describeSemaphore." + error;
                    }
                }
                if (message.createSemaphore != null && message.hasOwnProperty("createSemaphore")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.CreateSemaphore.verify(message.createSemaphore);
                        if (error)
                            return "createSemaphore." + error;
                    }
                }
                if (message.updateSemaphore != null && message.hasOwnProperty("updateSemaphore")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.UpdateSemaphore.verify(message.updateSemaphore);
                        if (error)
                            return "updateSemaphore." + error;
                    }
                }
                if (message.deleteSemaphore != null && message.hasOwnProperty("deleteSemaphore")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionRequest.DeleteSemaphore.verify(message.deleteSemaphore);
                        if (error)
                            return "deleteSemaphore." + error;
                    }
                }
                if (message.unsupported_13 != null && message.hasOwnProperty("unsupported_13")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_13);
                        if (error)
                            return "unsupported_13." + error;
                    }
                }
                if (message.unsupported_14 != null && message.hasOwnProperty("unsupported_14")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_14);
                        if (error)
                            return "unsupported_14." + error;
                    }
                }
                if (message.unsupported_15 != null && message.hasOwnProperty("unsupported_15")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_15);
                        if (error)
                            return "unsupported_15." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SessionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.SessionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.SessionRequest} SessionRequest
             */
            SessionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.SessionRequest)
                    return object;
                var message = new $root.Ydb.Coordination.SessionRequest();
                if (object.ping != null) {
                    if (typeof object.ping !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.ping: object expected");
                    message.ping = $root.Ydb.Coordination.SessionRequest.PingPong.fromObject(object.ping);
                }
                if (object.pong != null) {
                    if (typeof object.pong !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.pong: object expected");
                    message.pong = $root.Ydb.Coordination.SessionRequest.PingPong.fromObject(object.pong);
                }
                if (object.sessionStart != null) {
                    if (typeof object.sessionStart !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.sessionStart: object expected");
                    message.sessionStart = $root.Ydb.Coordination.SessionRequest.SessionStart.fromObject(object.sessionStart);
                }
                if (object.sessionStop != null) {
                    if (typeof object.sessionStop !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.sessionStop: object expected");
                    message.sessionStop = $root.Ydb.Coordination.SessionRequest.SessionStop.fromObject(object.sessionStop);
                }
                if (object.unsupported_5 != null) {
                    if (typeof object.unsupported_5 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.unsupported_5: object expected");
                    message.unsupported_5 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_5);
                }
                if (object.unsupported_6 != null) {
                    if (typeof object.unsupported_6 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.unsupported_6: object expected");
                    message.unsupported_6 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_6);
                }
                if (object.acquireSemaphore != null) {
                    if (typeof object.acquireSemaphore !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.acquireSemaphore: object expected");
                    message.acquireSemaphore = $root.Ydb.Coordination.SessionRequest.AcquireSemaphore.fromObject(object.acquireSemaphore);
                }
                if (object.releaseSemaphore != null) {
                    if (typeof object.releaseSemaphore !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.releaseSemaphore: object expected");
                    message.releaseSemaphore = $root.Ydb.Coordination.SessionRequest.ReleaseSemaphore.fromObject(object.releaseSemaphore);
                }
                if (object.describeSemaphore != null) {
                    if (typeof object.describeSemaphore !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.describeSemaphore: object expected");
                    message.describeSemaphore = $root.Ydb.Coordination.SessionRequest.DescribeSemaphore.fromObject(object.describeSemaphore);
                }
                if (object.createSemaphore != null) {
                    if (typeof object.createSemaphore !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.createSemaphore: object expected");
                    message.createSemaphore = $root.Ydb.Coordination.SessionRequest.CreateSemaphore.fromObject(object.createSemaphore);
                }
                if (object.updateSemaphore != null) {
                    if (typeof object.updateSemaphore !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.updateSemaphore: object expected");
                    message.updateSemaphore = $root.Ydb.Coordination.SessionRequest.UpdateSemaphore.fromObject(object.updateSemaphore);
                }
                if (object.deleteSemaphore != null) {
                    if (typeof object.deleteSemaphore !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.deleteSemaphore: object expected");
                    message.deleteSemaphore = $root.Ydb.Coordination.SessionRequest.DeleteSemaphore.fromObject(object.deleteSemaphore);
                }
                if (object.unsupported_13 != null) {
                    if (typeof object.unsupported_13 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.unsupported_13: object expected");
                    message.unsupported_13 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_13);
                }
                if (object.unsupported_14 != null) {
                    if (typeof object.unsupported_14 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.unsupported_14: object expected");
                    message.unsupported_14 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_14);
                }
                if (object.unsupported_15 != null) {
                    if (typeof object.unsupported_15 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionRequest.unsupported_15: object expected");
                    message.unsupported_15 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_15);
                }
                return message;
            };

            /**
             * Creates a plain object from a SessionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.SessionRequest
             * @static
             * @param {Ydb.Coordination.SessionRequest} message SessionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SessionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.ping != null && message.hasOwnProperty("ping")) {
                    object.ping = $root.Ydb.Coordination.SessionRequest.PingPong.toObject(message.ping, options);
                    if (options.oneofs)
                        object.request = "ping";
                }
                if (message.pong != null && message.hasOwnProperty("pong")) {
                    object.pong = $root.Ydb.Coordination.SessionRequest.PingPong.toObject(message.pong, options);
                    if (options.oneofs)
                        object.request = "pong";
                }
                if (message.sessionStart != null && message.hasOwnProperty("sessionStart")) {
                    object.sessionStart = $root.Ydb.Coordination.SessionRequest.SessionStart.toObject(message.sessionStart, options);
                    if (options.oneofs)
                        object.request = "sessionStart";
                }
                if (message.sessionStop != null && message.hasOwnProperty("sessionStop")) {
                    object.sessionStop = $root.Ydb.Coordination.SessionRequest.SessionStop.toObject(message.sessionStop, options);
                    if (options.oneofs)
                        object.request = "sessionStop";
                }
                if (message.unsupported_5 != null && message.hasOwnProperty("unsupported_5")) {
                    object.unsupported_5 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_5, options);
                    if (options.oneofs)
                        object.request = "unsupported_5";
                }
                if (message.unsupported_6 != null && message.hasOwnProperty("unsupported_6")) {
                    object.unsupported_6 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_6, options);
                    if (options.oneofs)
                        object.request = "unsupported_6";
                }
                if (message.acquireSemaphore != null && message.hasOwnProperty("acquireSemaphore")) {
                    object.acquireSemaphore = $root.Ydb.Coordination.SessionRequest.AcquireSemaphore.toObject(message.acquireSemaphore, options);
                    if (options.oneofs)
                        object.request = "acquireSemaphore";
                }
                if (message.releaseSemaphore != null && message.hasOwnProperty("releaseSemaphore")) {
                    object.releaseSemaphore = $root.Ydb.Coordination.SessionRequest.ReleaseSemaphore.toObject(message.releaseSemaphore, options);
                    if (options.oneofs)
                        object.request = "releaseSemaphore";
                }
                if (message.describeSemaphore != null && message.hasOwnProperty("describeSemaphore")) {
                    object.describeSemaphore = $root.Ydb.Coordination.SessionRequest.DescribeSemaphore.toObject(message.describeSemaphore, options);
                    if (options.oneofs)
                        object.request = "describeSemaphore";
                }
                if (message.createSemaphore != null && message.hasOwnProperty("createSemaphore")) {
                    object.createSemaphore = $root.Ydb.Coordination.SessionRequest.CreateSemaphore.toObject(message.createSemaphore, options);
                    if (options.oneofs)
                        object.request = "createSemaphore";
                }
                if (message.updateSemaphore != null && message.hasOwnProperty("updateSemaphore")) {
                    object.updateSemaphore = $root.Ydb.Coordination.SessionRequest.UpdateSemaphore.toObject(message.updateSemaphore, options);
                    if (options.oneofs)
                        object.request = "updateSemaphore";
                }
                if (message.deleteSemaphore != null && message.hasOwnProperty("deleteSemaphore")) {
                    object.deleteSemaphore = $root.Ydb.Coordination.SessionRequest.DeleteSemaphore.toObject(message.deleteSemaphore, options);
                    if (options.oneofs)
                        object.request = "deleteSemaphore";
                }
                if (message.unsupported_13 != null && message.hasOwnProperty("unsupported_13")) {
                    object.unsupported_13 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_13, options);
                    if (options.oneofs)
                        object.request = "unsupported_13";
                }
                if (message.unsupported_14 != null && message.hasOwnProperty("unsupported_14")) {
                    object.unsupported_14 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_14, options);
                    if (options.oneofs)
                        object.request = "unsupported_14";
                }
                if (message.unsupported_15 != null && message.hasOwnProperty("unsupported_15")) {
                    object.unsupported_15 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_15, options);
                    if (options.oneofs)
                        object.request = "unsupported_15";
                }
                return object;
            };

            /**
             * Converts this SessionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.SessionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SessionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SessionRequest.PingPong = (function() {

                /**
                 * Properties of a PingPong.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @interface IPingPong
                 * @property {number|Long|null} [opaque] PingPong opaque
                 */

                /**
                 * Constructs a new PingPong.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @classdesc Used for checking liveness of the connection
                 * @implements IPingPong
                 * @constructor
                 * @param {Ydb.Coordination.SessionRequest.IPingPong=} [properties] Properties to set
                 */
                function PingPong(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PingPong opaque.
                 * @member {number|Long} opaque
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @instance
                 */
                PingPong.prototype.opaque = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new PingPong instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IPingPong=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionRequest.PingPong} PingPong instance
                 */
                PingPong.create = function create(properties) {
                    return new PingPong(properties);
                };

                /**
                 * Encodes the specified PingPong message. Does not implicitly {@link Ydb.Coordination.SessionRequest.PingPong.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IPingPong} message PingPong message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingPong.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.opaque != null && message.hasOwnProperty("opaque"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.opaque);
                    return writer;
                };

                /**
                 * Encodes the specified PingPong message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.PingPong.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IPingPong} message PingPong message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingPong.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PingPong message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionRequest.PingPong} PingPong
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingPong.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest.PingPong();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.opaque = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PingPong message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionRequest.PingPong} PingPong
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingPong.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PingPong message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PingPong.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.opaque != null && message.hasOwnProperty("opaque"))
                        if (!$util.isInteger(message.opaque) && !(message.opaque && $util.isInteger(message.opaque.low) && $util.isInteger(message.opaque.high)))
                            return "opaque: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a PingPong message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionRequest.PingPong} PingPong
                 */
                PingPong.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionRequest.PingPong)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionRequest.PingPong();
                    if (object.opaque != null)
                        if ($util.Long)
                            (message.opaque = $util.Long.fromValue(object.opaque)).unsigned = true;
                        else if (typeof object.opaque === "string")
                            message.opaque = parseInt(object.opaque, 10);
                        else if (typeof object.opaque === "number")
                            message.opaque = object.opaque;
                        else if (typeof object.opaque === "object")
                            message.opaque = new $util.LongBits(object.opaque.low >>> 0, object.opaque.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a PingPong message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.PingPong} message PingPong
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PingPong.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.opaque = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.opaque = options.longs === String ? "0" : 0;
                    if (message.opaque != null && message.hasOwnProperty("opaque"))
                        if (typeof message.opaque === "number")
                            object.opaque = options.longs === String ? String(message.opaque) : message.opaque;
                        else
                            object.opaque = options.longs === String ? $util.Long.prototype.toString.call(message.opaque) : options.longs === Number ? new $util.LongBits(message.opaque.low >>> 0, message.opaque.high >>> 0).toNumber(true) : message.opaque;
                    return object;
                };

                /**
                 * Converts this PingPong to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionRequest.PingPong
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PingPong.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PingPong;
            })();

            SessionRequest.SessionStart = (function() {

                /**
                 * Properties of a SessionStart.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @interface ISessionStart
                 * @property {string|null} [path] SessionStart path
                 * @property {number|Long|null} [sessionId] SessionStart sessionId
                 * @property {number|Long|null} [timeoutMillis] SessionStart timeoutMillis
                 * @property {string|null} [description] SessionStart description
                 * @property {number|Long|null} [seqNo] SessionStart seqNo
                 * @property {Uint8Array|null} [protectionKey] SessionStart protectionKey
                 */

                /**
                 * Constructs a new SessionStart.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @classdesc First message used to start/restore a session
                 * @implements ISessionStart
                 * @constructor
                 * @param {Ydb.Coordination.SessionRequest.ISessionStart=} [properties] Properties to set
                 */
                function SessionStart(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionStart path.
                 * @member {string} path
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @instance
                 */
                SessionStart.prototype.path = "";

                /**
                 * SessionStart sessionId.
                 * @member {number|Long} sessionId
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @instance
                 */
                SessionStart.prototype.sessionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * SessionStart timeoutMillis.
                 * @member {number|Long} timeoutMillis
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @instance
                 */
                SessionStart.prototype.timeoutMillis = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * SessionStart description.
                 * @member {string} description
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @instance
                 */
                SessionStart.prototype.description = "";

                /**
                 * SessionStart seqNo.
                 * @member {number|Long} seqNo
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @instance
                 */
                SessionStart.prototype.seqNo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * SessionStart protectionKey.
                 * @member {Uint8Array} protectionKey
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @instance
                 */
                SessionStart.prototype.protectionKey = $util.newBuffer([]);

                /**
                 * Creates a new SessionStart instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ISessionStart=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionRequest.SessionStart} SessionStart instance
                 */
                SessionStart.create = function create(properties) {
                    return new SessionStart(properties);
                };

                /**
                 * Encodes the specified SessionStart message. Does not implicitly {@link Ydb.Coordination.SessionRequest.SessionStart.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ISessionStart} message SessionStart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.hasOwnProperty("path"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                    if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sessionId);
                    if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timeoutMillis);
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                    if (message.seqNo != null && message.hasOwnProperty("seqNo"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.seqNo);
                    if (message.protectionKey != null && message.hasOwnProperty("protectionKey"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.protectionKey);
                    return writer;
                };

                /**
                 * Encodes the specified SessionStart message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.SessionStart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ISessionStart} message SessionStart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionStart message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionRequest.SessionStart} SessionStart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest.SessionStart();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.path = reader.string();
                            break;
                        case 2:
                            message.sessionId = reader.uint64();
                            break;
                        case 3:
                            message.timeoutMillis = reader.uint64();
                            break;
                        case 4:
                            message.description = reader.string();
                            break;
                        case 5:
                            message.seqNo = reader.uint64();
                            break;
                        case 6:
                            message.protectionKey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionStart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionRequest.SessionStart} SessionStart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionStart message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionStart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                        if (!$util.isInteger(message.sessionId) && !(message.sessionId && $util.isInteger(message.sessionId.low) && $util.isInteger(message.sessionId.high)))
                            return "sessionId: integer|Long expected";
                    if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                        if (!$util.isInteger(message.timeoutMillis) && !(message.timeoutMillis && $util.isInteger(message.timeoutMillis.low) && $util.isInteger(message.timeoutMillis.high)))
                            return "timeoutMillis: integer|Long expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.seqNo != null && message.hasOwnProperty("seqNo"))
                        if (!$util.isInteger(message.seqNo) && !(message.seqNo && $util.isInteger(message.seqNo.low) && $util.isInteger(message.seqNo.high)))
                            return "seqNo: integer|Long expected";
                    if (message.protectionKey != null && message.hasOwnProperty("protectionKey"))
                        if (!(message.protectionKey && typeof message.protectionKey.length === "number" || $util.isString(message.protectionKey)))
                            return "protectionKey: buffer expected";
                    return null;
                };

                /**
                 * Creates a SessionStart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionRequest.SessionStart} SessionStart
                 */
                SessionStart.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionRequest.SessionStart)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionRequest.SessionStart();
                    if (object.path != null)
                        message.path = String(object.path);
                    if (object.sessionId != null)
                        if ($util.Long)
                            (message.sessionId = $util.Long.fromValue(object.sessionId)).unsigned = true;
                        else if (typeof object.sessionId === "string")
                            message.sessionId = parseInt(object.sessionId, 10);
                        else if (typeof object.sessionId === "number")
                            message.sessionId = object.sessionId;
                        else if (typeof object.sessionId === "object")
                            message.sessionId = new $util.LongBits(object.sessionId.low >>> 0, object.sessionId.high >>> 0).toNumber(true);
                    if (object.timeoutMillis != null)
                        if ($util.Long)
                            (message.timeoutMillis = $util.Long.fromValue(object.timeoutMillis)).unsigned = true;
                        else if (typeof object.timeoutMillis === "string")
                            message.timeoutMillis = parseInt(object.timeoutMillis, 10);
                        else if (typeof object.timeoutMillis === "number")
                            message.timeoutMillis = object.timeoutMillis;
                        else if (typeof object.timeoutMillis === "object")
                            message.timeoutMillis = new $util.LongBits(object.timeoutMillis.low >>> 0, object.timeoutMillis.high >>> 0).toNumber(true);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.seqNo != null)
                        if ($util.Long)
                            (message.seqNo = $util.Long.fromValue(object.seqNo)).unsigned = true;
                        else if (typeof object.seqNo === "string")
                            message.seqNo = parseInt(object.seqNo, 10);
                        else if (typeof object.seqNo === "number")
                            message.seqNo = object.seqNo;
                        else if (typeof object.seqNo === "object")
                            message.seqNo = new $util.LongBits(object.seqNo.low >>> 0, object.seqNo.high >>> 0).toNumber(true);
                    if (object.protectionKey != null)
                        if (typeof object.protectionKey === "string")
                            $util.base64.decode(object.protectionKey, message.protectionKey = $util.newBuffer($util.base64.length(object.protectionKey)), 0);
                        else if (object.protectionKey.length)
                            message.protectionKey = object.protectionKey;
                    return message;
                };

                /**
                 * Creates a plain object from a SessionStart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.SessionStart} message SessionStart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionStart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.path = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.sessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.sessionId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.timeoutMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timeoutMillis = options.longs === String ? "0" : 0;
                        object.description = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.seqNo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seqNo = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.protectionKey = "";
                        else {
                            object.protectionKey = [];
                            if (options.bytes !== Array)
                                object.protectionKey = $util.newBuffer(object.protectionKey);
                        }
                    }
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                        if (typeof message.sessionId === "number")
                            object.sessionId = options.longs === String ? String(message.sessionId) : message.sessionId;
                        else
                            object.sessionId = options.longs === String ? $util.Long.prototype.toString.call(message.sessionId) : options.longs === Number ? new $util.LongBits(message.sessionId.low >>> 0, message.sessionId.high >>> 0).toNumber(true) : message.sessionId;
                    if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                        if (typeof message.timeoutMillis === "number")
                            object.timeoutMillis = options.longs === String ? String(message.timeoutMillis) : message.timeoutMillis;
                        else
                            object.timeoutMillis = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutMillis) : options.longs === Number ? new $util.LongBits(message.timeoutMillis.low >>> 0, message.timeoutMillis.high >>> 0).toNumber(true) : message.timeoutMillis;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.seqNo != null && message.hasOwnProperty("seqNo"))
                        if (typeof message.seqNo === "number")
                            object.seqNo = options.longs === String ? String(message.seqNo) : message.seqNo;
                        else
                            object.seqNo = options.longs === String ? $util.Long.prototype.toString.call(message.seqNo) : options.longs === Number ? new $util.LongBits(message.seqNo.low >>> 0, message.seqNo.high >>> 0).toNumber(true) : message.seqNo;
                    if (message.protectionKey != null && message.hasOwnProperty("protectionKey"))
                        object.protectionKey = options.bytes === String ? $util.base64.encode(message.protectionKey, 0, message.protectionKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.protectionKey) : message.protectionKey;
                    return object;
                };

                /**
                 * Converts this SessionStart to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionRequest.SessionStart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionStart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionStart;
            })();

            SessionRequest.SessionStop = (function() {

                /**
                 * Properties of a SessionStop.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @interface ISessionStop
                 */

                /**
                 * Constructs a new SessionStop.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @classdesc Last message used to cleanly stop session before its timeout expires
                 * @implements ISessionStop
                 * @constructor
                 * @param {Ydb.Coordination.SessionRequest.ISessionStop=} [properties] Properties to set
                 */
                function SessionStop(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new SessionStop instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionRequest.SessionStop
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ISessionStop=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionRequest.SessionStop} SessionStop instance
                 */
                SessionStop.create = function create(properties) {
                    return new SessionStop(properties);
                };

                /**
                 * Encodes the specified SessionStop message. Does not implicitly {@link Ydb.Coordination.SessionRequest.SessionStop.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionRequest.SessionStop
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ISessionStop} message SessionStop message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStop.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified SessionStop message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.SessionStop.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.SessionStop
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ISessionStop} message SessionStop message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStop.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionStop message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionRequest.SessionStop
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionRequest.SessionStop} SessionStop
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStop.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest.SessionStop();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionStop message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.SessionStop
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionRequest.SessionStop} SessionStop
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStop.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionStop message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionRequest.SessionStop
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionStop.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a SessionStop message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionRequest.SessionStop
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionRequest.SessionStop} SessionStop
                 */
                SessionStop.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionRequest.SessionStop)
                        return object;
                    return new $root.Ydb.Coordination.SessionRequest.SessionStop();
                };

                /**
                 * Creates a plain object from a SessionStop message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionRequest.SessionStop
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.SessionStop} message SessionStop
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionStop.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this SessionStop to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionRequest.SessionStop
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionStop.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionStop;
            })();

            SessionRequest.AcquireSemaphore = (function() {

                /**
                 * Properties of an AcquireSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @interface IAcquireSemaphore
                 * @property {number|Long|null} [reqId] AcquireSemaphore reqId
                 * @property {string|null} [name] AcquireSemaphore name
                 * @property {number|Long|null} [timeoutMillis] AcquireSemaphore timeoutMillis
                 * @property {number|Long|null} [count] AcquireSemaphore count
                 * @property {Uint8Array|null} [data] AcquireSemaphore data
                 * @property {boolean|null} [ephemeral] AcquireSemaphore ephemeral
                 */

                /**
                 * Constructs a new AcquireSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @classdesc Used to acquire a semaphore
                 * 
                 * WARNING: a single session cannot acquire the same semaphore multiple times
                 * 
                 * Later requests override previous operations with the same semaphore,
                 * e.g. to reduce acquired count, change timeout or attached data.
                 * @implements IAcquireSemaphore
                 * @constructor
                 * @param {Ydb.Coordination.SessionRequest.IAcquireSemaphore=} [properties] Properties to set
                 */
                function AcquireSemaphore(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AcquireSemaphore reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @instance
                 */
                AcquireSemaphore.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * AcquireSemaphore name.
                 * @member {string} name
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @instance
                 */
                AcquireSemaphore.prototype.name = "";

                /**
                 * AcquireSemaphore timeoutMillis.
                 * @member {number|Long} timeoutMillis
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @instance
                 */
                AcquireSemaphore.prototype.timeoutMillis = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * AcquireSemaphore count.
                 * @member {number|Long} count
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @instance
                 */
                AcquireSemaphore.prototype.count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * AcquireSemaphore data.
                 * @member {Uint8Array} data
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @instance
                 */
                AcquireSemaphore.prototype.data = $util.newBuffer([]);

                /**
                 * AcquireSemaphore ephemeral.
                 * @member {boolean} ephemeral
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @instance
                 */
                AcquireSemaphore.prototype.ephemeral = false;

                /**
                 * Creates a new AcquireSemaphore instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IAcquireSemaphore=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionRequest.AcquireSemaphore} AcquireSemaphore instance
                 */
                AcquireSemaphore.create = function create(properties) {
                    return new AcquireSemaphore(properties);
                };

                /**
                 * Encodes the specified AcquireSemaphore message. Does not implicitly {@link Ydb.Coordination.SessionRequest.AcquireSemaphore.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IAcquireSemaphore} message AcquireSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AcquireSemaphore.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timeoutMillis);
                    if (message.count != null && message.hasOwnProperty("count"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.count);
                    if (message.data != null && message.hasOwnProperty("data"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.data);
                    if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ephemeral);
                    return writer;
                };

                /**
                 * Encodes the specified AcquireSemaphore message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.AcquireSemaphore.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IAcquireSemaphore} message AcquireSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AcquireSemaphore.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AcquireSemaphore message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionRequest.AcquireSemaphore} AcquireSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AcquireSemaphore.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest.AcquireSemaphore();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.timeoutMillis = reader.uint64();
                            break;
                        case 4:
                            message.count = reader.uint64();
                            break;
                        case 5:
                            message.data = reader.bytes();
                            break;
                        case 6:
                            message.ephemeral = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AcquireSemaphore message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionRequest.AcquireSemaphore} AcquireSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AcquireSemaphore.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AcquireSemaphore message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AcquireSemaphore.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                        if (!$util.isInteger(message.timeoutMillis) && !(message.timeoutMillis && $util.isInteger(message.timeoutMillis.low) && $util.isInteger(message.timeoutMillis.high)))
                            return "timeoutMillis: integer|Long expected";
                    if (message.count != null && message.hasOwnProperty("count"))
                        if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                            return "count: integer|Long expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                        if (typeof message.ephemeral !== "boolean")
                            return "ephemeral: boolean expected";
                    return null;
                };

                /**
                 * Creates an AcquireSemaphore message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionRequest.AcquireSemaphore} AcquireSemaphore
                 */
                AcquireSemaphore.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionRequest.AcquireSemaphore)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionRequest.AcquireSemaphore();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.timeoutMillis != null)
                        if ($util.Long)
                            (message.timeoutMillis = $util.Long.fromValue(object.timeoutMillis)).unsigned = true;
                        else if (typeof object.timeoutMillis === "string")
                            message.timeoutMillis = parseInt(object.timeoutMillis, 10);
                        else if (typeof object.timeoutMillis === "number")
                            message.timeoutMillis = object.timeoutMillis;
                        else if (typeof object.timeoutMillis === "object")
                            message.timeoutMillis = new $util.LongBits(object.timeoutMillis.low >>> 0, object.timeoutMillis.high >>> 0).toNumber(true);
                    if (object.count != null)
                        if ($util.Long)
                            (message.count = $util.Long.fromValue(object.count)).unsigned = true;
                        else if (typeof object.count === "string")
                            message.count = parseInt(object.count, 10);
                        else if (typeof object.count === "number")
                            message.count = object.count;
                        else if (typeof object.count === "object")
                            message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber(true);
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    if (object.ephemeral != null)
                        message.ephemeral = Boolean(object.ephemeral);
                    return message;
                };

                /**
                 * Creates a plain object from an AcquireSemaphore message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.AcquireSemaphore} message AcquireSemaphore
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AcquireSemaphore.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.name = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.timeoutMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timeoutMillis = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.count = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                        object.ephemeral = false;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                        if (typeof message.timeoutMillis === "number")
                            object.timeoutMillis = options.longs === String ? String(message.timeoutMillis) : message.timeoutMillis;
                        else
                            object.timeoutMillis = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutMillis) : options.longs === Number ? new $util.LongBits(message.timeoutMillis.low >>> 0, message.timeoutMillis.high >>> 0).toNumber(true) : message.timeoutMillis;
                    if (message.count != null && message.hasOwnProperty("count"))
                        if (typeof message.count === "number")
                            object.count = options.longs === String ? String(message.count) : message.count;
                        else
                            object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                        object.ephemeral = message.ephemeral;
                    return object;
                };

                /**
                 * Converts this AcquireSemaphore to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionRequest.AcquireSemaphore
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AcquireSemaphore.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AcquireSemaphore;
            })();

            SessionRequest.ReleaseSemaphore = (function() {

                /**
                 * Properties of a ReleaseSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @interface IReleaseSemaphore
                 * @property {number|Long|null} [reqId] ReleaseSemaphore reqId
                 * @property {string|null} [name] ReleaseSemaphore name
                 */

                /**
                 * Constructs a new ReleaseSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @classdesc Used to release a semaphore
                 * 
                 * WARNING: a single session cannot release the same semaphore multiple times
                 * 
                 * The release operation will either remove current session from waiters
                 * queue or release an already owned semaphore.
                 * @implements IReleaseSemaphore
                 * @constructor
                 * @param {Ydb.Coordination.SessionRequest.IReleaseSemaphore=} [properties] Properties to set
                 */
                function ReleaseSemaphore(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReleaseSemaphore reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @instance
                 */
                ReleaseSemaphore.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReleaseSemaphore name.
                 * @member {string} name
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @instance
                 */
                ReleaseSemaphore.prototype.name = "";

                /**
                 * Creates a new ReleaseSemaphore instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IReleaseSemaphore=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionRequest.ReleaseSemaphore} ReleaseSemaphore instance
                 */
                ReleaseSemaphore.create = function create(properties) {
                    return new ReleaseSemaphore(properties);
                };

                /**
                 * Encodes the specified ReleaseSemaphore message. Does not implicitly {@link Ydb.Coordination.SessionRequest.ReleaseSemaphore.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IReleaseSemaphore} message ReleaseSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReleaseSemaphore.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    return writer;
                };

                /**
                 * Encodes the specified ReleaseSemaphore message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.ReleaseSemaphore.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IReleaseSemaphore} message ReleaseSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReleaseSemaphore.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReleaseSemaphore message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionRequest.ReleaseSemaphore} ReleaseSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReleaseSemaphore.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest.ReleaseSemaphore();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReleaseSemaphore message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionRequest.ReleaseSemaphore} ReleaseSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReleaseSemaphore.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReleaseSemaphore message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReleaseSemaphore.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a ReleaseSemaphore message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionRequest.ReleaseSemaphore} ReleaseSemaphore
                 */
                ReleaseSemaphore.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionRequest.ReleaseSemaphore)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionRequest.ReleaseSemaphore();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a ReleaseSemaphore message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ReleaseSemaphore} message ReleaseSemaphore
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReleaseSemaphore.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.name = "";
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this ReleaseSemaphore to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionRequest.ReleaseSemaphore
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReleaseSemaphore.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReleaseSemaphore;
            })();

            SessionRequest.DescribeSemaphore = (function() {

                /**
                 * Properties of a DescribeSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @interface IDescribeSemaphore
                 * @property {number|Long|null} [reqId] DescribeSemaphore reqId
                 * @property {string|null} [name] DescribeSemaphore name
                 * @property {boolean|null} [includeOwners] DescribeSemaphore includeOwners
                 * @property {boolean|null} [includeWaiters] DescribeSemaphore includeWaiters
                 * @property {boolean|null} [watchData] DescribeSemaphore watchData
                 * @property {boolean|null} [watchOwners] DescribeSemaphore watchOwners
                 */

                /**
                 * Constructs a new DescribeSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @classdesc Used to describe semaphores and watch them for changes
                 * 
                 * WARNING: a describe operation will cancel previous watches on the same semaphore
                 * @implements IDescribeSemaphore
                 * @constructor
                 * @param {Ydb.Coordination.SessionRequest.IDescribeSemaphore=} [properties] Properties to set
                 */
                function DescribeSemaphore(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeSemaphore reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @instance
                 */
                DescribeSemaphore.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * DescribeSemaphore name.
                 * @member {string} name
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @instance
                 */
                DescribeSemaphore.prototype.name = "";

                /**
                 * DescribeSemaphore includeOwners.
                 * @member {boolean} includeOwners
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @instance
                 */
                DescribeSemaphore.prototype.includeOwners = false;

                /**
                 * DescribeSemaphore includeWaiters.
                 * @member {boolean} includeWaiters
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @instance
                 */
                DescribeSemaphore.prototype.includeWaiters = false;

                /**
                 * DescribeSemaphore watchData.
                 * @member {boolean} watchData
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @instance
                 */
                DescribeSemaphore.prototype.watchData = false;

                /**
                 * DescribeSemaphore watchOwners.
                 * @member {boolean} watchOwners
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @instance
                 */
                DescribeSemaphore.prototype.watchOwners = false;

                /**
                 * Creates a new DescribeSemaphore instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IDescribeSemaphore=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionRequest.DescribeSemaphore} DescribeSemaphore instance
                 */
                DescribeSemaphore.create = function create(properties) {
                    return new DescribeSemaphore(properties);
                };

                /**
                 * Encodes the specified DescribeSemaphore message. Does not implicitly {@link Ydb.Coordination.SessionRequest.DescribeSemaphore.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IDescribeSemaphore} message DescribeSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescribeSemaphore.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.includeOwners != null && message.hasOwnProperty("includeOwners"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeOwners);
                    if (message.includeWaiters != null && message.hasOwnProperty("includeWaiters"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.includeWaiters);
                    if (message.watchData != null && message.hasOwnProperty("watchData"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.watchData);
                    if (message.watchOwners != null && message.hasOwnProperty("watchOwners"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.watchOwners);
                    return writer;
                };

                /**
                 * Encodes the specified DescribeSemaphore message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.DescribeSemaphore.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IDescribeSemaphore} message DescribeSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescribeSemaphore.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DescribeSemaphore message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionRequest.DescribeSemaphore} DescribeSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescribeSemaphore.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest.DescribeSemaphore();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.includeOwners = reader.bool();
                            break;
                        case 4:
                            message.includeWaiters = reader.bool();
                            break;
                        case 5:
                            message.watchData = reader.bool();
                            break;
                        case 6:
                            message.watchOwners = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DescribeSemaphore message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionRequest.DescribeSemaphore} DescribeSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescribeSemaphore.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DescribeSemaphore message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeSemaphore.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.includeOwners != null && message.hasOwnProperty("includeOwners"))
                        if (typeof message.includeOwners !== "boolean")
                            return "includeOwners: boolean expected";
                    if (message.includeWaiters != null && message.hasOwnProperty("includeWaiters"))
                        if (typeof message.includeWaiters !== "boolean")
                            return "includeWaiters: boolean expected";
                    if (message.watchData != null && message.hasOwnProperty("watchData"))
                        if (typeof message.watchData !== "boolean")
                            return "watchData: boolean expected";
                    if (message.watchOwners != null && message.hasOwnProperty("watchOwners"))
                        if (typeof message.watchOwners !== "boolean")
                            return "watchOwners: boolean expected";
                    return null;
                };

                /**
                 * Creates a DescribeSemaphore message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionRequest.DescribeSemaphore} DescribeSemaphore
                 */
                DescribeSemaphore.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionRequest.DescribeSemaphore)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionRequest.DescribeSemaphore();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.includeOwners != null)
                        message.includeOwners = Boolean(object.includeOwners);
                    if (object.includeWaiters != null)
                        message.includeWaiters = Boolean(object.includeWaiters);
                    if (object.watchData != null)
                        message.watchData = Boolean(object.watchData);
                    if (object.watchOwners != null)
                        message.watchOwners = Boolean(object.watchOwners);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeSemaphore message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.DescribeSemaphore} message DescribeSemaphore
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeSemaphore.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.name = "";
                        object.includeOwners = false;
                        object.includeWaiters = false;
                        object.watchData = false;
                        object.watchOwners = false;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.includeOwners != null && message.hasOwnProperty("includeOwners"))
                        object.includeOwners = message.includeOwners;
                    if (message.includeWaiters != null && message.hasOwnProperty("includeWaiters"))
                        object.includeWaiters = message.includeWaiters;
                    if (message.watchData != null && message.hasOwnProperty("watchData"))
                        object.watchData = message.watchData;
                    if (message.watchOwners != null && message.hasOwnProperty("watchOwners"))
                        object.watchOwners = message.watchOwners;
                    return object;
                };

                /**
                 * Converts this DescribeSemaphore to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionRequest.DescribeSemaphore
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeSemaphore.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeSemaphore;
            })();

            SessionRequest.CreateSemaphore = (function() {

                /**
                 * Properties of a CreateSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @interface ICreateSemaphore
                 * @property {number|Long|null} [reqId] CreateSemaphore reqId
                 * @property {string|null} [name] CreateSemaphore name
                 * @property {number|Long|null} [limit] CreateSemaphore limit
                 * @property {Uint8Array|null} [data] CreateSemaphore data
                 */

                /**
                 * Constructs a new CreateSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @classdesc Used to create a new semaphore
                 * @implements ICreateSemaphore
                 * @constructor
                 * @param {Ydb.Coordination.SessionRequest.ICreateSemaphore=} [properties] Properties to set
                 */
                function CreateSemaphore(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateSemaphore reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @instance
                 */
                CreateSemaphore.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * CreateSemaphore name.
                 * @member {string} name
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @instance
                 */
                CreateSemaphore.prototype.name = "";

                /**
                 * CreateSemaphore limit.
                 * @member {number|Long} limit
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @instance
                 */
                CreateSemaphore.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * CreateSemaphore data.
                 * @member {Uint8Array} data
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @instance
                 */
                CreateSemaphore.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new CreateSemaphore instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ICreateSemaphore=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionRequest.CreateSemaphore} CreateSemaphore instance
                 */
                CreateSemaphore.create = function create(properties) {
                    return new CreateSemaphore(properties);
                };

                /**
                 * Encodes the specified CreateSemaphore message. Does not implicitly {@link Ydb.Coordination.SessionRequest.CreateSemaphore.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ICreateSemaphore} message CreateSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateSemaphore.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.limit);
                    if (message.data != null && message.hasOwnProperty("data"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified CreateSemaphore message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.CreateSemaphore.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.ICreateSemaphore} message CreateSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateSemaphore.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateSemaphore message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionRequest.CreateSemaphore} CreateSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateSemaphore.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest.CreateSemaphore();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.limit = reader.uint64();
                            break;
                        case 4:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateSemaphore message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionRequest.CreateSemaphore} CreateSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateSemaphore.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateSemaphore message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateSemaphore.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                            return "limit: integer|Long expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates a CreateSemaphore message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionRequest.CreateSemaphore} CreateSemaphore
                 */
                CreateSemaphore.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionRequest.CreateSemaphore)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionRequest.CreateSemaphore();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.limit != null)
                        if ($util.Long)
                            (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                        else if (typeof object.limit === "string")
                            message.limit = parseInt(object.limit, 10);
                        else if (typeof object.limit === "number")
                            message.limit = object.limit;
                        else if (typeof object.limit === "object")
                            message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a plain object from a CreateSemaphore message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.CreateSemaphore} message CreateSemaphore
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateSemaphore.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.name = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.limit = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (typeof message.limit === "number")
                            object.limit = options.longs === String ? String(message.limit) : message.limit;
                        else
                            object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Converts this CreateSemaphore to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionRequest.CreateSemaphore
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateSemaphore.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateSemaphore;
            })();

            SessionRequest.UpdateSemaphore = (function() {

                /**
                 * Properties of an UpdateSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @interface IUpdateSemaphore
                 * @property {number|Long|null} [reqId] UpdateSemaphore reqId
                 * @property {string|null} [name] UpdateSemaphore name
                 * @property {Uint8Array|null} [data] UpdateSemaphore data
                 */

                /**
                 * Constructs a new UpdateSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @classdesc Used to change semaphore data
                 * @implements IUpdateSemaphore
                 * @constructor
                 * @param {Ydb.Coordination.SessionRequest.IUpdateSemaphore=} [properties] Properties to set
                 */
                function UpdateSemaphore(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateSemaphore reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @instance
                 */
                UpdateSemaphore.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * UpdateSemaphore name.
                 * @member {string} name
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @instance
                 */
                UpdateSemaphore.prototype.name = "";

                /**
                 * UpdateSemaphore data.
                 * @member {Uint8Array} data
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @instance
                 */
                UpdateSemaphore.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new UpdateSemaphore instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IUpdateSemaphore=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionRequest.UpdateSemaphore} UpdateSemaphore instance
                 */
                UpdateSemaphore.create = function create(properties) {
                    return new UpdateSemaphore(properties);
                };

                /**
                 * Encodes the specified UpdateSemaphore message. Does not implicitly {@link Ydb.Coordination.SessionRequest.UpdateSemaphore.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IUpdateSemaphore} message UpdateSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateSemaphore.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.data != null && message.hasOwnProperty("data"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified UpdateSemaphore message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.UpdateSemaphore.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IUpdateSemaphore} message UpdateSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateSemaphore.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpdateSemaphore message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionRequest.UpdateSemaphore} UpdateSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateSemaphore.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest.UpdateSemaphore();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UpdateSemaphore message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionRequest.UpdateSemaphore} UpdateSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateSemaphore.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpdateSemaphore message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateSemaphore.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates an UpdateSemaphore message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionRequest.UpdateSemaphore} UpdateSemaphore
                 */
                UpdateSemaphore.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionRequest.UpdateSemaphore)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionRequest.UpdateSemaphore();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateSemaphore message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.UpdateSemaphore} message UpdateSemaphore
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateSemaphore.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.name = "";
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Converts this UpdateSemaphore to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionRequest.UpdateSemaphore
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateSemaphore.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateSemaphore;
            })();

            SessionRequest.DeleteSemaphore = (function() {

                /**
                 * Properties of a DeleteSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @interface IDeleteSemaphore
                 * @property {number|Long|null} [reqId] DeleteSemaphore reqId
                 * @property {string|null} [name] DeleteSemaphore name
                 * @property {boolean|null} [force] DeleteSemaphore force
                 */

                /**
                 * Constructs a new DeleteSemaphore.
                 * @memberof Ydb.Coordination.SessionRequest
                 * @classdesc Used to delete an existing semaphore
                 * @implements IDeleteSemaphore
                 * @constructor
                 * @param {Ydb.Coordination.SessionRequest.IDeleteSemaphore=} [properties] Properties to set
                 */
                function DeleteSemaphore(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteSemaphore reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @instance
                 */
                DeleteSemaphore.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * DeleteSemaphore name.
                 * @member {string} name
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @instance
                 */
                DeleteSemaphore.prototype.name = "";

                /**
                 * DeleteSemaphore force.
                 * @member {boolean} force
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @instance
                 */
                DeleteSemaphore.prototype.force = false;

                /**
                 * Creates a new DeleteSemaphore instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IDeleteSemaphore=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionRequest.DeleteSemaphore} DeleteSemaphore instance
                 */
                DeleteSemaphore.create = function create(properties) {
                    return new DeleteSemaphore(properties);
                };

                /**
                 * Encodes the specified DeleteSemaphore message. Does not implicitly {@link Ydb.Coordination.SessionRequest.DeleteSemaphore.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IDeleteSemaphore} message DeleteSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteSemaphore.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.force != null && message.hasOwnProperty("force"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.force);
                    return writer;
                };

                /**
                 * Encodes the specified DeleteSemaphore message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionRequest.DeleteSemaphore.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.IDeleteSemaphore} message DeleteSemaphore message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteSemaphore.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeleteSemaphore message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionRequest.DeleteSemaphore} DeleteSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteSemaphore.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionRequest.DeleteSemaphore();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.force = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeleteSemaphore message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionRequest.DeleteSemaphore} DeleteSemaphore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteSemaphore.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DeleteSemaphore message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteSemaphore.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.force != null && message.hasOwnProperty("force"))
                        if (typeof message.force !== "boolean")
                            return "force: boolean expected";
                    return null;
                };

                /**
                 * Creates a DeleteSemaphore message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionRequest.DeleteSemaphore} DeleteSemaphore
                 */
                DeleteSemaphore.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionRequest.DeleteSemaphore)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionRequest.DeleteSemaphore();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.force != null)
                        message.force = Boolean(object.force);
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteSemaphore message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @static
                 * @param {Ydb.Coordination.SessionRequest.DeleteSemaphore} message DeleteSemaphore
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteSemaphore.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.name = "";
                        object.force = false;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.force != null && message.hasOwnProperty("force"))
                        object.force = message.force;
                    return object;
                };

                /**
                 * Converts this DeleteSemaphore to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionRequest.DeleteSemaphore
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteSemaphore.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteSemaphore;
            })();

            return SessionRequest;
        })();

        Coordination.SessionResponse = (function() {

            /**
             * Properties of a SessionResponse.
             * @memberof Ydb.Coordination
             * @interface ISessionResponse
             * @property {Ydb.Coordination.SessionResponse.IPingPong|null} [ping] SessionResponse ping
             * @property {Ydb.Coordination.SessionResponse.IPingPong|null} [pong] SessionResponse pong
             * @property {Ydb.Coordination.SessionResponse.IFailure|null} [failure] SessionResponse failure
             * @property {Ydb.Coordination.SessionResponse.ISessionStarted|null} [sessionStarted] SessionResponse sessionStarted
             * @property {Ydb.Coordination.SessionResponse.ISessionStopped|null} [sessionStopped] SessionResponse sessionStopped
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_6] SessionResponse unsupported_6
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_7] SessionResponse unsupported_7
             * @property {Ydb.Coordination.SessionResponse.IAcquireSemaphorePending|null} [acquireSemaphorePending] SessionResponse acquireSemaphorePending
             * @property {Ydb.Coordination.SessionResponse.IAcquireSemaphoreResult|null} [acquireSemaphoreResult] SessionResponse acquireSemaphoreResult
             * @property {Ydb.Coordination.SessionResponse.IReleaseSemaphoreResult|null} [releaseSemaphoreResult] SessionResponse releaseSemaphoreResult
             * @property {Ydb.Coordination.SessionResponse.IDescribeSemaphoreResult|null} [describeSemaphoreResult] SessionResponse describeSemaphoreResult
             * @property {Ydb.Coordination.SessionResponse.IDescribeSemaphoreChanged|null} [describeSemaphoreChanged] SessionResponse describeSemaphoreChanged
             * @property {Ydb.Coordination.SessionResponse.ICreateSemaphoreResult|null} [createSemaphoreResult] SessionResponse createSemaphoreResult
             * @property {Ydb.Coordination.SessionResponse.IUpdateSemaphoreResult|null} [updateSemaphoreResult] SessionResponse updateSemaphoreResult
             * @property {Ydb.Coordination.SessionResponse.IDeleteSemaphoreResult|null} [deleteSemaphoreResult] SessionResponse deleteSemaphoreResult
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_16] SessionResponse unsupported_16
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_17] SessionResponse unsupported_17
             * @property {Ydb.Coordination.IUnsupported|null} [unsupported_18] SessionResponse unsupported_18
             */

            /**
             * Constructs a new SessionResponse.
             * @memberof Ydb.Coordination
             * @classdesc Session response message sent from server to client
             * @implements ISessionResponse
             * @constructor
             * @param {Ydb.Coordination.ISessionResponse=} [properties] Properties to set
             */
            function SessionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SessionResponse ping.
             * @member {Ydb.Coordination.SessionResponse.IPingPong|null|undefined} ping
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.ping = null;

            /**
             * SessionResponse pong.
             * @member {Ydb.Coordination.SessionResponse.IPingPong|null|undefined} pong
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.pong = null;

            /**
             * SessionResponse failure.
             * @member {Ydb.Coordination.SessionResponse.IFailure|null|undefined} failure
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.failure = null;

            /**
             * SessionResponse sessionStarted.
             * @member {Ydb.Coordination.SessionResponse.ISessionStarted|null|undefined} sessionStarted
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.sessionStarted = null;

            /**
             * SessionResponse sessionStopped.
             * @member {Ydb.Coordination.SessionResponse.ISessionStopped|null|undefined} sessionStopped
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.sessionStopped = null;

            /**
             * SessionResponse unsupported_6.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_6
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.unsupported_6 = null;

            /**
             * SessionResponse unsupported_7.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_7
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.unsupported_7 = null;

            /**
             * SessionResponse acquireSemaphorePending.
             * @member {Ydb.Coordination.SessionResponse.IAcquireSemaphorePending|null|undefined} acquireSemaphorePending
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.acquireSemaphorePending = null;

            /**
             * SessionResponse acquireSemaphoreResult.
             * @member {Ydb.Coordination.SessionResponse.IAcquireSemaphoreResult|null|undefined} acquireSemaphoreResult
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.acquireSemaphoreResult = null;

            /**
             * SessionResponse releaseSemaphoreResult.
             * @member {Ydb.Coordination.SessionResponse.IReleaseSemaphoreResult|null|undefined} releaseSemaphoreResult
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.releaseSemaphoreResult = null;

            /**
             * SessionResponse describeSemaphoreResult.
             * @member {Ydb.Coordination.SessionResponse.IDescribeSemaphoreResult|null|undefined} describeSemaphoreResult
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.describeSemaphoreResult = null;

            /**
             * SessionResponse describeSemaphoreChanged.
             * @member {Ydb.Coordination.SessionResponse.IDescribeSemaphoreChanged|null|undefined} describeSemaphoreChanged
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.describeSemaphoreChanged = null;

            /**
             * SessionResponse createSemaphoreResult.
             * @member {Ydb.Coordination.SessionResponse.ICreateSemaphoreResult|null|undefined} createSemaphoreResult
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.createSemaphoreResult = null;

            /**
             * SessionResponse updateSemaphoreResult.
             * @member {Ydb.Coordination.SessionResponse.IUpdateSemaphoreResult|null|undefined} updateSemaphoreResult
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.updateSemaphoreResult = null;

            /**
             * SessionResponse deleteSemaphoreResult.
             * @member {Ydb.Coordination.SessionResponse.IDeleteSemaphoreResult|null|undefined} deleteSemaphoreResult
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.deleteSemaphoreResult = null;

            /**
             * SessionResponse unsupported_16.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_16
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.unsupported_16 = null;

            /**
             * SessionResponse unsupported_17.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_17
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.unsupported_17 = null;

            /**
             * SessionResponse unsupported_18.
             * @member {Ydb.Coordination.IUnsupported|null|undefined} unsupported_18
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            SessionResponse.prototype.unsupported_18 = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * SessionResponse response.
             * @member {"ping"|"pong"|"failure"|"sessionStarted"|"sessionStopped"|"unsupported_6"|"unsupported_7"|"acquireSemaphorePending"|"acquireSemaphoreResult"|"releaseSemaphoreResult"|"describeSemaphoreResult"|"describeSemaphoreChanged"|"createSemaphoreResult"|"updateSemaphoreResult"|"deleteSemaphoreResult"|"unsupported_16"|"unsupported_17"|"unsupported_18"|undefined} response
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             */
            Object.defineProperty(SessionResponse.prototype, "response", {
                get: $util.oneOfGetter($oneOfFields = ["ping", "pong", "failure", "sessionStarted", "sessionStopped", "unsupported_6", "unsupported_7", "acquireSemaphorePending", "acquireSemaphoreResult", "releaseSemaphoreResult", "describeSemaphoreResult", "describeSemaphoreChanged", "createSemaphoreResult", "updateSemaphoreResult", "deleteSemaphoreResult", "unsupported_16", "unsupported_17", "unsupported_18"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SessionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.SessionResponse
             * @static
             * @param {Ydb.Coordination.ISessionResponse=} [properties] Properties to set
             * @returns {Ydb.Coordination.SessionResponse} SessionResponse instance
             */
            SessionResponse.create = function create(properties) {
                return new SessionResponse(properties);
            };

            /**
             * Encodes the specified SessionResponse message. Does not implicitly {@link Ydb.Coordination.SessionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.SessionResponse
             * @static
             * @param {Ydb.Coordination.ISessionResponse} message SessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ping != null && message.hasOwnProperty("ping"))
                    $root.Ydb.Coordination.SessionResponse.PingPong.encode(message.ping, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.pong != null && message.hasOwnProperty("pong"))
                    $root.Ydb.Coordination.SessionResponse.PingPong.encode(message.pong, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.failure != null && message.hasOwnProperty("failure"))
                    $root.Ydb.Coordination.SessionResponse.Failure.encode(message.failure, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.sessionStarted != null && message.hasOwnProperty("sessionStarted"))
                    $root.Ydb.Coordination.SessionResponse.SessionStarted.encode(message.sessionStarted, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.sessionStopped != null && message.hasOwnProperty("sessionStopped"))
                    $root.Ydb.Coordination.SessionResponse.SessionStopped.encode(message.sessionStopped, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.unsupported_6 != null && message.hasOwnProperty("unsupported_6"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_6, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.unsupported_7 != null && message.hasOwnProperty("unsupported_7"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_7, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.acquireSemaphorePending != null && message.hasOwnProperty("acquireSemaphorePending"))
                    $root.Ydb.Coordination.SessionResponse.AcquireSemaphorePending.encode(message.acquireSemaphorePending, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.acquireSemaphoreResult != null && message.hasOwnProperty("acquireSemaphoreResult"))
                    $root.Ydb.Coordination.SessionResponse.AcquireSemaphoreResult.encode(message.acquireSemaphoreResult, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.releaseSemaphoreResult != null && message.hasOwnProperty("releaseSemaphoreResult"))
                    $root.Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult.encode(message.releaseSemaphoreResult, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.describeSemaphoreResult != null && message.hasOwnProperty("describeSemaphoreResult"))
                    $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.encode(message.describeSemaphoreResult, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.describeSemaphoreChanged != null && message.hasOwnProperty("describeSemaphoreChanged"))
                    $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged.encode(message.describeSemaphoreChanged, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.createSemaphoreResult != null && message.hasOwnProperty("createSemaphoreResult"))
                    $root.Ydb.Coordination.SessionResponse.CreateSemaphoreResult.encode(message.createSemaphoreResult, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.updateSemaphoreResult != null && message.hasOwnProperty("updateSemaphoreResult"))
                    $root.Ydb.Coordination.SessionResponse.UpdateSemaphoreResult.encode(message.updateSemaphoreResult, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.deleteSemaphoreResult != null && message.hasOwnProperty("deleteSemaphoreResult"))
                    $root.Ydb.Coordination.SessionResponse.DeleteSemaphoreResult.encode(message.deleteSemaphoreResult, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.unsupported_16 != null && message.hasOwnProperty("unsupported_16"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_16, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.unsupported_17 != null && message.hasOwnProperty("unsupported_17"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_17, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.unsupported_18 != null && message.hasOwnProperty("unsupported_18"))
                    $root.Ydb.Coordination.Unsupported.encode(message.unsupported_18, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SessionResponse message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.SessionResponse
             * @static
             * @param {Ydb.Coordination.ISessionResponse} message SessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SessionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.SessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.SessionResponse} SessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ping = $root.Ydb.Coordination.SessionResponse.PingPong.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.pong = $root.Ydb.Coordination.SessionResponse.PingPong.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.failure = $root.Ydb.Coordination.SessionResponse.Failure.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.sessionStarted = $root.Ydb.Coordination.SessionResponse.SessionStarted.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.sessionStopped = $root.Ydb.Coordination.SessionResponse.SessionStopped.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.unsupported_6 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.unsupported_7 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.acquireSemaphorePending = $root.Ydb.Coordination.SessionResponse.AcquireSemaphorePending.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.acquireSemaphoreResult = $root.Ydb.Coordination.SessionResponse.AcquireSemaphoreResult.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.releaseSemaphoreResult = $root.Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.describeSemaphoreResult = $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.describeSemaphoreChanged = $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.createSemaphoreResult = $root.Ydb.Coordination.SessionResponse.CreateSemaphoreResult.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.updateSemaphoreResult = $root.Ydb.Coordination.SessionResponse.UpdateSemaphoreResult.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.deleteSemaphoreResult = $root.Ydb.Coordination.SessionResponse.DeleteSemaphoreResult.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.unsupported_16 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.unsupported_17 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.unsupported_18 = $root.Ydb.Coordination.Unsupported.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SessionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.SessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.SessionResponse} SessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SessionResponse message.
             * @function verify
             * @memberof Ydb.Coordination.SessionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SessionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.ping != null && message.hasOwnProperty("ping")) {
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.PingPong.verify(message.ping);
                        if (error)
                            return "ping." + error;
                    }
                }
                if (message.pong != null && message.hasOwnProperty("pong")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.PingPong.verify(message.pong);
                        if (error)
                            return "pong." + error;
                    }
                }
                if (message.failure != null && message.hasOwnProperty("failure")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.Failure.verify(message.failure);
                        if (error)
                            return "failure." + error;
                    }
                }
                if (message.sessionStarted != null && message.hasOwnProperty("sessionStarted")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.SessionStarted.verify(message.sessionStarted);
                        if (error)
                            return "sessionStarted." + error;
                    }
                }
                if (message.sessionStopped != null && message.hasOwnProperty("sessionStopped")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.SessionStopped.verify(message.sessionStopped);
                        if (error)
                            return "sessionStopped." + error;
                    }
                }
                if (message.unsupported_6 != null && message.hasOwnProperty("unsupported_6")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_6);
                        if (error)
                            return "unsupported_6." + error;
                    }
                }
                if (message.unsupported_7 != null && message.hasOwnProperty("unsupported_7")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_7);
                        if (error)
                            return "unsupported_7." + error;
                    }
                }
                if (message.acquireSemaphorePending != null && message.hasOwnProperty("acquireSemaphorePending")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.AcquireSemaphorePending.verify(message.acquireSemaphorePending);
                        if (error)
                            return "acquireSemaphorePending." + error;
                    }
                }
                if (message.acquireSemaphoreResult != null && message.hasOwnProperty("acquireSemaphoreResult")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.AcquireSemaphoreResult.verify(message.acquireSemaphoreResult);
                        if (error)
                            return "acquireSemaphoreResult." + error;
                    }
                }
                if (message.releaseSemaphoreResult != null && message.hasOwnProperty("releaseSemaphoreResult")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult.verify(message.releaseSemaphoreResult);
                        if (error)
                            return "releaseSemaphoreResult." + error;
                    }
                }
                if (message.describeSemaphoreResult != null && message.hasOwnProperty("describeSemaphoreResult")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.verify(message.describeSemaphoreResult);
                        if (error)
                            return "describeSemaphoreResult." + error;
                    }
                }
                if (message.describeSemaphoreChanged != null && message.hasOwnProperty("describeSemaphoreChanged")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged.verify(message.describeSemaphoreChanged);
                        if (error)
                            return "describeSemaphoreChanged." + error;
                    }
                }
                if (message.createSemaphoreResult != null && message.hasOwnProperty("createSemaphoreResult")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.CreateSemaphoreResult.verify(message.createSemaphoreResult);
                        if (error)
                            return "createSemaphoreResult." + error;
                    }
                }
                if (message.updateSemaphoreResult != null && message.hasOwnProperty("updateSemaphoreResult")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.UpdateSemaphoreResult.verify(message.updateSemaphoreResult);
                        if (error)
                            return "updateSemaphoreResult." + error;
                    }
                }
                if (message.deleteSemaphoreResult != null && message.hasOwnProperty("deleteSemaphoreResult")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.SessionResponse.DeleteSemaphoreResult.verify(message.deleteSemaphoreResult);
                        if (error)
                            return "deleteSemaphoreResult." + error;
                    }
                }
                if (message.unsupported_16 != null && message.hasOwnProperty("unsupported_16")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_16);
                        if (error)
                            return "unsupported_16." + error;
                    }
                }
                if (message.unsupported_17 != null && message.hasOwnProperty("unsupported_17")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_17);
                        if (error)
                            return "unsupported_17." + error;
                    }
                }
                if (message.unsupported_18 != null && message.hasOwnProperty("unsupported_18")) {
                    if (properties.response === 1)
                        return "response: multiple values";
                    properties.response = 1;
                    {
                        var error = $root.Ydb.Coordination.Unsupported.verify(message.unsupported_18);
                        if (error)
                            return "unsupported_18." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SessionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.SessionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.SessionResponse} SessionResponse
             */
            SessionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.SessionResponse)
                    return object;
                var message = new $root.Ydb.Coordination.SessionResponse();
                if (object.ping != null) {
                    if (typeof object.ping !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.ping: object expected");
                    message.ping = $root.Ydb.Coordination.SessionResponse.PingPong.fromObject(object.ping);
                }
                if (object.pong != null) {
                    if (typeof object.pong !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.pong: object expected");
                    message.pong = $root.Ydb.Coordination.SessionResponse.PingPong.fromObject(object.pong);
                }
                if (object.failure != null) {
                    if (typeof object.failure !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.failure: object expected");
                    message.failure = $root.Ydb.Coordination.SessionResponse.Failure.fromObject(object.failure);
                }
                if (object.sessionStarted != null) {
                    if (typeof object.sessionStarted !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.sessionStarted: object expected");
                    message.sessionStarted = $root.Ydb.Coordination.SessionResponse.SessionStarted.fromObject(object.sessionStarted);
                }
                if (object.sessionStopped != null) {
                    if (typeof object.sessionStopped !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.sessionStopped: object expected");
                    message.sessionStopped = $root.Ydb.Coordination.SessionResponse.SessionStopped.fromObject(object.sessionStopped);
                }
                if (object.unsupported_6 != null) {
                    if (typeof object.unsupported_6 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.unsupported_6: object expected");
                    message.unsupported_6 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_6);
                }
                if (object.unsupported_7 != null) {
                    if (typeof object.unsupported_7 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.unsupported_7: object expected");
                    message.unsupported_7 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_7);
                }
                if (object.acquireSemaphorePending != null) {
                    if (typeof object.acquireSemaphorePending !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.acquireSemaphorePending: object expected");
                    message.acquireSemaphorePending = $root.Ydb.Coordination.SessionResponse.AcquireSemaphorePending.fromObject(object.acquireSemaphorePending);
                }
                if (object.acquireSemaphoreResult != null) {
                    if (typeof object.acquireSemaphoreResult !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.acquireSemaphoreResult: object expected");
                    message.acquireSemaphoreResult = $root.Ydb.Coordination.SessionResponse.AcquireSemaphoreResult.fromObject(object.acquireSemaphoreResult);
                }
                if (object.releaseSemaphoreResult != null) {
                    if (typeof object.releaseSemaphoreResult !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.releaseSemaphoreResult: object expected");
                    message.releaseSemaphoreResult = $root.Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult.fromObject(object.releaseSemaphoreResult);
                }
                if (object.describeSemaphoreResult != null) {
                    if (typeof object.describeSemaphoreResult !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.describeSemaphoreResult: object expected");
                    message.describeSemaphoreResult = $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.fromObject(object.describeSemaphoreResult);
                }
                if (object.describeSemaphoreChanged != null) {
                    if (typeof object.describeSemaphoreChanged !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.describeSemaphoreChanged: object expected");
                    message.describeSemaphoreChanged = $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged.fromObject(object.describeSemaphoreChanged);
                }
                if (object.createSemaphoreResult != null) {
                    if (typeof object.createSemaphoreResult !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.createSemaphoreResult: object expected");
                    message.createSemaphoreResult = $root.Ydb.Coordination.SessionResponse.CreateSemaphoreResult.fromObject(object.createSemaphoreResult);
                }
                if (object.updateSemaphoreResult != null) {
                    if (typeof object.updateSemaphoreResult !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.updateSemaphoreResult: object expected");
                    message.updateSemaphoreResult = $root.Ydb.Coordination.SessionResponse.UpdateSemaphoreResult.fromObject(object.updateSemaphoreResult);
                }
                if (object.deleteSemaphoreResult != null) {
                    if (typeof object.deleteSemaphoreResult !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.deleteSemaphoreResult: object expected");
                    message.deleteSemaphoreResult = $root.Ydb.Coordination.SessionResponse.DeleteSemaphoreResult.fromObject(object.deleteSemaphoreResult);
                }
                if (object.unsupported_16 != null) {
                    if (typeof object.unsupported_16 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.unsupported_16: object expected");
                    message.unsupported_16 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_16);
                }
                if (object.unsupported_17 != null) {
                    if (typeof object.unsupported_17 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.unsupported_17: object expected");
                    message.unsupported_17 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_17);
                }
                if (object.unsupported_18 != null) {
                    if (typeof object.unsupported_18 !== "object")
                        throw TypeError(".Ydb.Coordination.SessionResponse.unsupported_18: object expected");
                    message.unsupported_18 = $root.Ydb.Coordination.Unsupported.fromObject(object.unsupported_18);
                }
                return message;
            };

            /**
             * Creates a plain object from a SessionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.SessionResponse
             * @static
             * @param {Ydb.Coordination.SessionResponse} message SessionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SessionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.ping != null && message.hasOwnProperty("ping")) {
                    object.ping = $root.Ydb.Coordination.SessionResponse.PingPong.toObject(message.ping, options);
                    if (options.oneofs)
                        object.response = "ping";
                }
                if (message.pong != null && message.hasOwnProperty("pong")) {
                    object.pong = $root.Ydb.Coordination.SessionResponse.PingPong.toObject(message.pong, options);
                    if (options.oneofs)
                        object.response = "pong";
                }
                if (message.failure != null && message.hasOwnProperty("failure")) {
                    object.failure = $root.Ydb.Coordination.SessionResponse.Failure.toObject(message.failure, options);
                    if (options.oneofs)
                        object.response = "failure";
                }
                if (message.sessionStarted != null && message.hasOwnProperty("sessionStarted")) {
                    object.sessionStarted = $root.Ydb.Coordination.SessionResponse.SessionStarted.toObject(message.sessionStarted, options);
                    if (options.oneofs)
                        object.response = "sessionStarted";
                }
                if (message.sessionStopped != null && message.hasOwnProperty("sessionStopped")) {
                    object.sessionStopped = $root.Ydb.Coordination.SessionResponse.SessionStopped.toObject(message.sessionStopped, options);
                    if (options.oneofs)
                        object.response = "sessionStopped";
                }
                if (message.unsupported_6 != null && message.hasOwnProperty("unsupported_6")) {
                    object.unsupported_6 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_6, options);
                    if (options.oneofs)
                        object.response = "unsupported_6";
                }
                if (message.unsupported_7 != null && message.hasOwnProperty("unsupported_7")) {
                    object.unsupported_7 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_7, options);
                    if (options.oneofs)
                        object.response = "unsupported_7";
                }
                if (message.acquireSemaphorePending != null && message.hasOwnProperty("acquireSemaphorePending")) {
                    object.acquireSemaphorePending = $root.Ydb.Coordination.SessionResponse.AcquireSemaphorePending.toObject(message.acquireSemaphorePending, options);
                    if (options.oneofs)
                        object.response = "acquireSemaphorePending";
                }
                if (message.acquireSemaphoreResult != null && message.hasOwnProperty("acquireSemaphoreResult")) {
                    object.acquireSemaphoreResult = $root.Ydb.Coordination.SessionResponse.AcquireSemaphoreResult.toObject(message.acquireSemaphoreResult, options);
                    if (options.oneofs)
                        object.response = "acquireSemaphoreResult";
                }
                if (message.releaseSemaphoreResult != null && message.hasOwnProperty("releaseSemaphoreResult")) {
                    object.releaseSemaphoreResult = $root.Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult.toObject(message.releaseSemaphoreResult, options);
                    if (options.oneofs)
                        object.response = "releaseSemaphoreResult";
                }
                if (message.describeSemaphoreResult != null && message.hasOwnProperty("describeSemaphoreResult")) {
                    object.describeSemaphoreResult = $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.toObject(message.describeSemaphoreResult, options);
                    if (options.oneofs)
                        object.response = "describeSemaphoreResult";
                }
                if (message.describeSemaphoreChanged != null && message.hasOwnProperty("describeSemaphoreChanged")) {
                    object.describeSemaphoreChanged = $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged.toObject(message.describeSemaphoreChanged, options);
                    if (options.oneofs)
                        object.response = "describeSemaphoreChanged";
                }
                if (message.createSemaphoreResult != null && message.hasOwnProperty("createSemaphoreResult")) {
                    object.createSemaphoreResult = $root.Ydb.Coordination.SessionResponse.CreateSemaphoreResult.toObject(message.createSemaphoreResult, options);
                    if (options.oneofs)
                        object.response = "createSemaphoreResult";
                }
                if (message.updateSemaphoreResult != null && message.hasOwnProperty("updateSemaphoreResult")) {
                    object.updateSemaphoreResult = $root.Ydb.Coordination.SessionResponse.UpdateSemaphoreResult.toObject(message.updateSemaphoreResult, options);
                    if (options.oneofs)
                        object.response = "updateSemaphoreResult";
                }
                if (message.deleteSemaphoreResult != null && message.hasOwnProperty("deleteSemaphoreResult")) {
                    object.deleteSemaphoreResult = $root.Ydb.Coordination.SessionResponse.DeleteSemaphoreResult.toObject(message.deleteSemaphoreResult, options);
                    if (options.oneofs)
                        object.response = "deleteSemaphoreResult";
                }
                if (message.unsupported_16 != null && message.hasOwnProperty("unsupported_16")) {
                    object.unsupported_16 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_16, options);
                    if (options.oneofs)
                        object.response = "unsupported_16";
                }
                if (message.unsupported_17 != null && message.hasOwnProperty("unsupported_17")) {
                    object.unsupported_17 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_17, options);
                    if (options.oneofs)
                        object.response = "unsupported_17";
                }
                if (message.unsupported_18 != null && message.hasOwnProperty("unsupported_18")) {
                    object.unsupported_18 = $root.Ydb.Coordination.Unsupported.toObject(message.unsupported_18, options);
                    if (options.oneofs)
                        object.response = "unsupported_18";
                }
                return object;
            };

            /**
             * Converts this SessionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.SessionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SessionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SessionResponse.PingPong = (function() {

                /**
                 * Properties of a PingPong.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface IPingPong
                 * @property {number|Long|null} [opaque] PingPong opaque
                 */

                /**
                 * Constructs a new PingPong.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc Used for checking liveness of the connection
                 * @implements IPingPong
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.IPingPong=} [properties] Properties to set
                 */
                function PingPong(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PingPong opaque.
                 * @member {number|Long} opaque
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @instance
                 */
                PingPong.prototype.opaque = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new PingPong instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IPingPong=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.PingPong} PingPong instance
                 */
                PingPong.create = function create(properties) {
                    return new PingPong(properties);
                };

                /**
                 * Encodes the specified PingPong message. Does not implicitly {@link Ydb.Coordination.SessionResponse.PingPong.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IPingPong} message PingPong message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingPong.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.opaque != null && message.hasOwnProperty("opaque"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.opaque);
                    return writer;
                };

                /**
                 * Encodes the specified PingPong message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.PingPong.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IPingPong} message PingPong message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PingPong.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PingPong message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.PingPong} PingPong
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingPong.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.PingPong();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.opaque = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PingPong message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.PingPong} PingPong
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PingPong.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PingPong message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PingPong.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.opaque != null && message.hasOwnProperty("opaque"))
                        if (!$util.isInteger(message.opaque) && !(message.opaque && $util.isInteger(message.opaque.low) && $util.isInteger(message.opaque.high)))
                            return "opaque: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a PingPong message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.PingPong} PingPong
                 */
                PingPong.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.PingPong)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.PingPong();
                    if (object.opaque != null)
                        if ($util.Long)
                            (message.opaque = $util.Long.fromValue(object.opaque)).unsigned = true;
                        else if (typeof object.opaque === "string")
                            message.opaque = parseInt(object.opaque, 10);
                        else if (typeof object.opaque === "number")
                            message.opaque = object.opaque;
                        else if (typeof object.opaque === "object")
                            message.opaque = new $util.LongBits(object.opaque.low >>> 0, object.opaque.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a PingPong message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.PingPong} message PingPong
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PingPong.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.opaque = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.opaque = options.longs === String ? "0" : 0;
                    if (message.opaque != null && message.hasOwnProperty("opaque"))
                        if (typeof message.opaque === "number")
                            object.opaque = options.longs === String ? String(message.opaque) : message.opaque;
                        else
                            object.opaque = options.longs === String ? $util.Long.prototype.toString.call(message.opaque) : options.longs === Number ? new $util.LongBits(message.opaque.low >>> 0, message.opaque.high >>> 0).toNumber(true) : message.opaque;
                    return object;
                };

                /**
                 * Converts this PingPong to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.PingPong
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PingPong.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PingPong;
            })();

            SessionResponse.Failure = (function() {

                /**
                 * Properties of a Failure.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface IFailure
                 * @property {Ydb.StatusIds.StatusCode|null} [status] Failure status
                 * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] Failure issues
                 */

                /**
                 * Constructs a new Failure.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc Used to report connection and session level failures
                 * @implements IFailure
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.IFailure=} [properties] Properties to set
                 */
                function Failure(properties) {
                    this.issues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Failure status.
                 * @member {Ydb.StatusIds.StatusCode} status
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @instance
                 */
                Failure.prototype.status = 0;

                /**
                 * Failure issues.
                 * @member {Array.<Ydb.Issue.IIssueMessage>} issues
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @instance
                 */
                Failure.prototype.issues = $util.emptyArray;

                /**
                 * Creates a new Failure instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IFailure=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.Failure} Failure instance
                 */
                Failure.create = function create(properties) {
                    return new Failure(properties);
                };

                /**
                 * Encodes the specified Failure message. Does not implicitly {@link Ydb.Coordination.SessionResponse.Failure.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IFailure} message Failure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Failure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                    if (message.issues != null && message.issues.length)
                        for (var i = 0; i < message.issues.length; ++i)
                            $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Failure message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.Failure.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IFailure} message Failure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Failure.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Failure message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.Failure} Failure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Failure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.Failure();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = reader.int32();
                            break;
                        case 2:
                            if (!(message.issues && message.issues.length))
                                message.issues = [];
                            message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Failure message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.Failure} Failure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Failure.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Failure message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Failure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 400000:
                        case 400010:
                        case 400020:
                        case 400030:
                        case 400040:
                        case 400050:
                        case 400060:
                        case 400070:
                        case 400080:
                        case 400090:
                        case 400100:
                        case 400120:
                        case 400130:
                        case 400140:
                        case 400150:
                        case 400160:
                        case 400170:
                        case 400180:
                        case 400190:
                            break;
                        }
                    if (message.issues != null && message.hasOwnProperty("issues")) {
                        if (!Array.isArray(message.issues))
                            return "issues: array expected";
                        for (var i = 0; i < message.issues.length; ++i) {
                            var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                            if (error)
                                return "issues." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Failure message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.Failure} Failure
                 */
                Failure.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.Failure)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.Failure();
                    switch (object.status) {
                    case "STATUS_CODE_UNSPECIFIED":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESS":
                    case 400000:
                        message.status = 400000;
                        break;
                    case "BAD_REQUEST":
                    case 400010:
                        message.status = 400010;
                        break;
                    case "UNAUTHORIZED":
                    case 400020:
                        message.status = 400020;
                        break;
                    case "INTERNAL_ERROR":
                    case 400030:
                        message.status = 400030;
                        break;
                    case "ABORTED":
                    case 400040:
                        message.status = 400040;
                        break;
                    case "UNAVAILABLE":
                    case 400050:
                        message.status = 400050;
                        break;
                    case "OVERLOADED":
                    case 400060:
                        message.status = 400060;
                        break;
                    case "SCHEME_ERROR":
                    case 400070:
                        message.status = 400070;
                        break;
                    case "GENERIC_ERROR":
                    case 400080:
                        message.status = 400080;
                        break;
                    case "TIMEOUT":
                    case 400090:
                        message.status = 400090;
                        break;
                    case "BAD_SESSION":
                    case 400100:
                        message.status = 400100;
                        break;
                    case "PRECONDITION_FAILED":
                    case 400120:
                        message.status = 400120;
                        break;
                    case "ALREADY_EXISTS":
                    case 400130:
                        message.status = 400130;
                        break;
                    case "NOT_FOUND":
                    case 400140:
                        message.status = 400140;
                        break;
                    case "SESSION_EXPIRED":
                    case 400150:
                        message.status = 400150;
                        break;
                    case "CANCELLED":
                    case 400160:
                        message.status = 400160;
                        break;
                    case "UNDETERMINED":
                    case 400170:
                        message.status = 400170;
                        break;
                    case "UNSUPPORTED":
                    case 400180:
                        message.status = 400180;
                        break;
                    case "SESSION_BUSY":
                    case 400190:
                        message.status = 400190;
                        break;
                    }
                    if (object.issues) {
                        if (!Array.isArray(object.issues))
                            throw TypeError(".Ydb.Coordination.SessionResponse.Failure.issues: array expected");
                        message.issues = [];
                        for (var i = 0; i < object.issues.length; ++i) {
                            if (typeof object.issues[i] !== "object")
                                throw TypeError(".Ydb.Coordination.SessionResponse.Failure.issues: object expected");
                            message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Failure message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.Failure} message Failure
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Failure.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.issues = [];
                    if (options.defaults)
                        object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                    if (message.issues && message.issues.length) {
                        object.issues = [];
                        for (var j = 0; j < message.issues.length; ++j)
                            object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Failure to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.Failure
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Failure.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Failure;
            })();

            SessionResponse.SessionStarted = (function() {

                /**
                 * Properties of a SessionStarted.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface ISessionStarted
                 * @property {number|Long|null} [sessionId] SessionStarted sessionId
                 * @property {number|Long|null} [timeoutMillis] SessionStarted timeoutMillis
                 */

                /**
                 * Constructs a new SessionStarted.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc Used to report a successful session create/restore operation
                 * @implements ISessionStarted
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.ISessionStarted=} [properties] Properties to set
                 */
                function SessionStarted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionStarted sessionId.
                 * @member {number|Long} sessionId
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @instance
                 */
                SessionStarted.prototype.sessionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * SessionStarted timeoutMillis.
                 * @member {number|Long} timeoutMillis
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @instance
                 */
                SessionStarted.prototype.timeoutMillis = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new SessionStarted instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ISessionStarted=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.SessionStarted} SessionStarted instance
                 */
                SessionStarted.create = function create(properties) {
                    return new SessionStarted(properties);
                };

                /**
                 * Encodes the specified SessionStarted message. Does not implicitly {@link Ydb.Coordination.SessionResponse.SessionStarted.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ISessionStarted} message SessionStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStarted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sessionId);
                    if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timeoutMillis);
                    return writer;
                };

                /**
                 * Encodes the specified SessionStarted message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.SessionStarted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ISessionStarted} message SessionStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStarted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionStarted message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.SessionStarted} SessionStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStarted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.SessionStarted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sessionId = reader.uint64();
                            break;
                        case 2:
                            message.timeoutMillis = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionStarted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.SessionStarted} SessionStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStarted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionStarted message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionStarted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                        if (!$util.isInteger(message.sessionId) && !(message.sessionId && $util.isInteger(message.sessionId.low) && $util.isInteger(message.sessionId.high)))
                            return "sessionId: integer|Long expected";
                    if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                        if (!$util.isInteger(message.timeoutMillis) && !(message.timeoutMillis && $util.isInteger(message.timeoutMillis.low) && $util.isInteger(message.timeoutMillis.high)))
                            return "timeoutMillis: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a SessionStarted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.SessionStarted} SessionStarted
                 */
                SessionStarted.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.SessionStarted)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.SessionStarted();
                    if (object.sessionId != null)
                        if ($util.Long)
                            (message.sessionId = $util.Long.fromValue(object.sessionId)).unsigned = true;
                        else if (typeof object.sessionId === "string")
                            message.sessionId = parseInt(object.sessionId, 10);
                        else if (typeof object.sessionId === "number")
                            message.sessionId = object.sessionId;
                        else if (typeof object.sessionId === "object")
                            message.sessionId = new $util.LongBits(object.sessionId.low >>> 0, object.sessionId.high >>> 0).toNumber(true);
                    if (object.timeoutMillis != null)
                        if ($util.Long)
                            (message.timeoutMillis = $util.Long.fromValue(object.timeoutMillis)).unsigned = true;
                        else if (typeof object.timeoutMillis === "string")
                            message.timeoutMillis = parseInt(object.timeoutMillis, 10);
                        else if (typeof object.timeoutMillis === "number")
                            message.timeoutMillis = object.timeoutMillis;
                        else if (typeof object.timeoutMillis === "object")
                            message.timeoutMillis = new $util.LongBits(object.timeoutMillis.low >>> 0, object.timeoutMillis.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a SessionStarted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.SessionStarted} message SessionStarted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionStarted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.sessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.sessionId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.timeoutMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timeoutMillis = options.longs === String ? "0" : 0;
                    }
                    if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                        if (typeof message.sessionId === "number")
                            object.sessionId = options.longs === String ? String(message.sessionId) : message.sessionId;
                        else
                            object.sessionId = options.longs === String ? $util.Long.prototype.toString.call(message.sessionId) : options.longs === Number ? new $util.LongBits(message.sessionId.low >>> 0, message.sessionId.high >>> 0).toNumber(true) : message.sessionId;
                    if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                        if (typeof message.timeoutMillis === "number")
                            object.timeoutMillis = options.longs === String ? String(message.timeoutMillis) : message.timeoutMillis;
                        else
                            object.timeoutMillis = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutMillis) : options.longs === Number ? new $util.LongBits(message.timeoutMillis.low >>> 0, message.timeoutMillis.high >>> 0).toNumber(true) : message.timeoutMillis;
                    return object;
                };

                /**
                 * Converts this SessionStarted to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.SessionStarted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionStarted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionStarted;
            })();

            SessionResponse.SessionStopped = (function() {

                /**
                 * Properties of a SessionStopped.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface ISessionStopped
                 * @property {number|Long|null} [sessionId] SessionStopped sessionId
                 */

                /**
                 * Constructs a new SessionStopped.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc Used to report a successful graceful termination of the session
                 * @implements ISessionStopped
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.ISessionStopped=} [properties] Properties to set
                 */
                function SessionStopped(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SessionStopped sessionId.
                 * @member {number|Long} sessionId
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @instance
                 */
                SessionStopped.prototype.sessionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new SessionStopped instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ISessionStopped=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.SessionStopped} SessionStopped instance
                 */
                SessionStopped.create = function create(properties) {
                    return new SessionStopped(properties);
                };

                /**
                 * Encodes the specified SessionStopped message. Does not implicitly {@link Ydb.Coordination.SessionResponse.SessionStopped.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ISessionStopped} message SessionStopped message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStopped.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sessionId);
                    return writer;
                };

                /**
                 * Encodes the specified SessionStopped message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.SessionStopped.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ISessionStopped} message SessionStopped message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SessionStopped.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SessionStopped message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.SessionStopped} SessionStopped
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStopped.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.SessionStopped();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sessionId = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SessionStopped message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.SessionStopped} SessionStopped
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SessionStopped.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SessionStopped message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SessionStopped.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                        if (!$util.isInteger(message.sessionId) && !(message.sessionId && $util.isInteger(message.sessionId.low) && $util.isInteger(message.sessionId.high)))
                            return "sessionId: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a SessionStopped message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.SessionStopped} SessionStopped
                 */
                SessionStopped.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.SessionStopped)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.SessionStopped();
                    if (object.sessionId != null)
                        if ($util.Long)
                            (message.sessionId = $util.Long.fromValue(object.sessionId)).unsigned = true;
                        else if (typeof object.sessionId === "string")
                            message.sessionId = parseInt(object.sessionId, 10);
                        else if (typeof object.sessionId === "number")
                            message.sessionId = object.sessionId;
                        else if (typeof object.sessionId === "object")
                            message.sessionId = new $util.LongBits(object.sessionId.low >>> 0, object.sessionId.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a SessionStopped message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.SessionStopped} message SessionStopped
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SessionStopped.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.sessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.sessionId = options.longs === String ? "0" : 0;
                    if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                        if (typeof message.sessionId === "number")
                            object.sessionId = options.longs === String ? String(message.sessionId) : message.sessionId;
                        else
                            object.sessionId = options.longs === String ? $util.Long.prototype.toString.call(message.sessionId) : options.longs === Number ? new $util.LongBits(message.sessionId.low >>> 0, message.sessionId.high >>> 0).toNumber(true) : message.sessionId;
                    return object;
                };

                /**
                 * Converts this SessionStopped to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.SessionStopped
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SessionStopped.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SessionStopped;
            })();

            SessionResponse.AcquireSemaphorePending = (function() {

                /**
                 * Properties of an AcquireSemaphorePending.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface IAcquireSemaphorePending
                 * @property {number|Long|null} [reqId] AcquireSemaphorePending reqId
                 */

                /**
                 * Constructs a new AcquireSemaphorePending.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc Used by the server to report when an acquire operation is added to the waiters queue
                 * @implements IAcquireSemaphorePending
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.IAcquireSemaphorePending=} [properties] Properties to set
                 */
                function AcquireSemaphorePending(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AcquireSemaphorePending reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @instance
                 */
                AcquireSemaphorePending.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new AcquireSemaphorePending instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IAcquireSemaphorePending=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.AcquireSemaphorePending} AcquireSemaphorePending instance
                 */
                AcquireSemaphorePending.create = function create(properties) {
                    return new AcquireSemaphorePending(properties);
                };

                /**
                 * Encodes the specified AcquireSemaphorePending message. Does not implicitly {@link Ydb.Coordination.SessionResponse.AcquireSemaphorePending.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IAcquireSemaphorePending} message AcquireSemaphorePending message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AcquireSemaphorePending.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    return writer;
                };

                /**
                 * Encodes the specified AcquireSemaphorePending message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.AcquireSemaphorePending.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IAcquireSemaphorePending} message AcquireSemaphorePending message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AcquireSemaphorePending.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AcquireSemaphorePending message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.AcquireSemaphorePending} AcquireSemaphorePending
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AcquireSemaphorePending.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.AcquireSemaphorePending();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AcquireSemaphorePending message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.AcquireSemaphorePending} AcquireSemaphorePending
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AcquireSemaphorePending.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AcquireSemaphorePending message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AcquireSemaphorePending.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an AcquireSemaphorePending message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.AcquireSemaphorePending} AcquireSemaphorePending
                 */
                AcquireSemaphorePending.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.AcquireSemaphorePending)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.AcquireSemaphorePending();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from an AcquireSemaphorePending message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.AcquireSemaphorePending} message AcquireSemaphorePending
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AcquireSemaphorePending.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    return object;
                };

                /**
                 * Converts this AcquireSemaphorePending to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphorePending
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AcquireSemaphorePending.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AcquireSemaphorePending;
            })();

            SessionResponse.AcquireSemaphoreResult = (function() {

                /**
                 * Properties of an AcquireSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface IAcquireSemaphoreResult
                 * @property {number|Long|null} [reqId] AcquireSemaphoreResult reqId
                 * @property {Ydb.StatusIds.StatusCode|null} [status] AcquireSemaphoreResult status
                 * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] AcquireSemaphoreResult issues
                 * @property {boolean|null} [acquired] AcquireSemaphoreResult acquired
                 */

                /**
                 * Constructs a new AcquireSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc Used by the server to report the result of an acquire operation
                 * @implements IAcquireSemaphoreResult
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.IAcquireSemaphoreResult=} [properties] Properties to set
                 */
                function AcquireSemaphoreResult(properties) {
                    this.issues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AcquireSemaphoreResult reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @instance
                 */
                AcquireSemaphoreResult.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * AcquireSemaphoreResult status.
                 * @member {Ydb.StatusIds.StatusCode} status
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @instance
                 */
                AcquireSemaphoreResult.prototype.status = 0;

                /**
                 * AcquireSemaphoreResult issues.
                 * @member {Array.<Ydb.Issue.IIssueMessage>} issues
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @instance
                 */
                AcquireSemaphoreResult.prototype.issues = $util.emptyArray;

                /**
                 * AcquireSemaphoreResult acquired.
                 * @member {boolean} acquired
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @instance
                 */
                AcquireSemaphoreResult.prototype.acquired = false;

                /**
                 * Creates a new AcquireSemaphoreResult instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IAcquireSemaphoreResult=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.AcquireSemaphoreResult} AcquireSemaphoreResult instance
                 */
                AcquireSemaphoreResult.create = function create(properties) {
                    return new AcquireSemaphoreResult(properties);
                };

                /**
                 * Encodes the specified AcquireSemaphoreResult message. Does not implicitly {@link Ydb.Coordination.SessionResponse.AcquireSemaphoreResult.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IAcquireSemaphoreResult} message AcquireSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AcquireSemaphoreResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    if (message.issues != null && message.issues.length)
                        for (var i = 0; i < message.issues.length; ++i)
                            $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.acquired != null && message.hasOwnProperty("acquired"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.acquired);
                    return writer;
                };

                /**
                 * Encodes the specified AcquireSemaphoreResult message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.AcquireSemaphoreResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IAcquireSemaphoreResult} message AcquireSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AcquireSemaphoreResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AcquireSemaphoreResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.AcquireSemaphoreResult} AcquireSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AcquireSemaphoreResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.AcquireSemaphoreResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.status = reader.int32();
                            break;
                        case 3:
                            if (!(message.issues && message.issues.length))
                                message.issues = [];
                            message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.acquired = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AcquireSemaphoreResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.AcquireSemaphoreResult} AcquireSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AcquireSemaphoreResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AcquireSemaphoreResult message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AcquireSemaphoreResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 400000:
                        case 400010:
                        case 400020:
                        case 400030:
                        case 400040:
                        case 400050:
                        case 400060:
                        case 400070:
                        case 400080:
                        case 400090:
                        case 400100:
                        case 400120:
                        case 400130:
                        case 400140:
                        case 400150:
                        case 400160:
                        case 400170:
                        case 400180:
                        case 400190:
                            break;
                        }
                    if (message.issues != null && message.hasOwnProperty("issues")) {
                        if (!Array.isArray(message.issues))
                            return "issues: array expected";
                        for (var i = 0; i < message.issues.length; ++i) {
                            var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                            if (error)
                                return "issues." + error;
                        }
                    }
                    if (message.acquired != null && message.hasOwnProperty("acquired"))
                        if (typeof message.acquired !== "boolean")
                            return "acquired: boolean expected";
                    return null;
                };

                /**
                 * Creates an AcquireSemaphoreResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.AcquireSemaphoreResult} AcquireSemaphoreResult
                 */
                AcquireSemaphoreResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.AcquireSemaphoreResult)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.AcquireSemaphoreResult();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    switch (object.status) {
                    case "STATUS_CODE_UNSPECIFIED":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESS":
                    case 400000:
                        message.status = 400000;
                        break;
                    case "BAD_REQUEST":
                    case 400010:
                        message.status = 400010;
                        break;
                    case "UNAUTHORIZED":
                    case 400020:
                        message.status = 400020;
                        break;
                    case "INTERNAL_ERROR":
                    case 400030:
                        message.status = 400030;
                        break;
                    case "ABORTED":
                    case 400040:
                        message.status = 400040;
                        break;
                    case "UNAVAILABLE":
                    case 400050:
                        message.status = 400050;
                        break;
                    case "OVERLOADED":
                    case 400060:
                        message.status = 400060;
                        break;
                    case "SCHEME_ERROR":
                    case 400070:
                        message.status = 400070;
                        break;
                    case "GENERIC_ERROR":
                    case 400080:
                        message.status = 400080;
                        break;
                    case "TIMEOUT":
                    case 400090:
                        message.status = 400090;
                        break;
                    case "BAD_SESSION":
                    case 400100:
                        message.status = 400100;
                        break;
                    case "PRECONDITION_FAILED":
                    case 400120:
                        message.status = 400120;
                        break;
                    case "ALREADY_EXISTS":
                    case 400130:
                        message.status = 400130;
                        break;
                    case "NOT_FOUND":
                    case 400140:
                        message.status = 400140;
                        break;
                    case "SESSION_EXPIRED":
                    case 400150:
                        message.status = 400150;
                        break;
                    case "CANCELLED":
                    case 400160:
                        message.status = 400160;
                        break;
                    case "UNDETERMINED":
                    case 400170:
                        message.status = 400170;
                        break;
                    case "UNSUPPORTED":
                    case 400180:
                        message.status = 400180;
                        break;
                    case "SESSION_BUSY":
                    case 400190:
                        message.status = 400190;
                        break;
                    }
                    if (object.issues) {
                        if (!Array.isArray(object.issues))
                            throw TypeError(".Ydb.Coordination.SessionResponse.AcquireSemaphoreResult.issues: array expected");
                        message.issues = [];
                        for (var i = 0; i < object.issues.length; ++i) {
                            if (typeof object.issues[i] !== "object")
                                throw TypeError(".Ydb.Coordination.SessionResponse.AcquireSemaphoreResult.issues: object expected");
                            message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                        }
                    }
                    if (object.acquired != null)
                        message.acquired = Boolean(object.acquired);
                    return message;
                };

                /**
                 * Creates a plain object from an AcquireSemaphoreResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.AcquireSemaphoreResult} message AcquireSemaphoreResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AcquireSemaphoreResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.issues = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                        object.acquired = false;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                    if (message.issues && message.issues.length) {
                        object.issues = [];
                        for (var j = 0; j < message.issues.length; ++j)
                            object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                    }
                    if (message.acquired != null && message.hasOwnProperty("acquired"))
                        object.acquired = message.acquired;
                    return object;
                };

                /**
                 * Converts this AcquireSemaphoreResult to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.AcquireSemaphoreResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AcquireSemaphoreResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AcquireSemaphoreResult;
            })();

            SessionResponse.ReleaseSemaphoreResult = (function() {

                /**
                 * Properties of a ReleaseSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface IReleaseSemaphoreResult
                 * @property {number|Long|null} [reqId] ReleaseSemaphoreResult reqId
                 * @property {Ydb.StatusIds.StatusCode|null} [status] ReleaseSemaphoreResult status
                 * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ReleaseSemaphoreResult issues
                 * @property {boolean|null} [released] ReleaseSemaphoreResult released
                 */

                /**
                 * Constructs a new ReleaseSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc Used by the server to report the result of a release operation
                 * @implements IReleaseSemaphoreResult
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.IReleaseSemaphoreResult=} [properties] Properties to set
                 */
                function ReleaseSemaphoreResult(properties) {
                    this.issues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReleaseSemaphoreResult reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @instance
                 */
                ReleaseSemaphoreResult.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReleaseSemaphoreResult status.
                 * @member {Ydb.StatusIds.StatusCode} status
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @instance
                 */
                ReleaseSemaphoreResult.prototype.status = 0;

                /**
                 * ReleaseSemaphoreResult issues.
                 * @member {Array.<Ydb.Issue.IIssueMessage>} issues
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @instance
                 */
                ReleaseSemaphoreResult.prototype.issues = $util.emptyArray;

                /**
                 * ReleaseSemaphoreResult released.
                 * @member {boolean} released
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @instance
                 */
                ReleaseSemaphoreResult.prototype.released = false;

                /**
                 * Creates a new ReleaseSemaphoreResult instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IReleaseSemaphoreResult=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult} ReleaseSemaphoreResult instance
                 */
                ReleaseSemaphoreResult.create = function create(properties) {
                    return new ReleaseSemaphoreResult(properties);
                };

                /**
                 * Encodes the specified ReleaseSemaphoreResult message. Does not implicitly {@link Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IReleaseSemaphoreResult} message ReleaseSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReleaseSemaphoreResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    if (message.issues != null && message.issues.length)
                        for (var i = 0; i < message.issues.length; ++i)
                            $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.released != null && message.hasOwnProperty("released"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.released);
                    return writer;
                };

                /**
                 * Encodes the specified ReleaseSemaphoreResult message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IReleaseSemaphoreResult} message ReleaseSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReleaseSemaphoreResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReleaseSemaphoreResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult} ReleaseSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReleaseSemaphoreResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.status = reader.int32();
                            break;
                        case 3:
                            if (!(message.issues && message.issues.length))
                                message.issues = [];
                            message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.released = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReleaseSemaphoreResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult} ReleaseSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReleaseSemaphoreResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReleaseSemaphoreResult message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReleaseSemaphoreResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 400000:
                        case 400010:
                        case 400020:
                        case 400030:
                        case 400040:
                        case 400050:
                        case 400060:
                        case 400070:
                        case 400080:
                        case 400090:
                        case 400100:
                        case 400120:
                        case 400130:
                        case 400140:
                        case 400150:
                        case 400160:
                        case 400170:
                        case 400180:
                        case 400190:
                            break;
                        }
                    if (message.issues != null && message.hasOwnProperty("issues")) {
                        if (!Array.isArray(message.issues))
                            return "issues: array expected";
                        for (var i = 0; i < message.issues.length; ++i) {
                            var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                            if (error)
                                return "issues." + error;
                        }
                    }
                    if (message.released != null && message.hasOwnProperty("released"))
                        if (typeof message.released !== "boolean")
                            return "released: boolean expected";
                    return null;
                };

                /**
                 * Creates a ReleaseSemaphoreResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult} ReleaseSemaphoreResult
                 */
                ReleaseSemaphoreResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    switch (object.status) {
                    case "STATUS_CODE_UNSPECIFIED":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESS":
                    case 400000:
                        message.status = 400000;
                        break;
                    case "BAD_REQUEST":
                    case 400010:
                        message.status = 400010;
                        break;
                    case "UNAUTHORIZED":
                    case 400020:
                        message.status = 400020;
                        break;
                    case "INTERNAL_ERROR":
                    case 400030:
                        message.status = 400030;
                        break;
                    case "ABORTED":
                    case 400040:
                        message.status = 400040;
                        break;
                    case "UNAVAILABLE":
                    case 400050:
                        message.status = 400050;
                        break;
                    case "OVERLOADED":
                    case 400060:
                        message.status = 400060;
                        break;
                    case "SCHEME_ERROR":
                    case 400070:
                        message.status = 400070;
                        break;
                    case "GENERIC_ERROR":
                    case 400080:
                        message.status = 400080;
                        break;
                    case "TIMEOUT":
                    case 400090:
                        message.status = 400090;
                        break;
                    case "BAD_SESSION":
                    case 400100:
                        message.status = 400100;
                        break;
                    case "PRECONDITION_FAILED":
                    case 400120:
                        message.status = 400120;
                        break;
                    case "ALREADY_EXISTS":
                    case 400130:
                        message.status = 400130;
                        break;
                    case "NOT_FOUND":
                    case 400140:
                        message.status = 400140;
                        break;
                    case "SESSION_EXPIRED":
                    case 400150:
                        message.status = 400150;
                        break;
                    case "CANCELLED":
                    case 400160:
                        message.status = 400160;
                        break;
                    case "UNDETERMINED":
                    case 400170:
                        message.status = 400170;
                        break;
                    case "UNSUPPORTED":
                    case 400180:
                        message.status = 400180;
                        break;
                    case "SESSION_BUSY":
                    case 400190:
                        message.status = 400190;
                        break;
                    }
                    if (object.issues) {
                        if (!Array.isArray(object.issues))
                            throw TypeError(".Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult.issues: array expected");
                        message.issues = [];
                        for (var i = 0; i < object.issues.length; ++i) {
                            if (typeof object.issues[i] !== "object")
                                throw TypeError(".Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult.issues: object expected");
                            message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                        }
                    }
                    if (object.released != null)
                        message.released = Boolean(object.released);
                    return message;
                };

                /**
                 * Creates a plain object from a ReleaseSemaphoreResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult} message ReleaseSemaphoreResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReleaseSemaphoreResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.issues = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                        object.released = false;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                    if (message.issues && message.issues.length) {
                        object.issues = [];
                        for (var j = 0; j < message.issues.length; ++j)
                            object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                    }
                    if (message.released != null && message.hasOwnProperty("released"))
                        object.released = message.released;
                    return object;
                };

                /**
                 * Converts this ReleaseSemaphoreResult to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.ReleaseSemaphoreResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReleaseSemaphoreResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReleaseSemaphoreResult;
            })();

            SessionResponse.DescribeSemaphoreResult = (function() {

                /**
                 * Properties of a DescribeSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface IDescribeSemaphoreResult
                 * @property {number|Long|null} [reqId] DescribeSemaphoreResult reqId
                 * @property {Ydb.StatusIds.StatusCode|null} [status] DescribeSemaphoreResult status
                 * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] DescribeSemaphoreResult issues
                 * @property {Ydb.Coordination.ISemaphoreDescription|null} [semaphoreDescription] DescribeSemaphoreResult semaphoreDescription
                 * @property {boolean|null} [watchAdded] DescribeSemaphoreResult watchAdded
                 */

                /**
                 * Constructs a new DescribeSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc The result of the describe operation
                 * @implements IDescribeSemaphoreResult
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.IDescribeSemaphoreResult=} [properties] Properties to set
                 */
                function DescribeSemaphoreResult(properties) {
                    this.issues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeSemaphoreResult reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @instance
                 */
                DescribeSemaphoreResult.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * DescribeSemaphoreResult status.
                 * @member {Ydb.StatusIds.StatusCode} status
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @instance
                 */
                DescribeSemaphoreResult.prototype.status = 0;

                /**
                 * DescribeSemaphoreResult issues.
                 * @member {Array.<Ydb.Issue.IIssueMessage>} issues
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @instance
                 */
                DescribeSemaphoreResult.prototype.issues = $util.emptyArray;

                /**
                 * DescribeSemaphoreResult semaphoreDescription.
                 * @member {Ydb.Coordination.ISemaphoreDescription|null|undefined} semaphoreDescription
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @instance
                 */
                DescribeSemaphoreResult.prototype.semaphoreDescription = null;

                /**
                 * DescribeSemaphoreResult watchAdded.
                 * @member {boolean} watchAdded
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @instance
                 */
                DescribeSemaphoreResult.prototype.watchAdded = false;

                /**
                 * Creates a new DescribeSemaphoreResult instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IDescribeSemaphoreResult=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.DescribeSemaphoreResult} DescribeSemaphoreResult instance
                 */
                DescribeSemaphoreResult.create = function create(properties) {
                    return new DescribeSemaphoreResult(properties);
                };

                /**
                 * Encodes the specified DescribeSemaphoreResult message. Does not implicitly {@link Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IDescribeSemaphoreResult} message DescribeSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescribeSemaphoreResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    if (message.issues != null && message.issues.length)
                        for (var i = 0; i < message.issues.length; ++i)
                            $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.semaphoreDescription != null && message.hasOwnProperty("semaphoreDescription"))
                        $root.Ydb.Coordination.SemaphoreDescription.encode(message.semaphoreDescription, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.watchAdded != null && message.hasOwnProperty("watchAdded"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.watchAdded);
                    return writer;
                };

                /**
                 * Encodes the specified DescribeSemaphoreResult message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IDescribeSemaphoreResult} message DescribeSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescribeSemaphoreResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DescribeSemaphoreResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.DescribeSemaphoreResult} DescribeSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescribeSemaphoreResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.status = reader.int32();
                            break;
                        case 3:
                            if (!(message.issues && message.issues.length))
                                message.issues = [];
                            message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.semaphoreDescription = $root.Ydb.Coordination.SemaphoreDescription.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.watchAdded = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DescribeSemaphoreResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.DescribeSemaphoreResult} DescribeSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescribeSemaphoreResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DescribeSemaphoreResult message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeSemaphoreResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 400000:
                        case 400010:
                        case 400020:
                        case 400030:
                        case 400040:
                        case 400050:
                        case 400060:
                        case 400070:
                        case 400080:
                        case 400090:
                        case 400100:
                        case 400120:
                        case 400130:
                        case 400140:
                        case 400150:
                        case 400160:
                        case 400170:
                        case 400180:
                        case 400190:
                            break;
                        }
                    if (message.issues != null && message.hasOwnProperty("issues")) {
                        if (!Array.isArray(message.issues))
                            return "issues: array expected";
                        for (var i = 0; i < message.issues.length; ++i) {
                            var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                            if (error)
                                return "issues." + error;
                        }
                    }
                    if (message.semaphoreDescription != null && message.hasOwnProperty("semaphoreDescription")) {
                        var error = $root.Ydb.Coordination.SemaphoreDescription.verify(message.semaphoreDescription);
                        if (error)
                            return "semaphoreDescription." + error;
                    }
                    if (message.watchAdded != null && message.hasOwnProperty("watchAdded"))
                        if (typeof message.watchAdded !== "boolean")
                            return "watchAdded: boolean expected";
                    return null;
                };

                /**
                 * Creates a DescribeSemaphoreResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.DescribeSemaphoreResult} DescribeSemaphoreResult
                 */
                DescribeSemaphoreResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreResult)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreResult();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    switch (object.status) {
                    case "STATUS_CODE_UNSPECIFIED":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESS":
                    case 400000:
                        message.status = 400000;
                        break;
                    case "BAD_REQUEST":
                    case 400010:
                        message.status = 400010;
                        break;
                    case "UNAUTHORIZED":
                    case 400020:
                        message.status = 400020;
                        break;
                    case "INTERNAL_ERROR":
                    case 400030:
                        message.status = 400030;
                        break;
                    case "ABORTED":
                    case 400040:
                        message.status = 400040;
                        break;
                    case "UNAVAILABLE":
                    case 400050:
                        message.status = 400050;
                        break;
                    case "OVERLOADED":
                    case 400060:
                        message.status = 400060;
                        break;
                    case "SCHEME_ERROR":
                    case 400070:
                        message.status = 400070;
                        break;
                    case "GENERIC_ERROR":
                    case 400080:
                        message.status = 400080;
                        break;
                    case "TIMEOUT":
                    case 400090:
                        message.status = 400090;
                        break;
                    case "BAD_SESSION":
                    case 400100:
                        message.status = 400100;
                        break;
                    case "PRECONDITION_FAILED":
                    case 400120:
                        message.status = 400120;
                        break;
                    case "ALREADY_EXISTS":
                    case 400130:
                        message.status = 400130;
                        break;
                    case "NOT_FOUND":
                    case 400140:
                        message.status = 400140;
                        break;
                    case "SESSION_EXPIRED":
                    case 400150:
                        message.status = 400150;
                        break;
                    case "CANCELLED":
                    case 400160:
                        message.status = 400160;
                        break;
                    case "UNDETERMINED":
                    case 400170:
                        message.status = 400170;
                        break;
                    case "UNSUPPORTED":
                    case 400180:
                        message.status = 400180;
                        break;
                    case "SESSION_BUSY":
                    case 400190:
                        message.status = 400190;
                        break;
                    }
                    if (object.issues) {
                        if (!Array.isArray(object.issues))
                            throw TypeError(".Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.issues: array expected");
                        message.issues = [];
                        for (var i = 0; i < object.issues.length; ++i) {
                            if (typeof object.issues[i] !== "object")
                                throw TypeError(".Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.issues: object expected");
                            message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                        }
                    }
                    if (object.semaphoreDescription != null) {
                        if (typeof object.semaphoreDescription !== "object")
                            throw TypeError(".Ydb.Coordination.SessionResponse.DescribeSemaphoreResult.semaphoreDescription: object expected");
                        message.semaphoreDescription = $root.Ydb.Coordination.SemaphoreDescription.fromObject(object.semaphoreDescription);
                    }
                    if (object.watchAdded != null)
                        message.watchAdded = Boolean(object.watchAdded);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeSemaphoreResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.DescribeSemaphoreResult} message DescribeSemaphoreResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeSemaphoreResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.issues = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                        object.semaphoreDescription = null;
                        object.watchAdded = false;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                    if (message.issues && message.issues.length) {
                        object.issues = [];
                        for (var j = 0; j < message.issues.length; ++j)
                            object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                    }
                    if (message.semaphoreDescription != null && message.hasOwnProperty("semaphoreDescription"))
                        object.semaphoreDescription = $root.Ydb.Coordination.SemaphoreDescription.toObject(message.semaphoreDescription, options);
                    if (message.watchAdded != null && message.hasOwnProperty("watchAdded"))
                        object.watchAdded = message.watchAdded;
                    return object;
                };

                /**
                 * Converts this DescribeSemaphoreResult to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeSemaphoreResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeSemaphoreResult;
            })();

            SessionResponse.DescribeSemaphoreChanged = (function() {

                /**
                 * Properties of a DescribeSemaphoreChanged.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface IDescribeSemaphoreChanged
                 * @property {number|Long|null} [reqId] DescribeSemaphoreChanged reqId
                 * @property {boolean|null} [dataChanged] DescribeSemaphoreChanged dataChanged
                 * @property {boolean|null} [ownersChanged] DescribeSemaphoreChanged ownersChanged
                 */

                /**
                 * Constructs a new DescribeSemaphoreChanged.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc Used to report a change in the watched semaphore
                 * @implements IDescribeSemaphoreChanged
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.IDescribeSemaphoreChanged=} [properties] Properties to set
                 */
                function DescribeSemaphoreChanged(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeSemaphoreChanged reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @instance
                 */
                DescribeSemaphoreChanged.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * DescribeSemaphoreChanged dataChanged.
                 * @member {boolean} dataChanged
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @instance
                 */
                DescribeSemaphoreChanged.prototype.dataChanged = false;

                /**
                 * DescribeSemaphoreChanged ownersChanged.
                 * @member {boolean} ownersChanged
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @instance
                 */
                DescribeSemaphoreChanged.prototype.ownersChanged = false;

                /**
                 * Creates a new DescribeSemaphoreChanged instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IDescribeSemaphoreChanged=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged} DescribeSemaphoreChanged instance
                 */
                DescribeSemaphoreChanged.create = function create(properties) {
                    return new DescribeSemaphoreChanged(properties);
                };

                /**
                 * Encodes the specified DescribeSemaphoreChanged message. Does not implicitly {@link Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IDescribeSemaphoreChanged} message DescribeSemaphoreChanged message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescribeSemaphoreChanged.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.dataChanged != null && message.hasOwnProperty("dataChanged"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.dataChanged);
                    if (message.ownersChanged != null && message.hasOwnProperty("ownersChanged"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.ownersChanged);
                    return writer;
                };

                /**
                 * Encodes the specified DescribeSemaphoreChanged message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IDescribeSemaphoreChanged} message DescribeSemaphoreChanged message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescribeSemaphoreChanged.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DescribeSemaphoreChanged message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged} DescribeSemaphoreChanged
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescribeSemaphoreChanged.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.dataChanged = reader.bool();
                            break;
                        case 3:
                            message.ownersChanged = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DescribeSemaphoreChanged message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged} DescribeSemaphoreChanged
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescribeSemaphoreChanged.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DescribeSemaphoreChanged message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeSemaphoreChanged.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.dataChanged != null && message.hasOwnProperty("dataChanged"))
                        if (typeof message.dataChanged !== "boolean")
                            return "dataChanged: boolean expected";
                    if (message.ownersChanged != null && message.hasOwnProperty("ownersChanged"))
                        if (typeof message.ownersChanged !== "boolean")
                            return "ownersChanged: boolean expected";
                    return null;
                };

                /**
                 * Creates a DescribeSemaphoreChanged message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged} DescribeSemaphoreChanged
                 */
                DescribeSemaphoreChanged.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    if (object.dataChanged != null)
                        message.dataChanged = Boolean(object.dataChanged);
                    if (object.ownersChanged != null)
                        message.ownersChanged = Boolean(object.ownersChanged);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeSemaphoreChanged message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged} message DescribeSemaphoreChanged
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeSemaphoreChanged.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.dataChanged = false;
                        object.ownersChanged = false;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.dataChanged != null && message.hasOwnProperty("dataChanged"))
                        object.dataChanged = message.dataChanged;
                    if (message.ownersChanged != null && message.hasOwnProperty("ownersChanged"))
                        object.ownersChanged = message.ownersChanged;
                    return object;
                };

                /**
                 * Converts this DescribeSemaphoreChanged to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.DescribeSemaphoreChanged
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeSemaphoreChanged.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeSemaphoreChanged;
            })();

            SessionResponse.CreateSemaphoreResult = (function() {

                /**
                 * Properties of a CreateSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface ICreateSemaphoreResult
                 * @property {number|Long|null} [reqId] CreateSemaphoreResult reqId
                 * @property {Ydb.StatusIds.StatusCode|null} [status] CreateSemaphoreResult status
                 * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] CreateSemaphoreResult issues
                 */

                /**
                 * Constructs a new CreateSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc The result of semaphore creation
                 * @implements ICreateSemaphoreResult
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.ICreateSemaphoreResult=} [properties] Properties to set
                 */
                function CreateSemaphoreResult(properties) {
                    this.issues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateSemaphoreResult reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @instance
                 */
                CreateSemaphoreResult.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * CreateSemaphoreResult status.
                 * @member {Ydb.StatusIds.StatusCode} status
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @instance
                 */
                CreateSemaphoreResult.prototype.status = 0;

                /**
                 * CreateSemaphoreResult issues.
                 * @member {Array.<Ydb.Issue.IIssueMessage>} issues
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @instance
                 */
                CreateSemaphoreResult.prototype.issues = $util.emptyArray;

                /**
                 * Creates a new CreateSemaphoreResult instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ICreateSemaphoreResult=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.CreateSemaphoreResult} CreateSemaphoreResult instance
                 */
                CreateSemaphoreResult.create = function create(properties) {
                    return new CreateSemaphoreResult(properties);
                };

                /**
                 * Encodes the specified CreateSemaphoreResult message. Does not implicitly {@link Ydb.Coordination.SessionResponse.CreateSemaphoreResult.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ICreateSemaphoreResult} message CreateSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateSemaphoreResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    if (message.issues != null && message.issues.length)
                        for (var i = 0; i < message.issues.length; ++i)
                            $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CreateSemaphoreResult message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.CreateSemaphoreResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.ICreateSemaphoreResult} message CreateSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateSemaphoreResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateSemaphoreResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.CreateSemaphoreResult} CreateSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateSemaphoreResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.CreateSemaphoreResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.status = reader.int32();
                            break;
                        case 3:
                            if (!(message.issues && message.issues.length))
                                message.issues = [];
                            message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateSemaphoreResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.CreateSemaphoreResult} CreateSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateSemaphoreResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateSemaphoreResult message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateSemaphoreResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 400000:
                        case 400010:
                        case 400020:
                        case 400030:
                        case 400040:
                        case 400050:
                        case 400060:
                        case 400070:
                        case 400080:
                        case 400090:
                        case 400100:
                        case 400120:
                        case 400130:
                        case 400140:
                        case 400150:
                        case 400160:
                        case 400170:
                        case 400180:
                        case 400190:
                            break;
                        }
                    if (message.issues != null && message.hasOwnProperty("issues")) {
                        if (!Array.isArray(message.issues))
                            return "issues: array expected";
                        for (var i = 0; i < message.issues.length; ++i) {
                            var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                            if (error)
                                return "issues." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CreateSemaphoreResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.CreateSemaphoreResult} CreateSemaphoreResult
                 */
                CreateSemaphoreResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.CreateSemaphoreResult)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.CreateSemaphoreResult();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    switch (object.status) {
                    case "STATUS_CODE_UNSPECIFIED":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESS":
                    case 400000:
                        message.status = 400000;
                        break;
                    case "BAD_REQUEST":
                    case 400010:
                        message.status = 400010;
                        break;
                    case "UNAUTHORIZED":
                    case 400020:
                        message.status = 400020;
                        break;
                    case "INTERNAL_ERROR":
                    case 400030:
                        message.status = 400030;
                        break;
                    case "ABORTED":
                    case 400040:
                        message.status = 400040;
                        break;
                    case "UNAVAILABLE":
                    case 400050:
                        message.status = 400050;
                        break;
                    case "OVERLOADED":
                    case 400060:
                        message.status = 400060;
                        break;
                    case "SCHEME_ERROR":
                    case 400070:
                        message.status = 400070;
                        break;
                    case "GENERIC_ERROR":
                    case 400080:
                        message.status = 400080;
                        break;
                    case "TIMEOUT":
                    case 400090:
                        message.status = 400090;
                        break;
                    case "BAD_SESSION":
                    case 400100:
                        message.status = 400100;
                        break;
                    case "PRECONDITION_FAILED":
                    case 400120:
                        message.status = 400120;
                        break;
                    case "ALREADY_EXISTS":
                    case 400130:
                        message.status = 400130;
                        break;
                    case "NOT_FOUND":
                    case 400140:
                        message.status = 400140;
                        break;
                    case "SESSION_EXPIRED":
                    case 400150:
                        message.status = 400150;
                        break;
                    case "CANCELLED":
                    case 400160:
                        message.status = 400160;
                        break;
                    case "UNDETERMINED":
                    case 400170:
                        message.status = 400170;
                        break;
                    case "UNSUPPORTED":
                    case 400180:
                        message.status = 400180;
                        break;
                    case "SESSION_BUSY":
                    case 400190:
                        message.status = 400190;
                        break;
                    }
                    if (object.issues) {
                        if (!Array.isArray(object.issues))
                            throw TypeError(".Ydb.Coordination.SessionResponse.CreateSemaphoreResult.issues: array expected");
                        message.issues = [];
                        for (var i = 0; i < object.issues.length; ++i) {
                            if (typeof object.issues[i] !== "object")
                                throw TypeError(".Ydb.Coordination.SessionResponse.CreateSemaphoreResult.issues: object expected");
                            message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateSemaphoreResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.CreateSemaphoreResult} message CreateSemaphoreResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateSemaphoreResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.issues = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                    if (message.issues && message.issues.length) {
                        object.issues = [];
                        for (var j = 0; j < message.issues.length; ++j)
                            object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this CreateSemaphoreResult to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.CreateSemaphoreResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateSemaphoreResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateSemaphoreResult;
            })();

            SessionResponse.UpdateSemaphoreResult = (function() {

                /**
                 * Properties of an UpdateSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface IUpdateSemaphoreResult
                 * @property {number|Long|null} [reqId] UpdateSemaphoreResult reqId
                 * @property {Ydb.StatusIds.StatusCode|null} [status] UpdateSemaphoreResult status
                 * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] UpdateSemaphoreResult issues
                 */

                /**
                 * Constructs a new UpdateSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc The result of semaphore update
                 * @implements IUpdateSemaphoreResult
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.IUpdateSemaphoreResult=} [properties] Properties to set
                 */
                function UpdateSemaphoreResult(properties) {
                    this.issues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateSemaphoreResult reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @instance
                 */
                UpdateSemaphoreResult.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * UpdateSemaphoreResult status.
                 * @member {Ydb.StatusIds.StatusCode} status
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @instance
                 */
                UpdateSemaphoreResult.prototype.status = 0;

                /**
                 * UpdateSemaphoreResult issues.
                 * @member {Array.<Ydb.Issue.IIssueMessage>} issues
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @instance
                 */
                UpdateSemaphoreResult.prototype.issues = $util.emptyArray;

                /**
                 * Creates a new UpdateSemaphoreResult instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IUpdateSemaphoreResult=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.UpdateSemaphoreResult} UpdateSemaphoreResult instance
                 */
                UpdateSemaphoreResult.create = function create(properties) {
                    return new UpdateSemaphoreResult(properties);
                };

                /**
                 * Encodes the specified UpdateSemaphoreResult message. Does not implicitly {@link Ydb.Coordination.SessionResponse.UpdateSemaphoreResult.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IUpdateSemaphoreResult} message UpdateSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateSemaphoreResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    if (message.issues != null && message.issues.length)
                        for (var i = 0; i < message.issues.length; ++i)
                            $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified UpdateSemaphoreResult message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.UpdateSemaphoreResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IUpdateSemaphoreResult} message UpdateSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateSemaphoreResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpdateSemaphoreResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.UpdateSemaphoreResult} UpdateSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateSemaphoreResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.UpdateSemaphoreResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.status = reader.int32();
                            break;
                        case 3:
                            if (!(message.issues && message.issues.length))
                                message.issues = [];
                            message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UpdateSemaphoreResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.UpdateSemaphoreResult} UpdateSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateSemaphoreResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpdateSemaphoreResult message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateSemaphoreResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 400000:
                        case 400010:
                        case 400020:
                        case 400030:
                        case 400040:
                        case 400050:
                        case 400060:
                        case 400070:
                        case 400080:
                        case 400090:
                        case 400100:
                        case 400120:
                        case 400130:
                        case 400140:
                        case 400150:
                        case 400160:
                        case 400170:
                        case 400180:
                        case 400190:
                            break;
                        }
                    if (message.issues != null && message.hasOwnProperty("issues")) {
                        if (!Array.isArray(message.issues))
                            return "issues: array expected";
                        for (var i = 0; i < message.issues.length; ++i) {
                            var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                            if (error)
                                return "issues." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an UpdateSemaphoreResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.UpdateSemaphoreResult} UpdateSemaphoreResult
                 */
                UpdateSemaphoreResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.UpdateSemaphoreResult)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.UpdateSemaphoreResult();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    switch (object.status) {
                    case "STATUS_CODE_UNSPECIFIED":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESS":
                    case 400000:
                        message.status = 400000;
                        break;
                    case "BAD_REQUEST":
                    case 400010:
                        message.status = 400010;
                        break;
                    case "UNAUTHORIZED":
                    case 400020:
                        message.status = 400020;
                        break;
                    case "INTERNAL_ERROR":
                    case 400030:
                        message.status = 400030;
                        break;
                    case "ABORTED":
                    case 400040:
                        message.status = 400040;
                        break;
                    case "UNAVAILABLE":
                    case 400050:
                        message.status = 400050;
                        break;
                    case "OVERLOADED":
                    case 400060:
                        message.status = 400060;
                        break;
                    case "SCHEME_ERROR":
                    case 400070:
                        message.status = 400070;
                        break;
                    case "GENERIC_ERROR":
                    case 400080:
                        message.status = 400080;
                        break;
                    case "TIMEOUT":
                    case 400090:
                        message.status = 400090;
                        break;
                    case "BAD_SESSION":
                    case 400100:
                        message.status = 400100;
                        break;
                    case "PRECONDITION_FAILED":
                    case 400120:
                        message.status = 400120;
                        break;
                    case "ALREADY_EXISTS":
                    case 400130:
                        message.status = 400130;
                        break;
                    case "NOT_FOUND":
                    case 400140:
                        message.status = 400140;
                        break;
                    case "SESSION_EXPIRED":
                    case 400150:
                        message.status = 400150;
                        break;
                    case "CANCELLED":
                    case 400160:
                        message.status = 400160;
                        break;
                    case "UNDETERMINED":
                    case 400170:
                        message.status = 400170;
                        break;
                    case "UNSUPPORTED":
                    case 400180:
                        message.status = 400180;
                        break;
                    case "SESSION_BUSY":
                    case 400190:
                        message.status = 400190;
                        break;
                    }
                    if (object.issues) {
                        if (!Array.isArray(object.issues))
                            throw TypeError(".Ydb.Coordination.SessionResponse.UpdateSemaphoreResult.issues: array expected");
                        message.issues = [];
                        for (var i = 0; i < object.issues.length; ++i) {
                            if (typeof object.issues[i] !== "object")
                                throw TypeError(".Ydb.Coordination.SessionResponse.UpdateSemaphoreResult.issues: object expected");
                            message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateSemaphoreResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.UpdateSemaphoreResult} message UpdateSemaphoreResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateSemaphoreResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.issues = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                    if (message.issues && message.issues.length) {
                        object.issues = [];
                        for (var j = 0; j < message.issues.length; ++j)
                            object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this UpdateSemaphoreResult to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.UpdateSemaphoreResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateSemaphoreResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateSemaphoreResult;
            })();

            SessionResponse.DeleteSemaphoreResult = (function() {

                /**
                 * Properties of a DeleteSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @interface IDeleteSemaphoreResult
                 * @property {number|Long|null} [reqId] DeleteSemaphoreResult reqId
                 * @property {Ydb.StatusIds.StatusCode|null} [status] DeleteSemaphoreResult status
                 * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] DeleteSemaphoreResult issues
                 */

                /**
                 * Constructs a new DeleteSemaphoreResult.
                 * @memberof Ydb.Coordination.SessionResponse
                 * @classdesc The result of semaphore deletion
                 * @implements IDeleteSemaphoreResult
                 * @constructor
                 * @param {Ydb.Coordination.SessionResponse.IDeleteSemaphoreResult=} [properties] Properties to set
                 */
                function DeleteSemaphoreResult(properties) {
                    this.issues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteSemaphoreResult reqId.
                 * @member {number|Long} reqId
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @instance
                 */
                DeleteSemaphoreResult.prototype.reqId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * DeleteSemaphoreResult status.
                 * @member {Ydb.StatusIds.StatusCode} status
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @instance
                 */
                DeleteSemaphoreResult.prototype.status = 0;

                /**
                 * DeleteSemaphoreResult issues.
                 * @member {Array.<Ydb.Issue.IIssueMessage>} issues
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @instance
                 */
                DeleteSemaphoreResult.prototype.issues = $util.emptyArray;

                /**
                 * Creates a new DeleteSemaphoreResult instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IDeleteSemaphoreResult=} [properties] Properties to set
                 * @returns {Ydb.Coordination.SessionResponse.DeleteSemaphoreResult} DeleteSemaphoreResult instance
                 */
                DeleteSemaphoreResult.create = function create(properties) {
                    return new DeleteSemaphoreResult(properties);
                };

                /**
                 * Encodes the specified DeleteSemaphoreResult message. Does not implicitly {@link Ydb.Coordination.SessionResponse.DeleteSemaphoreResult.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IDeleteSemaphoreResult} message DeleteSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteSemaphoreResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.reqId);
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    if (message.issues != null && message.issues.length)
                        for (var i = 0; i < message.issues.length; ++i)
                            $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified DeleteSemaphoreResult message, length delimited. Does not implicitly {@link Ydb.Coordination.SessionResponse.DeleteSemaphoreResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.IDeleteSemaphoreResult} message DeleteSemaphoreResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteSemaphoreResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeleteSemaphoreResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Coordination.SessionResponse.DeleteSemaphoreResult} DeleteSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteSemaphoreResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.SessionResponse.DeleteSemaphoreResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.reqId = reader.uint64();
                            break;
                        case 2:
                            message.status = reader.int32();
                            break;
                        case 3:
                            if (!(message.issues && message.issues.length))
                                message.issues = [];
                            message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeleteSemaphoreResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Coordination.SessionResponse.DeleteSemaphoreResult} DeleteSemaphoreResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteSemaphoreResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DeleteSemaphoreResult message.
                 * @function verify
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteSemaphoreResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (!$util.isInteger(message.reqId) && !(message.reqId && $util.isInteger(message.reqId.low) && $util.isInteger(message.reqId.high)))
                            return "reqId: integer|Long expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 400000:
                        case 400010:
                        case 400020:
                        case 400030:
                        case 400040:
                        case 400050:
                        case 400060:
                        case 400070:
                        case 400080:
                        case 400090:
                        case 400100:
                        case 400120:
                        case 400130:
                        case 400140:
                        case 400150:
                        case 400160:
                        case 400170:
                        case 400180:
                        case 400190:
                            break;
                        }
                    if (message.issues != null && message.hasOwnProperty("issues")) {
                        if (!Array.isArray(message.issues))
                            return "issues: array expected";
                        for (var i = 0; i < message.issues.length; ++i) {
                            var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                            if (error)
                                return "issues." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a DeleteSemaphoreResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Coordination.SessionResponse.DeleteSemaphoreResult} DeleteSemaphoreResult
                 */
                DeleteSemaphoreResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Coordination.SessionResponse.DeleteSemaphoreResult)
                        return object;
                    var message = new $root.Ydb.Coordination.SessionResponse.DeleteSemaphoreResult();
                    if (object.reqId != null)
                        if ($util.Long)
                            (message.reqId = $util.Long.fromValue(object.reqId)).unsigned = true;
                        else if (typeof object.reqId === "string")
                            message.reqId = parseInt(object.reqId, 10);
                        else if (typeof object.reqId === "number")
                            message.reqId = object.reqId;
                        else if (typeof object.reqId === "object")
                            message.reqId = new $util.LongBits(object.reqId.low >>> 0, object.reqId.high >>> 0).toNumber(true);
                    switch (object.status) {
                    case "STATUS_CODE_UNSPECIFIED":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESS":
                    case 400000:
                        message.status = 400000;
                        break;
                    case "BAD_REQUEST":
                    case 400010:
                        message.status = 400010;
                        break;
                    case "UNAUTHORIZED":
                    case 400020:
                        message.status = 400020;
                        break;
                    case "INTERNAL_ERROR":
                    case 400030:
                        message.status = 400030;
                        break;
                    case "ABORTED":
                    case 400040:
                        message.status = 400040;
                        break;
                    case "UNAVAILABLE":
                    case 400050:
                        message.status = 400050;
                        break;
                    case "OVERLOADED":
                    case 400060:
                        message.status = 400060;
                        break;
                    case "SCHEME_ERROR":
                    case 400070:
                        message.status = 400070;
                        break;
                    case "GENERIC_ERROR":
                    case 400080:
                        message.status = 400080;
                        break;
                    case "TIMEOUT":
                    case 400090:
                        message.status = 400090;
                        break;
                    case "BAD_SESSION":
                    case 400100:
                        message.status = 400100;
                        break;
                    case "PRECONDITION_FAILED":
                    case 400120:
                        message.status = 400120;
                        break;
                    case "ALREADY_EXISTS":
                    case 400130:
                        message.status = 400130;
                        break;
                    case "NOT_FOUND":
                    case 400140:
                        message.status = 400140;
                        break;
                    case "SESSION_EXPIRED":
                    case 400150:
                        message.status = 400150;
                        break;
                    case "CANCELLED":
                    case 400160:
                        message.status = 400160;
                        break;
                    case "UNDETERMINED":
                    case 400170:
                        message.status = 400170;
                        break;
                    case "UNSUPPORTED":
                    case 400180:
                        message.status = 400180;
                        break;
                    case "SESSION_BUSY":
                    case 400190:
                        message.status = 400190;
                        break;
                    }
                    if (object.issues) {
                        if (!Array.isArray(object.issues))
                            throw TypeError(".Ydb.Coordination.SessionResponse.DeleteSemaphoreResult.issues: array expected");
                        message.issues = [];
                        for (var i = 0; i < object.issues.length; ++i) {
                            if (typeof object.issues[i] !== "object")
                                throw TypeError(".Ydb.Coordination.SessionResponse.DeleteSemaphoreResult.issues: object expected");
                            message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteSemaphoreResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @static
                 * @param {Ydb.Coordination.SessionResponse.DeleteSemaphoreResult} message DeleteSemaphoreResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteSemaphoreResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.issues = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reqId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reqId = options.longs === String ? "0" : 0;
                        object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    }
                    if (message.reqId != null && message.hasOwnProperty("reqId"))
                        if (typeof message.reqId === "number")
                            object.reqId = options.longs === String ? String(message.reqId) : message.reqId;
                        else
                            object.reqId = options.longs === String ? $util.Long.prototype.toString.call(message.reqId) : options.longs === Number ? new $util.LongBits(message.reqId.low >>> 0, message.reqId.high >>> 0).toNumber(true) : message.reqId;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                    if (message.issues && message.issues.length) {
                        object.issues = [];
                        for (var j = 0; j < message.issues.length; ++j)
                            object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this DeleteSemaphoreResult to JSON.
                 * @function toJSON
                 * @memberof Ydb.Coordination.SessionResponse.DeleteSemaphoreResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteSemaphoreResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteSemaphoreResult;
            })();

            return SessionResponse;
        })();

        Coordination.CreateNodeRequest = (function() {

            /**
             * Properties of a CreateNodeRequest.
             * @memberof Ydb.Coordination
             * @interface ICreateNodeRequest
             * @property {string|null} [path] CreateNodeRequest path
             * @property {Ydb.Coordination.IConfig|null} [config] CreateNodeRequest config
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CreateNodeRequest operationParams
             */

            /**
             * Constructs a new CreateNodeRequest.
             * @memberof Ydb.Coordination
             * @classdesc Represents a CreateNodeRequest.
             * @implements ICreateNodeRequest
             * @constructor
             * @param {Ydb.Coordination.ICreateNodeRequest=} [properties] Properties to set
             */
            function CreateNodeRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateNodeRequest path.
             * @member {string} path
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @instance
             */
            CreateNodeRequest.prototype.path = "";

            /**
             * CreateNodeRequest config.
             * @member {Ydb.Coordination.IConfig|null|undefined} config
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @instance
             */
            CreateNodeRequest.prototype.config = null;

            /**
             * CreateNodeRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @instance
             */
            CreateNodeRequest.prototype.operationParams = null;

            /**
             * Creates a new CreateNodeRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @static
             * @param {Ydb.Coordination.ICreateNodeRequest=} [properties] Properties to set
             * @returns {Ydb.Coordination.CreateNodeRequest} CreateNodeRequest instance
             */
            CreateNodeRequest.create = function create(properties) {
                return new CreateNodeRequest(properties);
            };

            /**
             * Encodes the specified CreateNodeRequest message. Does not implicitly {@link Ydb.Coordination.CreateNodeRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @static
             * @param {Ydb.Coordination.ICreateNodeRequest} message CreateNodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateNodeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.config != null && message.hasOwnProperty("config"))
                    $root.Ydb.Coordination.Config.encode(message.config, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateNodeRequest message, length delimited. Does not implicitly {@link Ydb.Coordination.CreateNodeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @static
             * @param {Ydb.Coordination.ICreateNodeRequest} message CreateNodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateNodeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateNodeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.CreateNodeRequest} CreateNodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateNodeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.CreateNodeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.config = $root.Ydb.Coordination.Config.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateNodeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.CreateNodeRequest} CreateNodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateNodeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateNodeRequest message.
             * @function verify
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateNodeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.config != null && message.hasOwnProperty("config")) {
                    var error = $root.Ydb.Coordination.Config.verify(message.config);
                    if (error)
                        return "config." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a CreateNodeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.CreateNodeRequest} CreateNodeRequest
             */
            CreateNodeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.CreateNodeRequest)
                    return object;
                var message = new $root.Ydb.Coordination.CreateNodeRequest();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.config != null) {
                    if (typeof object.config !== "object")
                        throw TypeError(".Ydb.Coordination.CreateNodeRequest.config: object expected");
                    message.config = $root.Ydb.Coordination.Config.fromObject(object.config);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Coordination.CreateNodeRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateNodeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @static
             * @param {Ydb.Coordination.CreateNodeRequest} message CreateNodeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateNodeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.config = null;
                    object.operationParams = null;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.config != null && message.hasOwnProperty("config"))
                    object.config = $root.Ydb.Coordination.Config.toObject(message.config, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this CreateNodeRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.CreateNodeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateNodeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateNodeRequest;
        })();

        Coordination.CreateNodeResponse = (function() {

            /**
             * Properties of a CreateNodeResponse.
             * @memberof Ydb.Coordination
             * @interface ICreateNodeResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CreateNodeResponse operation
             */

            /**
             * Constructs a new CreateNodeResponse.
             * @memberof Ydb.Coordination
             * @classdesc Represents a CreateNodeResponse.
             * @implements ICreateNodeResponse
             * @constructor
             * @param {Ydb.Coordination.ICreateNodeResponse=} [properties] Properties to set
             */
            function CreateNodeResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateNodeResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @instance
             */
            CreateNodeResponse.prototype.operation = null;

            /**
             * Creates a new CreateNodeResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @static
             * @param {Ydb.Coordination.ICreateNodeResponse=} [properties] Properties to set
             * @returns {Ydb.Coordination.CreateNodeResponse} CreateNodeResponse instance
             */
            CreateNodeResponse.create = function create(properties) {
                return new CreateNodeResponse(properties);
            };

            /**
             * Encodes the specified CreateNodeResponse message. Does not implicitly {@link Ydb.Coordination.CreateNodeResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @static
             * @param {Ydb.Coordination.ICreateNodeResponse} message CreateNodeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateNodeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateNodeResponse message, length delimited. Does not implicitly {@link Ydb.Coordination.CreateNodeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @static
             * @param {Ydb.Coordination.ICreateNodeResponse} message CreateNodeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateNodeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateNodeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.CreateNodeResponse} CreateNodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateNodeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.CreateNodeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateNodeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.CreateNodeResponse} CreateNodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateNodeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateNodeResponse message.
             * @function verify
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateNodeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CreateNodeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.CreateNodeResponse} CreateNodeResponse
             */
            CreateNodeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.CreateNodeResponse)
                    return object;
                var message = new $root.Ydb.Coordination.CreateNodeResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Coordination.CreateNodeResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateNodeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @static
             * @param {Ydb.Coordination.CreateNodeResponse} message CreateNodeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateNodeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CreateNodeResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.CreateNodeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateNodeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateNodeResponse;
        })();

        Coordination.AlterNodeRequest = (function() {

            /**
             * Properties of an AlterNodeRequest.
             * @memberof Ydb.Coordination
             * @interface IAlterNodeRequest
             * @property {string|null} [path] AlterNodeRequest path
             * @property {Ydb.Coordination.IConfig|null} [config] AlterNodeRequest config
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] AlterNodeRequest operationParams
             */

            /**
             * Constructs a new AlterNodeRequest.
             * @memberof Ydb.Coordination
             * @classdesc Represents an AlterNodeRequest.
             * @implements IAlterNodeRequest
             * @constructor
             * @param {Ydb.Coordination.IAlterNodeRequest=} [properties] Properties to set
             */
            function AlterNodeRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterNodeRequest path.
             * @member {string} path
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @instance
             */
            AlterNodeRequest.prototype.path = "";

            /**
             * AlterNodeRequest config.
             * @member {Ydb.Coordination.IConfig|null|undefined} config
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @instance
             */
            AlterNodeRequest.prototype.config = null;

            /**
             * AlterNodeRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @instance
             */
            AlterNodeRequest.prototype.operationParams = null;

            /**
             * Creates a new AlterNodeRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @static
             * @param {Ydb.Coordination.IAlterNodeRequest=} [properties] Properties to set
             * @returns {Ydb.Coordination.AlterNodeRequest} AlterNodeRequest instance
             */
            AlterNodeRequest.create = function create(properties) {
                return new AlterNodeRequest(properties);
            };

            /**
             * Encodes the specified AlterNodeRequest message. Does not implicitly {@link Ydb.Coordination.AlterNodeRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @static
             * @param {Ydb.Coordination.IAlterNodeRequest} message AlterNodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterNodeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.config != null && message.hasOwnProperty("config"))
                    $root.Ydb.Coordination.Config.encode(message.config, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlterNodeRequest message, length delimited. Does not implicitly {@link Ydb.Coordination.AlterNodeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @static
             * @param {Ydb.Coordination.IAlterNodeRequest} message AlterNodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterNodeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterNodeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.AlterNodeRequest} AlterNodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterNodeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.AlterNodeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.config = $root.Ydb.Coordination.Config.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterNodeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.AlterNodeRequest} AlterNodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterNodeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterNodeRequest message.
             * @function verify
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterNodeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.config != null && message.hasOwnProperty("config")) {
                    var error = $root.Ydb.Coordination.Config.verify(message.config);
                    if (error)
                        return "config." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates an AlterNodeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.AlterNodeRequest} AlterNodeRequest
             */
            AlterNodeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.AlterNodeRequest)
                    return object;
                var message = new $root.Ydb.Coordination.AlterNodeRequest();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.config != null) {
                    if (typeof object.config !== "object")
                        throw TypeError(".Ydb.Coordination.AlterNodeRequest.config: object expected");
                    message.config = $root.Ydb.Coordination.Config.fromObject(object.config);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Coordination.AlterNodeRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlterNodeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @static
             * @param {Ydb.Coordination.AlterNodeRequest} message AlterNodeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterNodeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.config = null;
                    object.operationParams = null;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.config != null && message.hasOwnProperty("config"))
                    object.config = $root.Ydb.Coordination.Config.toObject(message.config, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this AlterNodeRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.AlterNodeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterNodeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterNodeRequest;
        })();

        Coordination.AlterNodeResponse = (function() {

            /**
             * Properties of an AlterNodeResponse.
             * @memberof Ydb.Coordination
             * @interface IAlterNodeResponse
             * @property {Ydb.Operations.IOperation|null} [operation] AlterNodeResponse operation
             */

            /**
             * Constructs a new AlterNodeResponse.
             * @memberof Ydb.Coordination
             * @classdesc Represents an AlterNodeResponse.
             * @implements IAlterNodeResponse
             * @constructor
             * @param {Ydb.Coordination.IAlterNodeResponse=} [properties] Properties to set
             */
            function AlterNodeResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterNodeResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @instance
             */
            AlterNodeResponse.prototype.operation = null;

            /**
             * Creates a new AlterNodeResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @static
             * @param {Ydb.Coordination.IAlterNodeResponse=} [properties] Properties to set
             * @returns {Ydb.Coordination.AlterNodeResponse} AlterNodeResponse instance
             */
            AlterNodeResponse.create = function create(properties) {
                return new AlterNodeResponse(properties);
            };

            /**
             * Encodes the specified AlterNodeResponse message. Does not implicitly {@link Ydb.Coordination.AlterNodeResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @static
             * @param {Ydb.Coordination.IAlterNodeResponse} message AlterNodeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterNodeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlterNodeResponse message, length delimited. Does not implicitly {@link Ydb.Coordination.AlterNodeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @static
             * @param {Ydb.Coordination.IAlterNodeResponse} message AlterNodeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterNodeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterNodeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.AlterNodeResponse} AlterNodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterNodeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.AlterNodeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterNodeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.AlterNodeResponse} AlterNodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterNodeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterNodeResponse message.
             * @function verify
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterNodeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an AlterNodeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.AlterNodeResponse} AlterNodeResponse
             */
            AlterNodeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.AlterNodeResponse)
                    return object;
                var message = new $root.Ydb.Coordination.AlterNodeResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Coordination.AlterNodeResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlterNodeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @static
             * @param {Ydb.Coordination.AlterNodeResponse} message AlterNodeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterNodeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this AlterNodeResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.AlterNodeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterNodeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterNodeResponse;
        })();

        Coordination.DropNodeRequest = (function() {

            /**
             * Properties of a DropNodeRequest.
             * @memberof Ydb.Coordination
             * @interface IDropNodeRequest
             * @property {string|null} [path] DropNodeRequest path
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DropNodeRequest operationParams
             */

            /**
             * Constructs a new DropNodeRequest.
             * @memberof Ydb.Coordination
             * @classdesc Represents a DropNodeRequest.
             * @implements IDropNodeRequest
             * @constructor
             * @param {Ydb.Coordination.IDropNodeRequest=} [properties] Properties to set
             */
            function DropNodeRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DropNodeRequest path.
             * @member {string} path
             * @memberof Ydb.Coordination.DropNodeRequest
             * @instance
             */
            DropNodeRequest.prototype.path = "";

            /**
             * DropNodeRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Coordination.DropNodeRequest
             * @instance
             */
            DropNodeRequest.prototype.operationParams = null;

            /**
             * Creates a new DropNodeRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.DropNodeRequest
             * @static
             * @param {Ydb.Coordination.IDropNodeRequest=} [properties] Properties to set
             * @returns {Ydb.Coordination.DropNodeRequest} DropNodeRequest instance
             */
            DropNodeRequest.create = function create(properties) {
                return new DropNodeRequest(properties);
            };

            /**
             * Encodes the specified DropNodeRequest message. Does not implicitly {@link Ydb.Coordination.DropNodeRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.DropNodeRequest
             * @static
             * @param {Ydb.Coordination.IDropNodeRequest} message DropNodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropNodeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DropNodeRequest message, length delimited. Does not implicitly {@link Ydb.Coordination.DropNodeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.DropNodeRequest
             * @static
             * @param {Ydb.Coordination.IDropNodeRequest} message DropNodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropNodeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropNodeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.DropNodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.DropNodeRequest} DropNodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropNodeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.DropNodeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropNodeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.DropNodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.DropNodeRequest} DropNodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropNodeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropNodeRequest message.
             * @function verify
             * @memberof Ydb.Coordination.DropNodeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropNodeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a DropNodeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.DropNodeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.DropNodeRequest} DropNodeRequest
             */
            DropNodeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.DropNodeRequest)
                    return object;
                var message = new $root.Ydb.Coordination.DropNodeRequest();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Coordination.DropNodeRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DropNodeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.DropNodeRequest
             * @static
             * @param {Ydb.Coordination.DropNodeRequest} message DropNodeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropNodeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.operationParams = null;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this DropNodeRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.DropNodeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropNodeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropNodeRequest;
        })();

        Coordination.DropNodeResponse = (function() {

            /**
             * Properties of a DropNodeResponse.
             * @memberof Ydb.Coordination
             * @interface IDropNodeResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DropNodeResponse operation
             */

            /**
             * Constructs a new DropNodeResponse.
             * @memberof Ydb.Coordination
             * @classdesc Represents a DropNodeResponse.
             * @implements IDropNodeResponse
             * @constructor
             * @param {Ydb.Coordination.IDropNodeResponse=} [properties] Properties to set
             */
            function DropNodeResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DropNodeResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Coordination.DropNodeResponse
             * @instance
             */
            DropNodeResponse.prototype.operation = null;

            /**
             * Creates a new DropNodeResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.DropNodeResponse
             * @static
             * @param {Ydb.Coordination.IDropNodeResponse=} [properties] Properties to set
             * @returns {Ydb.Coordination.DropNodeResponse} DropNodeResponse instance
             */
            DropNodeResponse.create = function create(properties) {
                return new DropNodeResponse(properties);
            };

            /**
             * Encodes the specified DropNodeResponse message. Does not implicitly {@link Ydb.Coordination.DropNodeResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.DropNodeResponse
             * @static
             * @param {Ydb.Coordination.IDropNodeResponse} message DropNodeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropNodeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DropNodeResponse message, length delimited. Does not implicitly {@link Ydb.Coordination.DropNodeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.DropNodeResponse
             * @static
             * @param {Ydb.Coordination.IDropNodeResponse} message DropNodeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropNodeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropNodeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.DropNodeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.DropNodeResponse} DropNodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropNodeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.DropNodeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropNodeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.DropNodeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.DropNodeResponse} DropNodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropNodeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropNodeResponse message.
             * @function verify
             * @memberof Ydb.Coordination.DropNodeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropNodeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DropNodeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.DropNodeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.DropNodeResponse} DropNodeResponse
             */
            DropNodeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.DropNodeResponse)
                    return object;
                var message = new $root.Ydb.Coordination.DropNodeResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Coordination.DropNodeResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DropNodeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.DropNodeResponse
             * @static
             * @param {Ydb.Coordination.DropNodeResponse} message DropNodeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropNodeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DropNodeResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.DropNodeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropNodeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropNodeResponse;
        })();

        Coordination.DescribeNodeRequest = (function() {

            /**
             * Properties of a DescribeNodeRequest.
             * @memberof Ydb.Coordination
             * @interface IDescribeNodeRequest
             * @property {string|null} [path] DescribeNodeRequest path
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DescribeNodeRequest operationParams
             */

            /**
             * Constructs a new DescribeNodeRequest.
             * @memberof Ydb.Coordination
             * @classdesc Represents a DescribeNodeRequest.
             * @implements IDescribeNodeRequest
             * @constructor
             * @param {Ydb.Coordination.IDescribeNodeRequest=} [properties] Properties to set
             */
            function DescribeNodeRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeNodeRequest path.
             * @member {string} path
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @instance
             */
            DescribeNodeRequest.prototype.path = "";

            /**
             * DescribeNodeRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @instance
             */
            DescribeNodeRequest.prototype.operationParams = null;

            /**
             * Creates a new DescribeNodeRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @static
             * @param {Ydb.Coordination.IDescribeNodeRequest=} [properties] Properties to set
             * @returns {Ydb.Coordination.DescribeNodeRequest} DescribeNodeRequest instance
             */
            DescribeNodeRequest.create = function create(properties) {
                return new DescribeNodeRequest(properties);
            };

            /**
             * Encodes the specified DescribeNodeRequest message. Does not implicitly {@link Ydb.Coordination.DescribeNodeRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @static
             * @param {Ydb.Coordination.IDescribeNodeRequest} message DescribeNodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeNodeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeNodeRequest message, length delimited. Does not implicitly {@link Ydb.Coordination.DescribeNodeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @static
             * @param {Ydb.Coordination.IDescribeNodeRequest} message DescribeNodeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeNodeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeNodeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.DescribeNodeRequest} DescribeNodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeNodeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.DescribeNodeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeNodeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.DescribeNodeRequest} DescribeNodeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeNodeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeNodeRequest message.
             * @function verify
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeNodeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeNodeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.DescribeNodeRequest} DescribeNodeRequest
             */
            DescribeNodeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.DescribeNodeRequest)
                    return object;
                var message = new $root.Ydb.Coordination.DescribeNodeRequest();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Coordination.DescribeNodeRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeNodeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @static
             * @param {Ydb.Coordination.DescribeNodeRequest} message DescribeNodeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeNodeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.operationParams = null;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this DescribeNodeRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.DescribeNodeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeNodeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeNodeRequest;
        })();

        Coordination.DescribeNodeResponse = (function() {

            /**
             * Properties of a DescribeNodeResponse.
             * @memberof Ydb.Coordination
             * @interface IDescribeNodeResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DescribeNodeResponse operation
             */

            /**
             * Constructs a new DescribeNodeResponse.
             * @memberof Ydb.Coordination
             * @classdesc Represents a DescribeNodeResponse.
             * @implements IDescribeNodeResponse
             * @constructor
             * @param {Ydb.Coordination.IDescribeNodeResponse=} [properties] Properties to set
             */
            function DescribeNodeResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeNodeResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @instance
             */
            DescribeNodeResponse.prototype.operation = null;

            /**
             * Creates a new DescribeNodeResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @static
             * @param {Ydb.Coordination.IDescribeNodeResponse=} [properties] Properties to set
             * @returns {Ydb.Coordination.DescribeNodeResponse} DescribeNodeResponse instance
             */
            DescribeNodeResponse.create = function create(properties) {
                return new DescribeNodeResponse(properties);
            };

            /**
             * Encodes the specified DescribeNodeResponse message. Does not implicitly {@link Ydb.Coordination.DescribeNodeResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @static
             * @param {Ydb.Coordination.IDescribeNodeResponse} message DescribeNodeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeNodeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeNodeResponse message, length delimited. Does not implicitly {@link Ydb.Coordination.DescribeNodeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @static
             * @param {Ydb.Coordination.IDescribeNodeResponse} message DescribeNodeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeNodeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeNodeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.DescribeNodeResponse} DescribeNodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeNodeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.DescribeNodeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeNodeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.DescribeNodeResponse} DescribeNodeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeNodeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeNodeResponse message.
             * @function verify
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeNodeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeNodeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.DescribeNodeResponse} DescribeNodeResponse
             */
            DescribeNodeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.DescribeNodeResponse)
                    return object;
                var message = new $root.Ydb.Coordination.DescribeNodeResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Coordination.DescribeNodeResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeNodeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @static
             * @param {Ydb.Coordination.DescribeNodeResponse} message DescribeNodeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeNodeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DescribeNodeResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.DescribeNodeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeNodeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeNodeResponse;
        })();

        Coordination.DescribeNodeResult = (function() {

            /**
             * Properties of a DescribeNodeResult.
             * @memberof Ydb.Coordination
             * @interface IDescribeNodeResult
             * @property {Ydb.Scheme.IEntry|null} [self] DescribeNodeResult self
             * @property {Ydb.Coordination.IConfig|null} [config] DescribeNodeResult config
             */

            /**
             * Constructs a new DescribeNodeResult.
             * @memberof Ydb.Coordination
             * @classdesc Represents a DescribeNodeResult.
             * @implements IDescribeNodeResult
             * @constructor
             * @param {Ydb.Coordination.IDescribeNodeResult=} [properties] Properties to set
             */
            function DescribeNodeResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeNodeResult self.
             * @member {Ydb.Scheme.IEntry|null|undefined} self
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @instance
             */
            DescribeNodeResult.prototype.self = null;

            /**
             * DescribeNodeResult config.
             * @member {Ydb.Coordination.IConfig|null|undefined} config
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @instance
             */
            DescribeNodeResult.prototype.config = null;

            /**
             * Creates a new DescribeNodeResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @static
             * @param {Ydb.Coordination.IDescribeNodeResult=} [properties] Properties to set
             * @returns {Ydb.Coordination.DescribeNodeResult} DescribeNodeResult instance
             */
            DescribeNodeResult.create = function create(properties) {
                return new DescribeNodeResult(properties);
            };

            /**
             * Encodes the specified DescribeNodeResult message. Does not implicitly {@link Ydb.Coordination.DescribeNodeResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @static
             * @param {Ydb.Coordination.IDescribeNodeResult} message DescribeNodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeNodeResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.self != null && message.hasOwnProperty("self"))
                    $root.Ydb.Scheme.Entry.encode(message.self, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.config != null && message.hasOwnProperty("config"))
                    $root.Ydb.Coordination.Config.encode(message.config, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeNodeResult message, length delimited. Does not implicitly {@link Ydb.Coordination.DescribeNodeResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @static
             * @param {Ydb.Coordination.IDescribeNodeResult} message DescribeNodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeNodeResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeNodeResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Coordination.DescribeNodeResult} DescribeNodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeNodeResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Coordination.DescribeNodeResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.self = $root.Ydb.Scheme.Entry.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.config = $root.Ydb.Coordination.Config.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeNodeResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Coordination.DescribeNodeResult} DescribeNodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeNodeResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeNodeResult message.
             * @function verify
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeNodeResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.self != null && message.hasOwnProperty("self")) {
                    var error = $root.Ydb.Scheme.Entry.verify(message.self);
                    if (error)
                        return "self." + error;
                }
                if (message.config != null && message.hasOwnProperty("config")) {
                    var error = $root.Ydb.Coordination.Config.verify(message.config);
                    if (error)
                        return "config." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeNodeResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Coordination.DescribeNodeResult} DescribeNodeResult
             */
            DescribeNodeResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Coordination.DescribeNodeResult)
                    return object;
                var message = new $root.Ydb.Coordination.DescribeNodeResult();
                if (object.self != null) {
                    if (typeof object.self !== "object")
                        throw TypeError(".Ydb.Coordination.DescribeNodeResult.self: object expected");
                    message.self = $root.Ydb.Scheme.Entry.fromObject(object.self);
                }
                if (object.config != null) {
                    if (typeof object.config !== "object")
                        throw TypeError(".Ydb.Coordination.DescribeNodeResult.config: object expected");
                    message.config = $root.Ydb.Coordination.Config.fromObject(object.config);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeNodeResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @static
             * @param {Ydb.Coordination.DescribeNodeResult} message DescribeNodeResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeNodeResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.self = null;
                    object.config = null;
                }
                if (message.self != null && message.hasOwnProperty("self"))
                    object.self = $root.Ydb.Scheme.Entry.toObject(message.self, options);
                if (message.config != null && message.hasOwnProperty("config"))
                    object.config = $root.Ydb.Coordination.Config.toObject(message.config, options);
                return object;
            };

            /**
             * Converts this DescribeNodeResult to JSON.
             * @function toJSON
             * @memberof Ydb.Coordination.DescribeNodeResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeNodeResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeNodeResult;
        })();

        return Coordination;
    })();

    Ydb.Scheme = (function() {

        /**
         * Namespace Scheme.
         * @memberof Ydb
         * @namespace
         */
        var Scheme = {};

        Scheme.MakeDirectoryRequest = (function() {

            /**
             * Properties of a MakeDirectoryRequest.
             * @memberof Ydb.Scheme
             * @interface IMakeDirectoryRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] MakeDirectoryRequest operationParams
             * @property {string|null} [path] MakeDirectoryRequest path
             */

            /**
             * Constructs a new MakeDirectoryRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a MakeDirectoryRequest.
             * @implements IMakeDirectoryRequest
             * @constructor
             * @param {Ydb.Scheme.IMakeDirectoryRequest=} [properties] Properties to set
             */
            function MakeDirectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MakeDirectoryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @instance
             */
            MakeDirectoryRequest.prototype.operationParams = null;

            /**
             * MakeDirectoryRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @instance
             */
            MakeDirectoryRequest.prototype.path = "";

            /**
             * Creates a new MakeDirectoryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.MakeDirectoryRequest} MakeDirectoryRequest instance
             */
            MakeDirectoryRequest.create = function create(properties) {
                return new MakeDirectoryRequest(properties);
            };

            /**
             * Encodes the specified MakeDirectoryRequest message. Does not implicitly {@link Ydb.Scheme.MakeDirectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryRequest} message MakeDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeDirectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified MakeDirectoryRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.MakeDirectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryRequest} message MakeDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeDirectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MakeDirectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.MakeDirectoryRequest} MakeDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeDirectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.MakeDirectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MakeDirectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.MakeDirectoryRequest} MakeDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeDirectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MakeDirectoryRequest message.
             * @function verify
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MakeDirectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a MakeDirectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.MakeDirectoryRequest} MakeDirectoryRequest
             */
            MakeDirectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.MakeDirectoryRequest)
                    return object;
                var message = new $root.Ydb.Scheme.MakeDirectoryRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.MakeDirectoryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a MakeDirectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Ydb.Scheme.MakeDirectoryRequest} message MakeDirectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MakeDirectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this MakeDirectoryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MakeDirectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MakeDirectoryRequest;
        })();

        Scheme.MakeDirectoryResponse = (function() {

            /**
             * Properties of a MakeDirectoryResponse.
             * @memberof Ydb.Scheme
             * @interface IMakeDirectoryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] MakeDirectoryResponse operation
             */

            /**
             * Constructs a new MakeDirectoryResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a MakeDirectoryResponse.
             * @implements IMakeDirectoryResponse
             * @constructor
             * @param {Ydb.Scheme.IMakeDirectoryResponse=} [properties] Properties to set
             */
            function MakeDirectoryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MakeDirectoryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @instance
             */
            MakeDirectoryResponse.prototype.operation = null;

            /**
             * Creates a new MakeDirectoryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.MakeDirectoryResponse} MakeDirectoryResponse instance
             */
            MakeDirectoryResponse.create = function create(properties) {
                return new MakeDirectoryResponse(properties);
            };

            /**
             * Encodes the specified MakeDirectoryResponse message. Does not implicitly {@link Ydb.Scheme.MakeDirectoryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryResponse} message MakeDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeDirectoryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MakeDirectoryResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.MakeDirectoryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryResponse} message MakeDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeDirectoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MakeDirectoryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.MakeDirectoryResponse} MakeDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeDirectoryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.MakeDirectoryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MakeDirectoryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.MakeDirectoryResponse} MakeDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeDirectoryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MakeDirectoryResponse message.
             * @function verify
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MakeDirectoryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a MakeDirectoryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.MakeDirectoryResponse} MakeDirectoryResponse
             */
            MakeDirectoryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.MakeDirectoryResponse)
                    return object;
                var message = new $root.Ydb.Scheme.MakeDirectoryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.MakeDirectoryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a MakeDirectoryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Ydb.Scheme.MakeDirectoryResponse} message MakeDirectoryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MakeDirectoryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this MakeDirectoryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MakeDirectoryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MakeDirectoryResponse;
        })();

        Scheme.RemoveDirectoryRequest = (function() {

            /**
             * Properties of a RemoveDirectoryRequest.
             * @memberof Ydb.Scheme
             * @interface IRemoveDirectoryRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] RemoveDirectoryRequest operationParams
             * @property {string|null} [path] RemoveDirectoryRequest path
             */

            /**
             * Constructs a new RemoveDirectoryRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a RemoveDirectoryRequest.
             * @implements IRemoveDirectoryRequest
             * @constructor
             * @param {Ydb.Scheme.IRemoveDirectoryRequest=} [properties] Properties to set
             */
            function RemoveDirectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RemoveDirectoryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @instance
             */
            RemoveDirectoryRequest.prototype.operationParams = null;

            /**
             * RemoveDirectoryRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @instance
             */
            RemoveDirectoryRequest.prototype.path = "";

            /**
             * Creates a new RemoveDirectoryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.RemoveDirectoryRequest} RemoveDirectoryRequest instance
             */
            RemoveDirectoryRequest.create = function create(properties) {
                return new RemoveDirectoryRequest(properties);
            };

            /**
             * Encodes the specified RemoveDirectoryRequest message. Does not implicitly {@link Ydb.Scheme.RemoveDirectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryRequest} message RemoveDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDirectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified RemoveDirectoryRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.RemoveDirectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryRequest} message RemoveDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDirectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RemoveDirectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.RemoveDirectoryRequest} RemoveDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDirectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.RemoveDirectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RemoveDirectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.RemoveDirectoryRequest} RemoveDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDirectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RemoveDirectoryRequest message.
             * @function verify
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoveDirectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a RemoveDirectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.RemoveDirectoryRequest} RemoveDirectoryRequest
             */
            RemoveDirectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.RemoveDirectoryRequest)
                    return object;
                var message = new $root.Ydb.Scheme.RemoveDirectoryRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.RemoveDirectoryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a RemoveDirectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Ydb.Scheme.RemoveDirectoryRequest} message RemoveDirectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoveDirectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this RemoveDirectoryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoveDirectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RemoveDirectoryRequest;
        })();

        Scheme.RemoveDirectoryResponse = (function() {

            /**
             * Properties of a RemoveDirectoryResponse.
             * @memberof Ydb.Scheme
             * @interface IRemoveDirectoryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] RemoveDirectoryResponse operation
             */

            /**
             * Constructs a new RemoveDirectoryResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a RemoveDirectoryResponse.
             * @implements IRemoveDirectoryResponse
             * @constructor
             * @param {Ydb.Scheme.IRemoveDirectoryResponse=} [properties] Properties to set
             */
            function RemoveDirectoryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RemoveDirectoryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @instance
             */
            RemoveDirectoryResponse.prototype.operation = null;

            /**
             * Creates a new RemoveDirectoryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.RemoveDirectoryResponse} RemoveDirectoryResponse instance
             */
            RemoveDirectoryResponse.create = function create(properties) {
                return new RemoveDirectoryResponse(properties);
            };

            /**
             * Encodes the specified RemoveDirectoryResponse message. Does not implicitly {@link Ydb.Scheme.RemoveDirectoryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryResponse} message RemoveDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDirectoryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RemoveDirectoryResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.RemoveDirectoryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryResponse} message RemoveDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDirectoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RemoveDirectoryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.RemoveDirectoryResponse} RemoveDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDirectoryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.RemoveDirectoryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RemoveDirectoryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.RemoveDirectoryResponse} RemoveDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDirectoryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RemoveDirectoryResponse message.
             * @function verify
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoveDirectoryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a RemoveDirectoryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.RemoveDirectoryResponse} RemoveDirectoryResponse
             */
            RemoveDirectoryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.RemoveDirectoryResponse)
                    return object;
                var message = new $root.Ydb.Scheme.RemoveDirectoryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.RemoveDirectoryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a RemoveDirectoryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Ydb.Scheme.RemoveDirectoryResponse} message RemoveDirectoryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoveDirectoryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this RemoveDirectoryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoveDirectoryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RemoveDirectoryResponse;
        })();

        Scheme.ListDirectoryRequest = (function() {

            /**
             * Properties of a ListDirectoryRequest.
             * @memberof Ydb.Scheme
             * @interface IListDirectoryRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ListDirectoryRequest operationParams
             * @property {string|null} [path] ListDirectoryRequest path
             */

            /**
             * Constructs a new ListDirectoryRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ListDirectoryRequest.
             * @implements IListDirectoryRequest
             * @constructor
             * @param {Ydb.Scheme.IListDirectoryRequest=} [properties] Properties to set
             */
            function ListDirectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListDirectoryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @instance
             */
            ListDirectoryRequest.prototype.operationParams = null;

            /**
             * ListDirectoryRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @instance
             */
            ListDirectoryRequest.prototype.path = "";

            /**
             * Creates a new ListDirectoryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IListDirectoryRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.ListDirectoryRequest} ListDirectoryRequest instance
             */
            ListDirectoryRequest.create = function create(properties) {
                return new ListDirectoryRequest(properties);
            };

            /**
             * Encodes the specified ListDirectoryRequest message. Does not implicitly {@link Ydb.Scheme.ListDirectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IListDirectoryRequest} message ListDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified ListDirectoryRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.ListDirectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IListDirectoryRequest} message ListDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListDirectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ListDirectoryRequest} ListDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ListDirectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListDirectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ListDirectoryRequest} ListDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListDirectoryRequest message.
             * @function verify
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListDirectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a ListDirectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ListDirectoryRequest} ListDirectoryRequest
             */
            ListDirectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ListDirectoryRequest)
                    return object;
                var message = new $root.Ydb.Scheme.ListDirectoryRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.ListDirectoryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a ListDirectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Ydb.Scheme.ListDirectoryRequest} message ListDirectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListDirectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this ListDirectoryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListDirectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListDirectoryRequest;
        })();

        Scheme.ListDirectoryResponse = (function() {

            /**
             * Properties of a ListDirectoryResponse.
             * @memberof Ydb.Scheme
             * @interface IListDirectoryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ListDirectoryResponse operation
             */

            /**
             * Constructs a new ListDirectoryResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ListDirectoryResponse.
             * @implements IListDirectoryResponse
             * @constructor
             * @param {Ydb.Scheme.IListDirectoryResponse=} [properties] Properties to set
             */
            function ListDirectoryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListDirectoryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @instance
             */
            ListDirectoryResponse.prototype.operation = null;

            /**
             * Creates a new ListDirectoryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IListDirectoryResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.ListDirectoryResponse} ListDirectoryResponse instance
             */
            ListDirectoryResponse.create = function create(properties) {
                return new ListDirectoryResponse(properties);
            };

            /**
             * Encodes the specified ListDirectoryResponse message. Does not implicitly {@link Ydb.Scheme.ListDirectoryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IListDirectoryResponse} message ListDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListDirectoryResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.ListDirectoryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IListDirectoryResponse} message ListDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListDirectoryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ListDirectoryResponse} ListDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ListDirectoryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListDirectoryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ListDirectoryResponse} ListDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListDirectoryResponse message.
             * @function verify
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListDirectoryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a ListDirectoryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ListDirectoryResponse} ListDirectoryResponse
             */
            ListDirectoryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ListDirectoryResponse)
                    return object;
                var message = new $root.Ydb.Scheme.ListDirectoryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.ListDirectoryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListDirectoryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Ydb.Scheme.ListDirectoryResponse} message ListDirectoryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListDirectoryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ListDirectoryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListDirectoryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListDirectoryResponse;
        })();

        Scheme.Permissions = (function() {

            /**
             * Properties of a Permissions.
             * @memberof Ydb.Scheme
             * @interface IPermissions
             * @property {string|null} [subject] Permissions subject
             * @property {Array.<string>|null} [permissionNames] Permissions permissionNames
             */

            /**
             * Constructs a new Permissions.
             * @memberof Ydb.Scheme
             * @classdesc Represents a Permissions.
             * @implements IPermissions
             * @constructor
             * @param {Ydb.Scheme.IPermissions=} [properties] Properties to set
             */
            function Permissions(properties) {
                this.permissionNames = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Permissions subject.
             * @member {string} subject
             * @memberof Ydb.Scheme.Permissions
             * @instance
             */
            Permissions.prototype.subject = "";

            /**
             * Permissions permissionNames.
             * @member {Array.<string>} permissionNames
             * @memberof Ydb.Scheme.Permissions
             * @instance
             */
            Permissions.prototype.permissionNames = $util.emptyArray;

            /**
             * Creates a new Permissions instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Ydb.Scheme.IPermissions=} [properties] Properties to set
             * @returns {Ydb.Scheme.Permissions} Permissions instance
             */
            Permissions.create = function create(properties) {
                return new Permissions(properties);
            };

            /**
             * Encodes the specified Permissions message. Does not implicitly {@link Ydb.Scheme.Permissions.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Ydb.Scheme.IPermissions} message Permissions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Permissions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && message.hasOwnProperty("subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                if (message.permissionNames != null && message.permissionNames.length)
                    for (var i = 0; i < message.permissionNames.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.permissionNames[i]);
                return writer;
            };

            /**
             * Encodes the specified Permissions message, length delimited. Does not implicitly {@link Ydb.Scheme.Permissions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Ydb.Scheme.IPermissions} message Permissions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Permissions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Permissions message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.Permissions} Permissions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Permissions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.Permissions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    case 2:
                        if (!(message.permissionNames && message.permissionNames.length))
                            message.permissionNames = [];
                        message.permissionNames.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Permissions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.Permissions} Permissions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Permissions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Permissions message.
             * @function verify
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Permissions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                if (message.permissionNames != null && message.hasOwnProperty("permissionNames")) {
                    if (!Array.isArray(message.permissionNames))
                        return "permissionNames: array expected";
                    for (var i = 0; i < message.permissionNames.length; ++i)
                        if (!$util.isString(message.permissionNames[i]))
                            return "permissionNames: string[] expected";
                }
                return null;
            };

            /**
             * Creates a Permissions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.Permissions} Permissions
             */
            Permissions.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.Permissions)
                    return object;
                var message = new $root.Ydb.Scheme.Permissions();
                if (object.subject != null)
                    message.subject = String(object.subject);
                if (object.permissionNames) {
                    if (!Array.isArray(object.permissionNames))
                        throw TypeError(".Ydb.Scheme.Permissions.permissionNames: array expected");
                    message.permissionNames = [];
                    for (var i = 0; i < object.permissionNames.length; ++i)
                        message.permissionNames[i] = String(object.permissionNames[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Permissions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Ydb.Scheme.Permissions} message Permissions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Permissions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.permissionNames = [];
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                if (message.permissionNames && message.permissionNames.length) {
                    object.permissionNames = [];
                    for (var j = 0; j < message.permissionNames.length; ++j)
                        object.permissionNames[j] = message.permissionNames[j];
                }
                return object;
            };

            /**
             * Converts this Permissions to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.Permissions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Permissions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Permissions;
        })();

        Scheme.Entry = (function() {

            /**
             * Properties of an Entry.
             * @memberof Ydb.Scheme
             * @interface IEntry
             * @property {string|null} [name] Entry name
             * @property {string|null} [owner] Entry owner
             * @property {Ydb.Scheme.Entry.Type|null} [type] Entry type
             * @property {Array.<Ydb.Scheme.IPermissions>|null} [effectivePermissions] Entry effectivePermissions
             * @property {Array.<Ydb.Scheme.IPermissions>|null} [permissions] Entry permissions
             */

            /**
             * Constructs a new Entry.
             * @memberof Ydb.Scheme
             * @classdesc Represents an Entry.
             * @implements IEntry
             * @constructor
             * @param {Ydb.Scheme.IEntry=} [properties] Properties to set
             */
            function Entry(properties) {
                this.effectivePermissions = [];
                this.permissions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Entry name.
             * @member {string} name
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.name = "";

            /**
             * Entry owner.
             * @member {string} owner
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.owner = "";

            /**
             * Entry type.
             * @member {Ydb.Scheme.Entry.Type} type
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.type = 0;

            /**
             * Entry effectivePermissions.
             * @member {Array.<Ydb.Scheme.IPermissions>} effectivePermissions
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.effectivePermissions = $util.emptyArray;

            /**
             * Entry permissions.
             * @member {Array.<Ydb.Scheme.IPermissions>} permissions
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.permissions = $util.emptyArray;

            /**
             * Creates a new Entry instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Ydb.Scheme.IEntry=} [properties] Properties to set
             * @returns {Ydb.Scheme.Entry} Entry instance
             */
            Entry.create = function create(properties) {
                return new Entry(properties);
            };

            /**
             * Encodes the specified Entry message. Does not implicitly {@link Ydb.Scheme.Entry.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Ydb.Scheme.IEntry} message Entry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.owner != null && message.hasOwnProperty("owner"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.owner);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.effectivePermissions != null && message.effectivePermissions.length)
                    for (var i = 0; i < message.effectivePermissions.length; ++i)
                        $root.Ydb.Scheme.Permissions.encode(message.effectivePermissions[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.permissions != null && message.permissions.length)
                    for (var i = 0; i < message.permissions.length; ++i)
                        $root.Ydb.Scheme.Permissions.encode(message.permissions[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Entry message, length delimited. Does not implicitly {@link Ydb.Scheme.Entry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Ydb.Scheme.IEntry} message Entry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Entry message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.Entry} Entry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.Entry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.owner = reader.string();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        if (!(message.effectivePermissions && message.effectivePermissions.length))
                            message.effectivePermissions = [];
                        message.effectivePermissions.push($root.Ydb.Scheme.Permissions.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.permissions && message.permissions.length))
                            message.permissions = [];
                        message.permissions.push($root.Ydb.Scheme.Permissions.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Entry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.Entry} Entry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Entry message.
             * @function verify
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Entry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isString(message.owner))
                        return "owner: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.effectivePermissions != null && message.hasOwnProperty("effectivePermissions")) {
                    if (!Array.isArray(message.effectivePermissions))
                        return "effectivePermissions: array expected";
                    for (var i = 0; i < message.effectivePermissions.length; ++i) {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.effectivePermissions[i]);
                        if (error)
                            return "effectivePermissions." + error;
                    }
                }
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    if (!Array.isArray(message.permissions))
                        return "permissions: array expected";
                    for (var i = 0; i < message.permissions.length; ++i) {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.permissions[i]);
                        if (error)
                            return "permissions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Entry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.Entry} Entry
             */
            Entry.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.Entry)
                    return object;
                var message = new $root.Ydb.Scheme.Entry();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.owner != null)
                    message.owner = String(object.owner);
                switch (object.type) {
                case "TYPE_UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "DIRECTORY":
                case 1:
                    message.type = 1;
                    break;
                case "TABLE":
                case 2:
                    message.type = 2;
                    break;
                case "PERS_QUEUE_GROUP":
                case 3:
                    message.type = 3;
                    break;
                case "DATABASE":
                case 4:
                    message.type = 4;
                    break;
                case "RTMR_VOLUME":
                case 5:
                    message.type = 5;
                    break;
                case "BLOCK_STORE_VOLUME":
                case 6:
                    message.type = 6;
                    break;
                case "COORDINATION_NODE":
                case 7:
                    message.type = 7;
                    break;
                }
                if (object.effectivePermissions) {
                    if (!Array.isArray(object.effectivePermissions))
                        throw TypeError(".Ydb.Scheme.Entry.effectivePermissions: array expected");
                    message.effectivePermissions = [];
                    for (var i = 0; i < object.effectivePermissions.length; ++i) {
                        if (typeof object.effectivePermissions[i] !== "object")
                            throw TypeError(".Ydb.Scheme.Entry.effectivePermissions: object expected");
                        message.effectivePermissions[i] = $root.Ydb.Scheme.Permissions.fromObject(object.effectivePermissions[i]);
                    }
                }
                if (object.permissions) {
                    if (!Array.isArray(object.permissions))
                        throw TypeError(".Ydb.Scheme.Entry.permissions: array expected");
                    message.permissions = [];
                    for (var i = 0; i < object.permissions.length; ++i) {
                        if (typeof object.permissions[i] !== "object")
                            throw TypeError(".Ydb.Scheme.Entry.permissions: object expected");
                        message.permissions[i] = $root.Ydb.Scheme.Permissions.fromObject(object.permissions[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Entry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Ydb.Scheme.Entry} message Entry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Entry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.effectivePermissions = [];
                    object.permissions = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.owner = "";
                    object.type = options.enums === String ? "TYPE_UNSPECIFIED" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    object.owner = message.owner;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.Ydb.Scheme.Entry.Type[message.type] : message.type;
                if (message.effectivePermissions && message.effectivePermissions.length) {
                    object.effectivePermissions = [];
                    for (var j = 0; j < message.effectivePermissions.length; ++j)
                        object.effectivePermissions[j] = $root.Ydb.Scheme.Permissions.toObject(message.effectivePermissions[j], options);
                }
                if (message.permissions && message.permissions.length) {
                    object.permissions = [];
                    for (var j = 0; j < message.permissions.length; ++j)
                        object.permissions[j] = $root.Ydb.Scheme.Permissions.toObject(message.permissions[j], options);
                }
                return object;
            };

            /**
             * Converts this Entry to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.Entry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Entry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name Ydb.Scheme.Entry.Type
             * @enum {string}
             * @property {number} TYPE_UNSPECIFIED=0 TYPE_UNSPECIFIED value
             * @property {number} DIRECTORY=1 DIRECTORY value
             * @property {number} TABLE=2 TABLE value
             * @property {number} PERS_QUEUE_GROUP=3 PERS_QUEUE_GROUP value
             * @property {number} DATABASE=4 DATABASE value
             * @property {number} RTMR_VOLUME=5 RTMR_VOLUME value
             * @property {number} BLOCK_STORE_VOLUME=6 BLOCK_STORE_VOLUME value
             * @property {number} COORDINATION_NODE=7 COORDINATION_NODE value
             */
            Entry.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "DIRECTORY"] = 1;
                values[valuesById[2] = "TABLE"] = 2;
                values[valuesById[3] = "PERS_QUEUE_GROUP"] = 3;
                values[valuesById[4] = "DATABASE"] = 4;
                values[valuesById[5] = "RTMR_VOLUME"] = 5;
                values[valuesById[6] = "BLOCK_STORE_VOLUME"] = 6;
                values[valuesById[7] = "COORDINATION_NODE"] = 7;
                return values;
            })();

            return Entry;
        })();

        Scheme.ListDirectoryResult = (function() {

            /**
             * Properties of a ListDirectoryResult.
             * @memberof Ydb.Scheme
             * @interface IListDirectoryResult
             * @property {Ydb.Scheme.IEntry|null} [self] ListDirectoryResult self
             * @property {Array.<Ydb.Scheme.IEntry>|null} [children] ListDirectoryResult children
             */

            /**
             * Constructs a new ListDirectoryResult.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ListDirectoryResult.
             * @implements IListDirectoryResult
             * @constructor
             * @param {Ydb.Scheme.IListDirectoryResult=} [properties] Properties to set
             */
            function ListDirectoryResult(properties) {
                this.children = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListDirectoryResult self.
             * @member {Ydb.Scheme.IEntry|null|undefined} self
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @instance
             */
            ListDirectoryResult.prototype.self = null;

            /**
             * ListDirectoryResult children.
             * @member {Array.<Ydb.Scheme.IEntry>} children
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @instance
             */
            ListDirectoryResult.prototype.children = $util.emptyArray;

            /**
             * Creates a new ListDirectoryResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Ydb.Scheme.IListDirectoryResult=} [properties] Properties to set
             * @returns {Ydb.Scheme.ListDirectoryResult} ListDirectoryResult instance
             */
            ListDirectoryResult.create = function create(properties) {
                return new ListDirectoryResult(properties);
            };

            /**
             * Encodes the specified ListDirectoryResult message. Does not implicitly {@link Ydb.Scheme.ListDirectoryResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Ydb.Scheme.IListDirectoryResult} message ListDirectoryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.self != null && message.hasOwnProperty("self"))
                    $root.Ydb.Scheme.Entry.encode(message.self, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.children != null && message.children.length)
                    for (var i = 0; i < message.children.length; ++i)
                        $root.Ydb.Scheme.Entry.encode(message.children[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListDirectoryResult message, length delimited. Does not implicitly {@link Ydb.Scheme.ListDirectoryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Ydb.Scheme.IListDirectoryResult} message ListDirectoryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListDirectoryResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ListDirectoryResult} ListDirectoryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ListDirectoryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.self = $root.Ydb.Scheme.Entry.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.children && message.children.length))
                            message.children = [];
                        message.children.push($root.Ydb.Scheme.Entry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListDirectoryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ListDirectoryResult} ListDirectoryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListDirectoryResult message.
             * @function verify
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListDirectoryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.self != null && message.hasOwnProperty("self")) {
                    var error = $root.Ydb.Scheme.Entry.verify(message.self);
                    if (error)
                        return "self." + error;
                }
                if (message.children != null && message.hasOwnProperty("children")) {
                    if (!Array.isArray(message.children))
                        return "children: array expected";
                    for (var i = 0; i < message.children.length; ++i) {
                        var error = $root.Ydb.Scheme.Entry.verify(message.children[i]);
                        if (error)
                            return "children." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListDirectoryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ListDirectoryResult} ListDirectoryResult
             */
            ListDirectoryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ListDirectoryResult)
                    return object;
                var message = new $root.Ydb.Scheme.ListDirectoryResult();
                if (object.self != null) {
                    if (typeof object.self !== "object")
                        throw TypeError(".Ydb.Scheme.ListDirectoryResult.self: object expected");
                    message.self = $root.Ydb.Scheme.Entry.fromObject(object.self);
                }
                if (object.children) {
                    if (!Array.isArray(object.children))
                        throw TypeError(".Ydb.Scheme.ListDirectoryResult.children: array expected");
                    message.children = [];
                    for (var i = 0; i < object.children.length; ++i) {
                        if (typeof object.children[i] !== "object")
                            throw TypeError(".Ydb.Scheme.ListDirectoryResult.children: object expected");
                        message.children[i] = $root.Ydb.Scheme.Entry.fromObject(object.children[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListDirectoryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Ydb.Scheme.ListDirectoryResult} message ListDirectoryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListDirectoryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.children = [];
                if (options.defaults)
                    object.self = null;
                if (message.self != null && message.hasOwnProperty("self"))
                    object.self = $root.Ydb.Scheme.Entry.toObject(message.self, options);
                if (message.children && message.children.length) {
                    object.children = [];
                    for (var j = 0; j < message.children.length; ++j)
                        object.children[j] = $root.Ydb.Scheme.Entry.toObject(message.children[j], options);
                }
                return object;
            };

            /**
             * Converts this ListDirectoryResult to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListDirectoryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListDirectoryResult;
        })();

        Scheme.DescribePathRequest = (function() {

            /**
             * Properties of a DescribePathRequest.
             * @memberof Ydb.Scheme
             * @interface IDescribePathRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DescribePathRequest operationParams
             * @property {string|null} [path] DescribePathRequest path
             */

            /**
             * Constructs a new DescribePathRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a DescribePathRequest.
             * @implements IDescribePathRequest
             * @constructor
             * @param {Ydb.Scheme.IDescribePathRequest=} [properties] Properties to set
             */
            function DescribePathRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribePathRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.DescribePathRequest
             * @instance
             */
            DescribePathRequest.prototype.operationParams = null;

            /**
             * DescribePathRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.DescribePathRequest
             * @instance
             */
            DescribePathRequest.prototype.path = "";

            /**
             * Creates a new DescribePathRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Ydb.Scheme.IDescribePathRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.DescribePathRequest} DescribePathRequest instance
             */
            DescribePathRequest.create = function create(properties) {
                return new DescribePathRequest(properties);
            };

            /**
             * Encodes the specified DescribePathRequest message. Does not implicitly {@link Ydb.Scheme.DescribePathRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Ydb.Scheme.IDescribePathRequest} message DescribePathRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified DescribePathRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.DescribePathRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Ydb.Scheme.IDescribePathRequest} message DescribePathRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribePathRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.DescribePathRequest} DescribePathRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.DescribePathRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribePathRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.DescribePathRequest} DescribePathRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribePathRequest message.
             * @function verify
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribePathRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a DescribePathRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.DescribePathRequest} DescribePathRequest
             */
            DescribePathRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.DescribePathRequest)
                    return object;
                var message = new $root.Ydb.Scheme.DescribePathRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.DescribePathRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a DescribePathRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Ydb.Scheme.DescribePathRequest} message DescribePathRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribePathRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this DescribePathRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.DescribePathRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribePathRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribePathRequest;
        })();

        Scheme.DescribePathResponse = (function() {

            /**
             * Properties of a DescribePathResponse.
             * @memberof Ydb.Scheme
             * @interface IDescribePathResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DescribePathResponse operation
             */

            /**
             * Constructs a new DescribePathResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a DescribePathResponse.
             * @implements IDescribePathResponse
             * @constructor
             * @param {Ydb.Scheme.IDescribePathResponse=} [properties] Properties to set
             */
            function DescribePathResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribePathResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.DescribePathResponse
             * @instance
             */
            DescribePathResponse.prototype.operation = null;

            /**
             * Creates a new DescribePathResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Ydb.Scheme.IDescribePathResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.DescribePathResponse} DescribePathResponse instance
             */
            DescribePathResponse.create = function create(properties) {
                return new DescribePathResponse(properties);
            };

            /**
             * Encodes the specified DescribePathResponse message. Does not implicitly {@link Ydb.Scheme.DescribePathResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Ydb.Scheme.IDescribePathResponse} message DescribePathResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribePathResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.DescribePathResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Ydb.Scheme.IDescribePathResponse} message DescribePathResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribePathResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.DescribePathResponse} DescribePathResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.DescribePathResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribePathResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.DescribePathResponse} DescribePathResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribePathResponse message.
             * @function verify
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribePathResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DescribePathResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.DescribePathResponse} DescribePathResponse
             */
            DescribePathResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.DescribePathResponse)
                    return object;
                var message = new $root.Ydb.Scheme.DescribePathResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.DescribePathResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribePathResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Ydb.Scheme.DescribePathResponse} message DescribePathResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribePathResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DescribePathResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.DescribePathResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribePathResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribePathResponse;
        })();

        Scheme.DescribePathResult = (function() {

            /**
             * Properties of a DescribePathResult.
             * @memberof Ydb.Scheme
             * @interface IDescribePathResult
             * @property {Ydb.Scheme.IEntry|null} [self] DescribePathResult self
             */

            /**
             * Constructs a new DescribePathResult.
             * @memberof Ydb.Scheme
             * @classdesc Represents a DescribePathResult.
             * @implements IDescribePathResult
             * @constructor
             * @param {Ydb.Scheme.IDescribePathResult=} [properties] Properties to set
             */
            function DescribePathResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribePathResult self.
             * @member {Ydb.Scheme.IEntry|null|undefined} self
             * @memberof Ydb.Scheme.DescribePathResult
             * @instance
             */
            DescribePathResult.prototype.self = null;

            /**
             * Creates a new DescribePathResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Ydb.Scheme.IDescribePathResult=} [properties] Properties to set
             * @returns {Ydb.Scheme.DescribePathResult} DescribePathResult instance
             */
            DescribePathResult.create = function create(properties) {
                return new DescribePathResult(properties);
            };

            /**
             * Encodes the specified DescribePathResult message. Does not implicitly {@link Ydb.Scheme.DescribePathResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Ydb.Scheme.IDescribePathResult} message DescribePathResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.self != null && message.hasOwnProperty("self"))
                    $root.Ydb.Scheme.Entry.encode(message.self, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribePathResult message, length delimited. Does not implicitly {@link Ydb.Scheme.DescribePathResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Ydb.Scheme.IDescribePathResult} message DescribePathResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribePathResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.DescribePathResult} DescribePathResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.DescribePathResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.self = $root.Ydb.Scheme.Entry.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribePathResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.DescribePathResult} DescribePathResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribePathResult message.
             * @function verify
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribePathResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.self != null && message.hasOwnProperty("self")) {
                    var error = $root.Ydb.Scheme.Entry.verify(message.self);
                    if (error)
                        return "self." + error;
                }
                return null;
            };

            /**
             * Creates a DescribePathResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.DescribePathResult} DescribePathResult
             */
            DescribePathResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.DescribePathResult)
                    return object;
                var message = new $root.Ydb.Scheme.DescribePathResult();
                if (object.self != null) {
                    if (typeof object.self !== "object")
                        throw TypeError(".Ydb.Scheme.DescribePathResult.self: object expected");
                    message.self = $root.Ydb.Scheme.Entry.fromObject(object.self);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribePathResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Ydb.Scheme.DescribePathResult} message DescribePathResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribePathResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.self = null;
                if (message.self != null && message.hasOwnProperty("self"))
                    object.self = $root.Ydb.Scheme.Entry.toObject(message.self, options);
                return object;
            };

            /**
             * Converts this DescribePathResult to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.DescribePathResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribePathResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribePathResult;
        })();

        Scheme.PermissionsAction = (function() {

            /**
             * Properties of a PermissionsAction.
             * @memberof Ydb.Scheme
             * @interface IPermissionsAction
             * @property {Ydb.Scheme.IPermissions|null} [grant] PermissionsAction grant
             * @property {Ydb.Scheme.IPermissions|null} [revoke] PermissionsAction revoke
             * @property {Ydb.Scheme.IPermissions|null} [set] PermissionsAction set
             * @property {string|null} [changeOwner] PermissionsAction changeOwner
             */

            /**
             * Constructs a new PermissionsAction.
             * @memberof Ydb.Scheme
             * @classdesc Represents a PermissionsAction.
             * @implements IPermissionsAction
             * @constructor
             * @param {Ydb.Scheme.IPermissionsAction=} [properties] Properties to set
             */
            function PermissionsAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PermissionsAction grant.
             * @member {Ydb.Scheme.IPermissions|null|undefined} grant
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            PermissionsAction.prototype.grant = null;

            /**
             * PermissionsAction revoke.
             * @member {Ydb.Scheme.IPermissions|null|undefined} revoke
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            PermissionsAction.prototype.revoke = null;

            /**
             * PermissionsAction set.
             * @member {Ydb.Scheme.IPermissions|null|undefined} set
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            PermissionsAction.prototype.set = null;

            /**
             * PermissionsAction changeOwner.
             * @member {string} changeOwner
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            PermissionsAction.prototype.changeOwner = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * PermissionsAction action.
             * @member {"grant"|"revoke"|"set"|"changeOwner"|undefined} action
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            Object.defineProperty(PermissionsAction.prototype, "action", {
                get: $util.oneOfGetter($oneOfFields = ["grant", "revoke", "set", "changeOwner"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PermissionsAction instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Ydb.Scheme.IPermissionsAction=} [properties] Properties to set
             * @returns {Ydb.Scheme.PermissionsAction} PermissionsAction instance
             */
            PermissionsAction.create = function create(properties) {
                return new PermissionsAction(properties);
            };

            /**
             * Encodes the specified PermissionsAction message. Does not implicitly {@link Ydb.Scheme.PermissionsAction.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Ydb.Scheme.IPermissionsAction} message PermissionsAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionsAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.grant != null && message.hasOwnProperty("grant"))
                    $root.Ydb.Scheme.Permissions.encode(message.grant, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.revoke != null && message.hasOwnProperty("revoke"))
                    $root.Ydb.Scheme.Permissions.encode(message.revoke, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.set != null && message.hasOwnProperty("set"))
                    $root.Ydb.Scheme.Permissions.encode(message.set, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.changeOwner != null && message.hasOwnProperty("changeOwner"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.changeOwner);
                return writer;
            };

            /**
             * Encodes the specified PermissionsAction message, length delimited. Does not implicitly {@link Ydb.Scheme.PermissionsAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Ydb.Scheme.IPermissionsAction} message PermissionsAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionsAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PermissionsAction message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.PermissionsAction} PermissionsAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionsAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.PermissionsAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grant = $root.Ydb.Scheme.Permissions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.revoke = $root.Ydb.Scheme.Permissions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.set = $root.Ydb.Scheme.Permissions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.changeOwner = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PermissionsAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.PermissionsAction} PermissionsAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionsAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PermissionsAction message.
             * @function verify
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PermissionsAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.grant != null && message.hasOwnProperty("grant")) {
                    properties.action = 1;
                    {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.grant);
                        if (error)
                            return "grant." + error;
                    }
                }
                if (message.revoke != null && message.hasOwnProperty("revoke")) {
                    if (properties.action === 1)
                        return "action: multiple values";
                    properties.action = 1;
                    {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.revoke);
                        if (error)
                            return "revoke." + error;
                    }
                }
                if (message.set != null && message.hasOwnProperty("set")) {
                    if (properties.action === 1)
                        return "action: multiple values";
                    properties.action = 1;
                    {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.set);
                        if (error)
                            return "set." + error;
                    }
                }
                if (message.changeOwner != null && message.hasOwnProperty("changeOwner")) {
                    if (properties.action === 1)
                        return "action: multiple values";
                    properties.action = 1;
                    if (!$util.isString(message.changeOwner))
                        return "changeOwner: string expected";
                }
                return null;
            };

            /**
             * Creates a PermissionsAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.PermissionsAction} PermissionsAction
             */
            PermissionsAction.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.PermissionsAction)
                    return object;
                var message = new $root.Ydb.Scheme.PermissionsAction();
                if (object.grant != null) {
                    if (typeof object.grant !== "object")
                        throw TypeError(".Ydb.Scheme.PermissionsAction.grant: object expected");
                    message.grant = $root.Ydb.Scheme.Permissions.fromObject(object.grant);
                }
                if (object.revoke != null) {
                    if (typeof object.revoke !== "object")
                        throw TypeError(".Ydb.Scheme.PermissionsAction.revoke: object expected");
                    message.revoke = $root.Ydb.Scheme.Permissions.fromObject(object.revoke);
                }
                if (object.set != null) {
                    if (typeof object.set !== "object")
                        throw TypeError(".Ydb.Scheme.PermissionsAction.set: object expected");
                    message.set = $root.Ydb.Scheme.Permissions.fromObject(object.set);
                }
                if (object.changeOwner != null)
                    message.changeOwner = String(object.changeOwner);
                return message;
            };

            /**
             * Creates a plain object from a PermissionsAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Ydb.Scheme.PermissionsAction} message PermissionsAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PermissionsAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.grant != null && message.hasOwnProperty("grant")) {
                    object.grant = $root.Ydb.Scheme.Permissions.toObject(message.grant, options);
                    if (options.oneofs)
                        object.action = "grant";
                }
                if (message.revoke != null && message.hasOwnProperty("revoke")) {
                    object.revoke = $root.Ydb.Scheme.Permissions.toObject(message.revoke, options);
                    if (options.oneofs)
                        object.action = "revoke";
                }
                if (message.set != null && message.hasOwnProperty("set")) {
                    object.set = $root.Ydb.Scheme.Permissions.toObject(message.set, options);
                    if (options.oneofs)
                        object.action = "set";
                }
                if (message.changeOwner != null && message.hasOwnProperty("changeOwner")) {
                    object.changeOwner = message.changeOwner;
                    if (options.oneofs)
                        object.action = "changeOwner";
                }
                return object;
            };

            /**
             * Converts this PermissionsAction to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PermissionsAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PermissionsAction;
        })();

        Scheme.ModifyPermissionsRequest = (function() {

            /**
             * Properties of a ModifyPermissionsRequest.
             * @memberof Ydb.Scheme
             * @interface IModifyPermissionsRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ModifyPermissionsRequest operationParams
             * @property {string|null} [path] ModifyPermissionsRequest path
             * @property {Array.<Ydb.Scheme.IPermissionsAction>|null} [actions] ModifyPermissionsRequest actions
             * @property {boolean|null} [clearPermissions] ModifyPermissionsRequest clearPermissions
             */

            /**
             * Constructs a new ModifyPermissionsRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ModifyPermissionsRequest.
             * @implements IModifyPermissionsRequest
             * @constructor
             * @param {Ydb.Scheme.IModifyPermissionsRequest=} [properties] Properties to set
             */
            function ModifyPermissionsRequest(properties) {
                this.actions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyPermissionsRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             */
            ModifyPermissionsRequest.prototype.operationParams = null;

            /**
             * ModifyPermissionsRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             */
            ModifyPermissionsRequest.prototype.path = "";

            /**
             * ModifyPermissionsRequest actions.
             * @member {Array.<Ydb.Scheme.IPermissionsAction>} actions
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             */
            ModifyPermissionsRequest.prototype.actions = $util.emptyArray;

            /**
             * ModifyPermissionsRequest clearPermissions.
             * @member {boolean} clearPermissions
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             */
            ModifyPermissionsRequest.prototype.clearPermissions = false;

            /**
             * Creates a new ModifyPermissionsRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.ModifyPermissionsRequest} ModifyPermissionsRequest instance
             */
            ModifyPermissionsRequest.create = function create(properties) {
                return new ModifyPermissionsRequest(properties);
            };

            /**
             * Encodes the specified ModifyPermissionsRequest message. Does not implicitly {@link Ydb.Scheme.ModifyPermissionsRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsRequest} message ModifyPermissionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyPermissionsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.actions != null && message.actions.length)
                    for (var i = 0; i < message.actions.length; ++i)
                        $root.Ydb.Scheme.PermissionsAction.encode(message.actions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clearPermissions != null && message.hasOwnProperty("clearPermissions"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.clearPermissions);
                return writer;
            };

            /**
             * Encodes the specified ModifyPermissionsRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.ModifyPermissionsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsRequest} message ModifyPermissionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyPermissionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyPermissionsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ModifyPermissionsRequest} ModifyPermissionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyPermissionsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ModifyPermissionsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 3:
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.Ydb.Scheme.PermissionsAction.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.clearPermissions = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyPermissionsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ModifyPermissionsRequest} ModifyPermissionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyPermissionsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyPermissionsRequest message.
             * @function verify
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyPermissionsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.actions != null && message.hasOwnProperty("actions")) {
                    if (!Array.isArray(message.actions))
                        return "actions: array expected";
                    for (var i = 0; i < message.actions.length; ++i) {
                        var error = $root.Ydb.Scheme.PermissionsAction.verify(message.actions[i]);
                        if (error)
                            return "actions." + error;
                    }
                }
                if (message.clearPermissions != null && message.hasOwnProperty("clearPermissions"))
                    if (typeof message.clearPermissions !== "boolean")
                        return "clearPermissions: boolean expected";
                return null;
            };

            /**
             * Creates a ModifyPermissionsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ModifyPermissionsRequest} ModifyPermissionsRequest
             */
            ModifyPermissionsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ModifyPermissionsRequest)
                    return object;
                var message = new $root.Ydb.Scheme.ModifyPermissionsRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.ModifyPermissionsRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                if (object.actions) {
                    if (!Array.isArray(object.actions))
                        throw TypeError(".Ydb.Scheme.ModifyPermissionsRequest.actions: array expected");
                    message.actions = [];
                    for (var i = 0; i < object.actions.length; ++i) {
                        if (typeof object.actions[i] !== "object")
                            throw TypeError(".Ydb.Scheme.ModifyPermissionsRequest.actions: object expected");
                        message.actions[i] = $root.Ydb.Scheme.PermissionsAction.fromObject(object.actions[i]);
                    }
                }
                if (object.clearPermissions != null)
                    message.clearPermissions = Boolean(object.clearPermissions);
                return message;
            };

            /**
             * Creates a plain object from a ModifyPermissionsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Ydb.Scheme.ModifyPermissionsRequest} message ModifyPermissionsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyPermissionsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.actions = [];
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                    object.clearPermissions = false;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.actions && message.actions.length) {
                    object.actions = [];
                    for (var j = 0; j < message.actions.length; ++j)
                        object.actions[j] = $root.Ydb.Scheme.PermissionsAction.toObject(message.actions[j], options);
                }
                if (message.clearPermissions != null && message.hasOwnProperty("clearPermissions"))
                    object.clearPermissions = message.clearPermissions;
                return object;
            };

            /**
             * Converts this ModifyPermissionsRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyPermissionsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ModifyPermissionsRequest;
        })();

        Scheme.ModifyPermissionsResponse = (function() {

            /**
             * Properties of a ModifyPermissionsResponse.
             * @memberof Ydb.Scheme
             * @interface IModifyPermissionsResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ModifyPermissionsResponse operation
             */

            /**
             * Constructs a new ModifyPermissionsResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ModifyPermissionsResponse.
             * @implements IModifyPermissionsResponse
             * @constructor
             * @param {Ydb.Scheme.IModifyPermissionsResponse=} [properties] Properties to set
             */
            function ModifyPermissionsResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyPermissionsResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @instance
             */
            ModifyPermissionsResponse.prototype.operation = null;

            /**
             * Creates a new ModifyPermissionsResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.ModifyPermissionsResponse} ModifyPermissionsResponse instance
             */
            ModifyPermissionsResponse.create = function create(properties) {
                return new ModifyPermissionsResponse(properties);
            };

            /**
             * Encodes the specified ModifyPermissionsResponse message. Does not implicitly {@link Ydb.Scheme.ModifyPermissionsResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsResponse} message ModifyPermissionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyPermissionsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ModifyPermissionsResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.ModifyPermissionsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsResponse} message ModifyPermissionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyPermissionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyPermissionsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ModifyPermissionsResponse} ModifyPermissionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyPermissionsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ModifyPermissionsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyPermissionsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ModifyPermissionsResponse} ModifyPermissionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyPermissionsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyPermissionsResponse message.
             * @function verify
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyPermissionsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a ModifyPermissionsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ModifyPermissionsResponse} ModifyPermissionsResponse
             */
            ModifyPermissionsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ModifyPermissionsResponse)
                    return object;
                var message = new $root.Ydb.Scheme.ModifyPermissionsResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.ModifyPermissionsResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a ModifyPermissionsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Ydb.Scheme.ModifyPermissionsResponse} message ModifyPermissionsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyPermissionsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ModifyPermissionsResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyPermissionsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ModifyPermissionsResponse;
        })();

        Scheme.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Scheme
             * @namespace
             */
            var V1 = {};

            V1.SchemeService = (function() {

                /**
                 * Constructs a new SchemeService service.
                 * @memberof Ydb.Scheme.V1
                 * @classdesc Represents a SchemeService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function SchemeService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (SchemeService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SchemeService;

                /**
                 * Creates new SchemeService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {SchemeService} RPC service. Useful where requests and/or responses are streamed.
                 */
                SchemeService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Scheme.V1.SchemeService#makeDirectory}.
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @typedef MakeDirectoryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Scheme.MakeDirectoryResponse} [response] MakeDirectoryResponse
                 */

                /**
                 * Calls MakeDirectory.
                 * @function makeDirectory
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IMakeDirectoryRequest} request MakeDirectoryRequest message or plain object
                 * @param {Ydb.Scheme.V1.SchemeService.MakeDirectoryCallback} callback Node-style callback called with the error, if any, and MakeDirectoryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SchemeService.prototype.makeDirectory = function makeDirectory(request, callback) {
                    return this.rpcCall(makeDirectory, $root.Ydb.Scheme.MakeDirectoryRequest, $root.Ydb.Scheme.MakeDirectoryResponse, request, callback);
                }, "name", { value: "MakeDirectory" });

                /**
                 * Calls MakeDirectory.
                 * @function makeDirectory
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IMakeDirectoryRequest} request MakeDirectoryRequest message or plain object
                 * @returns {Promise<Ydb.Scheme.MakeDirectoryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Scheme.V1.SchemeService#removeDirectory}.
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @typedef RemoveDirectoryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Scheme.RemoveDirectoryResponse} [response] RemoveDirectoryResponse
                 */

                /**
                 * Calls RemoveDirectory.
                 * @function removeDirectory
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IRemoveDirectoryRequest} request RemoveDirectoryRequest message or plain object
                 * @param {Ydb.Scheme.V1.SchemeService.RemoveDirectoryCallback} callback Node-style callback called with the error, if any, and RemoveDirectoryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SchemeService.prototype.removeDirectory = function removeDirectory(request, callback) {
                    return this.rpcCall(removeDirectory, $root.Ydb.Scheme.RemoveDirectoryRequest, $root.Ydb.Scheme.RemoveDirectoryResponse, request, callback);
                }, "name", { value: "RemoveDirectory" });

                /**
                 * Calls RemoveDirectory.
                 * @function removeDirectory
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IRemoveDirectoryRequest} request RemoveDirectoryRequest message or plain object
                 * @returns {Promise<Ydb.Scheme.RemoveDirectoryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Scheme.V1.SchemeService#listDirectory}.
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @typedef ListDirectoryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Scheme.ListDirectoryResponse} [response] ListDirectoryResponse
                 */

                /**
                 * Calls ListDirectory.
                 * @function listDirectory
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IListDirectoryRequest} request ListDirectoryRequest message or plain object
                 * @param {Ydb.Scheme.V1.SchemeService.ListDirectoryCallback} callback Node-style callback called with the error, if any, and ListDirectoryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SchemeService.prototype.listDirectory = function listDirectory(request, callback) {
                    return this.rpcCall(listDirectory, $root.Ydb.Scheme.ListDirectoryRequest, $root.Ydb.Scheme.ListDirectoryResponse, request, callback);
                }, "name", { value: "ListDirectory" });

                /**
                 * Calls ListDirectory.
                 * @function listDirectory
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IListDirectoryRequest} request ListDirectoryRequest message or plain object
                 * @returns {Promise<Ydb.Scheme.ListDirectoryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Scheme.V1.SchemeService#describePath}.
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @typedef DescribePathCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Scheme.DescribePathResponse} [response] DescribePathResponse
                 */

                /**
                 * Calls DescribePath.
                 * @function describePath
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IDescribePathRequest} request DescribePathRequest message or plain object
                 * @param {Ydb.Scheme.V1.SchemeService.DescribePathCallback} callback Node-style callback called with the error, if any, and DescribePathResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SchemeService.prototype.describePath = function describePath(request, callback) {
                    return this.rpcCall(describePath, $root.Ydb.Scheme.DescribePathRequest, $root.Ydb.Scheme.DescribePathResponse, request, callback);
                }, "name", { value: "DescribePath" });

                /**
                 * Calls DescribePath.
                 * @function describePath
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IDescribePathRequest} request DescribePathRequest message or plain object
                 * @returns {Promise<Ydb.Scheme.DescribePathResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Scheme.V1.SchemeService#modifyPermissions}.
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @typedef ModifyPermissionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Scheme.ModifyPermissionsResponse} [response] ModifyPermissionsResponse
                 */

                /**
                 * Calls ModifyPermissions.
                 * @function modifyPermissions
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IModifyPermissionsRequest} request ModifyPermissionsRequest message or plain object
                 * @param {Ydb.Scheme.V1.SchemeService.ModifyPermissionsCallback} callback Node-style callback called with the error, if any, and ModifyPermissionsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SchemeService.prototype.modifyPermissions = function modifyPermissions(request, callback) {
                    return this.rpcCall(modifyPermissions, $root.Ydb.Scheme.ModifyPermissionsRequest, $root.Ydb.Scheme.ModifyPermissionsResponse, request, callback);
                }, "name", { value: "ModifyPermissions" });

                /**
                 * Calls ModifyPermissions.
                 * @function modifyPermissions
                 * @memberof Ydb.Scheme.V1.SchemeService
                 * @instance
                 * @param {Ydb.Scheme.IModifyPermissionsRequest} request ModifyPermissionsRequest message or plain object
                 * @returns {Promise<Ydb.Scheme.ModifyPermissionsResponse>} Promise
                 * @variation 2
                 */

                return SchemeService;
            })();

            return V1;
        })();

        return Scheme;
    })();

    Ydb.Discovery = (function() {

        /**
         * Namespace Discovery.
         * @memberof Ydb
         * @namespace
         */
        var Discovery = {};

        Discovery.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Discovery
             * @namespace
             */
            var V1 = {};

            V1.DiscoveryService = (function() {

                /**
                 * Constructs a new DiscoveryService service.
                 * @memberof Ydb.Discovery.V1
                 * @classdesc Represents a DiscoveryService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function DiscoveryService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (DiscoveryService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DiscoveryService;

                /**
                 * Creates new DiscoveryService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {DiscoveryService} RPC service. Useful where requests and/or responses are streamed.
                 */
                DiscoveryService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Discovery.V1.DiscoveryService#listEndpoints}.
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @typedef ListEndpointsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Discovery.ListEndpointsResponse} [response] ListEndpointsResponse
                 */

                /**
                 * Calls ListEndpoints.
                 * @function listEndpoints
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @instance
                 * @param {Ydb.Discovery.IListEndpointsRequest} request ListEndpointsRequest message or plain object
                 * @param {Ydb.Discovery.V1.DiscoveryService.ListEndpointsCallback} callback Node-style callback called with the error, if any, and ListEndpointsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DiscoveryService.prototype.listEndpoints = function listEndpoints(request, callback) {
                    return this.rpcCall(listEndpoints, $root.Ydb.Discovery.ListEndpointsRequest, $root.Ydb.Discovery.ListEndpointsResponse, request, callback);
                }, "name", { value: "ListEndpoints" });

                /**
                 * Calls ListEndpoints.
                 * @function listEndpoints
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @instance
                 * @param {Ydb.Discovery.IListEndpointsRequest} request ListEndpointsRequest message or plain object
                 * @returns {Promise<Ydb.Discovery.ListEndpointsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Discovery.V1.DiscoveryService#whoAmI}.
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @typedef WhoAmICallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Discovery.WhoAmIResponse} [response] WhoAmIResponse
                 */

                /**
                 * Calls WhoAmI.
                 * @function whoAmI
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @instance
                 * @param {Ydb.Discovery.IWhoAmIRequest} request WhoAmIRequest message or plain object
                 * @param {Ydb.Discovery.V1.DiscoveryService.WhoAmICallback} callback Node-style callback called with the error, if any, and WhoAmIResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DiscoveryService.prototype.whoAmI = function whoAmI(request, callback) {
                    return this.rpcCall(whoAmI, $root.Ydb.Discovery.WhoAmIRequest, $root.Ydb.Discovery.WhoAmIResponse, request, callback);
                }, "name", { value: "WhoAmI" });

                /**
                 * Calls WhoAmI.
                 * @function whoAmI
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @instance
                 * @param {Ydb.Discovery.IWhoAmIRequest} request WhoAmIRequest message or plain object
                 * @returns {Promise<Ydb.Discovery.WhoAmIResponse>} Promise
                 * @variation 2
                 */

                return DiscoveryService;
            })();

            return V1;
        })();

        Discovery.ListEndpointsRequest = (function() {

            /**
             * Properties of a ListEndpointsRequest.
             * @memberof Ydb.Discovery
             * @interface IListEndpointsRequest
             * @property {string|null} [database] ListEndpointsRequest database
             * @property {Array.<string>|null} [service] ListEndpointsRequest service
             */

            /**
             * Constructs a new ListEndpointsRequest.
             * @memberof Ydb.Discovery
             * @classdesc Represents a ListEndpointsRequest.
             * @implements IListEndpointsRequest
             * @constructor
             * @param {Ydb.Discovery.IListEndpointsRequest=} [properties] Properties to set
             */
            function ListEndpointsRequest(properties) {
                this.service = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListEndpointsRequest database.
             * @member {string} database
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @instance
             */
            ListEndpointsRequest.prototype.database = "";

            /**
             * ListEndpointsRequest service.
             * @member {Array.<string>} service
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @instance
             */
            ListEndpointsRequest.prototype.service = $util.emptyArray;

            /**
             * Creates a new ListEndpointsRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Ydb.Discovery.IListEndpointsRequest=} [properties] Properties to set
             * @returns {Ydb.Discovery.ListEndpointsRequest} ListEndpointsRequest instance
             */
            ListEndpointsRequest.create = function create(properties) {
                return new ListEndpointsRequest(properties);
            };

            /**
             * Encodes the specified ListEndpointsRequest message. Does not implicitly {@link Ydb.Discovery.ListEndpointsRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Ydb.Discovery.IListEndpointsRequest} message ListEndpointsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && message.hasOwnProperty("database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.service[i]);
                return writer;
            };

            /**
             * Encodes the specified ListEndpointsRequest message, length delimited. Does not implicitly {@link Ydb.Discovery.ListEndpointsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Ydb.Discovery.IListEndpointsRequest} message ListEndpointsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListEndpointsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.ListEndpointsRequest} ListEndpointsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.ListEndpointsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.string();
                        break;
                    case 2:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListEndpointsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.ListEndpointsRequest} ListEndpointsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListEndpointsRequest message.
             * @function verify
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListEndpointsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i)
                        if (!$util.isString(message.service[i]))
                            return "service: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ListEndpointsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.ListEndpointsRequest} ListEndpointsRequest
             */
            ListEndpointsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.ListEndpointsRequest)
                    return object;
                var message = new $root.Ydb.Discovery.ListEndpointsRequest();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".Ydb.Discovery.ListEndpointsRequest.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i)
                        message.service[i] = String(object.service[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListEndpointsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Ydb.Discovery.ListEndpointsRequest} message ListEndpointsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListEndpointsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.service = [];
                if (options.defaults)
                    object.database = "";
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = message.service[j];
                }
                return object;
            };

            /**
             * Converts this ListEndpointsRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListEndpointsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListEndpointsRequest;
        })();

        Discovery.EndpointInfo = (function() {

            /**
             * Properties of an EndpointInfo.
             * @memberof Ydb.Discovery
             * @interface IEndpointInfo
             * @property {string|null} [address] EndpointInfo address
             * @property {number|null} [port] EndpointInfo port
             * @property {number|null} [loadFactor] EndpointInfo loadFactor
             * @property {boolean|null} [ssl] EndpointInfo ssl
             * @property {Array.<string>|null} [service] EndpointInfo service
             * @property {string|null} [location] EndpointInfo location
             */

            /**
             * Constructs a new EndpointInfo.
             * @memberof Ydb.Discovery
             * @classdesc Represents an EndpointInfo.
             * @implements IEndpointInfo
             * @constructor
             * @param {Ydb.Discovery.IEndpointInfo=} [properties] Properties to set
             */
            function EndpointInfo(properties) {
                this.service = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EndpointInfo address.
             * @member {string} address
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.address = "";

            /**
             * EndpointInfo port.
             * @member {number} port
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.port = 0;

            /**
             * EndpointInfo loadFactor.
             * @member {number} loadFactor
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.loadFactor = 0;

            /**
             * EndpointInfo ssl.
             * @member {boolean} ssl
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.ssl = false;

            /**
             * EndpointInfo service.
             * @member {Array.<string>} service
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.service = $util.emptyArray;

            /**
             * EndpointInfo location.
             * @member {string} location
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.location = "";

            /**
             * Creates a new EndpointInfo instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Ydb.Discovery.IEndpointInfo=} [properties] Properties to set
             * @returns {Ydb.Discovery.EndpointInfo} EndpointInfo instance
             */
            EndpointInfo.create = function create(properties) {
                return new EndpointInfo(properties);
            };

            /**
             * Encodes the specified EndpointInfo message. Does not implicitly {@link Ydb.Discovery.EndpointInfo.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Ydb.Discovery.IEndpointInfo} message EndpointInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndpointInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && message.hasOwnProperty("address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.loadFactor != null && message.hasOwnProperty("loadFactor"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.loadFactor);
                if (message.ssl != null && message.hasOwnProperty("ssl"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.ssl);
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.service[i]);
                if (message.location != null && message.hasOwnProperty("location"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.location);
                return writer;
            };

            /**
             * Encodes the specified EndpointInfo message, length delimited. Does not implicitly {@link Ydb.Discovery.EndpointInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Ydb.Discovery.IEndpointInfo} message EndpointInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndpointInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EndpointInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.EndpointInfo} EndpointInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndpointInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.EndpointInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.loadFactor = reader.float();
                        break;
                    case 4:
                        message.ssl = reader.bool();
                        break;
                    case 5:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push(reader.string());
                        break;
                    case 6:
                        message.location = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EndpointInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.EndpointInfo} EndpointInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndpointInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EndpointInfo message.
             * @function verify
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EndpointInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.loadFactor != null && message.hasOwnProperty("loadFactor"))
                    if (typeof message.loadFactor !== "number")
                        return "loadFactor: number expected";
                if (message.ssl != null && message.hasOwnProperty("ssl"))
                    if (typeof message.ssl !== "boolean")
                        return "ssl: boolean expected";
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i)
                        if (!$util.isString(message.service[i]))
                            return "service: string[] expected";
                }
                if (message.location != null && message.hasOwnProperty("location"))
                    if (!$util.isString(message.location))
                        return "location: string expected";
                return null;
            };

            /**
             * Creates an EndpointInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.EndpointInfo} EndpointInfo
             */
            EndpointInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.EndpointInfo)
                    return object;
                var message = new $root.Ydb.Discovery.EndpointInfo();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.loadFactor != null)
                    message.loadFactor = Number(object.loadFactor);
                if (object.ssl != null)
                    message.ssl = Boolean(object.ssl);
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".Ydb.Discovery.EndpointInfo.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i)
                        message.service[i] = String(object.service[i]);
                }
                if (object.location != null)
                    message.location = String(object.location);
                return message;
            };

            /**
             * Creates a plain object from an EndpointInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Ydb.Discovery.EndpointInfo} message EndpointInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EndpointInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.service = [];
                if (options.defaults) {
                    object.address = "";
                    object.port = 0;
                    object.loadFactor = 0;
                    object.ssl = false;
                    object.location = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.loadFactor != null && message.hasOwnProperty("loadFactor"))
                    object.loadFactor = options.json && !isFinite(message.loadFactor) ? String(message.loadFactor) : message.loadFactor;
                if (message.ssl != null && message.hasOwnProperty("ssl"))
                    object.ssl = message.ssl;
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = message.service[j];
                }
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = message.location;
                return object;
            };

            /**
             * Converts this EndpointInfo to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EndpointInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EndpointInfo;
        })();

        Discovery.ListEndpointsResult = (function() {

            /**
             * Properties of a ListEndpointsResult.
             * @memberof Ydb.Discovery
             * @interface IListEndpointsResult
             * @property {Array.<Ydb.Discovery.IEndpointInfo>|null} [endpoints] ListEndpointsResult endpoints
             * @property {string|null} [selfLocation] ListEndpointsResult selfLocation
             */

            /**
             * Constructs a new ListEndpointsResult.
             * @memberof Ydb.Discovery
             * @classdesc Represents a ListEndpointsResult.
             * @implements IListEndpointsResult
             * @constructor
             * @param {Ydb.Discovery.IListEndpointsResult=} [properties] Properties to set
             */
            function ListEndpointsResult(properties) {
                this.endpoints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListEndpointsResult endpoints.
             * @member {Array.<Ydb.Discovery.IEndpointInfo>} endpoints
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @instance
             */
            ListEndpointsResult.prototype.endpoints = $util.emptyArray;

            /**
             * ListEndpointsResult selfLocation.
             * @member {string} selfLocation
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @instance
             */
            ListEndpointsResult.prototype.selfLocation = "";

            /**
             * Creates a new ListEndpointsResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Ydb.Discovery.IListEndpointsResult=} [properties] Properties to set
             * @returns {Ydb.Discovery.ListEndpointsResult} ListEndpointsResult instance
             */
            ListEndpointsResult.create = function create(properties) {
                return new ListEndpointsResult(properties);
            };

            /**
             * Encodes the specified ListEndpointsResult message. Does not implicitly {@link Ydb.Discovery.ListEndpointsResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Ydb.Discovery.IListEndpointsResult} message ListEndpointsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endpoints != null && message.endpoints.length)
                    for (var i = 0; i < message.endpoints.length; ++i)
                        $root.Ydb.Discovery.EndpointInfo.encode(message.endpoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.selfLocation != null && message.hasOwnProperty("selfLocation"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.selfLocation);
                return writer;
            };

            /**
             * Encodes the specified ListEndpointsResult message, length delimited. Does not implicitly {@link Ydb.Discovery.ListEndpointsResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Ydb.Discovery.IListEndpointsResult} message ListEndpointsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListEndpointsResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.ListEndpointsResult} ListEndpointsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.ListEndpointsResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.endpoints && message.endpoints.length))
                            message.endpoints = [];
                        message.endpoints.push($root.Ydb.Discovery.EndpointInfo.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.selfLocation = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListEndpointsResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.ListEndpointsResult} ListEndpointsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListEndpointsResult message.
             * @function verify
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListEndpointsResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endpoints != null && message.hasOwnProperty("endpoints")) {
                    if (!Array.isArray(message.endpoints))
                        return "endpoints: array expected";
                    for (var i = 0; i < message.endpoints.length; ++i) {
                        var error = $root.Ydb.Discovery.EndpointInfo.verify(message.endpoints[i]);
                        if (error)
                            return "endpoints." + error;
                    }
                }
                if (message.selfLocation != null && message.hasOwnProperty("selfLocation"))
                    if (!$util.isString(message.selfLocation))
                        return "selfLocation: string expected";
                return null;
            };

            /**
             * Creates a ListEndpointsResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.ListEndpointsResult} ListEndpointsResult
             */
            ListEndpointsResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.ListEndpointsResult)
                    return object;
                var message = new $root.Ydb.Discovery.ListEndpointsResult();
                if (object.endpoints) {
                    if (!Array.isArray(object.endpoints))
                        throw TypeError(".Ydb.Discovery.ListEndpointsResult.endpoints: array expected");
                    message.endpoints = [];
                    for (var i = 0; i < object.endpoints.length; ++i) {
                        if (typeof object.endpoints[i] !== "object")
                            throw TypeError(".Ydb.Discovery.ListEndpointsResult.endpoints: object expected");
                        message.endpoints[i] = $root.Ydb.Discovery.EndpointInfo.fromObject(object.endpoints[i]);
                    }
                }
                if (object.selfLocation != null)
                    message.selfLocation = String(object.selfLocation);
                return message;
            };

            /**
             * Creates a plain object from a ListEndpointsResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Ydb.Discovery.ListEndpointsResult} message ListEndpointsResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListEndpointsResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.endpoints = [];
                if (options.defaults)
                    object.selfLocation = "";
                if (message.endpoints && message.endpoints.length) {
                    object.endpoints = [];
                    for (var j = 0; j < message.endpoints.length; ++j)
                        object.endpoints[j] = $root.Ydb.Discovery.EndpointInfo.toObject(message.endpoints[j], options);
                }
                if (message.selfLocation != null && message.hasOwnProperty("selfLocation"))
                    object.selfLocation = message.selfLocation;
                return object;
            };

            /**
             * Converts this ListEndpointsResult to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListEndpointsResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListEndpointsResult;
        })();

        Discovery.ListEndpointsResponse = (function() {

            /**
             * Properties of a ListEndpointsResponse.
             * @memberof Ydb.Discovery
             * @interface IListEndpointsResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ListEndpointsResponse operation
             */

            /**
             * Constructs a new ListEndpointsResponse.
             * @memberof Ydb.Discovery
             * @classdesc Represents a ListEndpointsResponse.
             * @implements IListEndpointsResponse
             * @constructor
             * @param {Ydb.Discovery.IListEndpointsResponse=} [properties] Properties to set
             */
            function ListEndpointsResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListEndpointsResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @instance
             */
            ListEndpointsResponse.prototype.operation = null;

            /**
             * Creates a new ListEndpointsResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Ydb.Discovery.IListEndpointsResponse=} [properties] Properties to set
             * @returns {Ydb.Discovery.ListEndpointsResponse} ListEndpointsResponse instance
             */
            ListEndpointsResponse.create = function create(properties) {
                return new ListEndpointsResponse(properties);
            };

            /**
             * Encodes the specified ListEndpointsResponse message. Does not implicitly {@link Ydb.Discovery.ListEndpointsResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Ydb.Discovery.IListEndpointsResponse} message ListEndpointsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListEndpointsResponse message, length delimited. Does not implicitly {@link Ydb.Discovery.ListEndpointsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Ydb.Discovery.IListEndpointsResponse} message ListEndpointsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListEndpointsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.ListEndpointsResponse} ListEndpointsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.ListEndpointsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListEndpointsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.ListEndpointsResponse} ListEndpointsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListEndpointsResponse message.
             * @function verify
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListEndpointsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a ListEndpointsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.ListEndpointsResponse} ListEndpointsResponse
             */
            ListEndpointsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.ListEndpointsResponse)
                    return object;
                var message = new $root.Ydb.Discovery.ListEndpointsResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Discovery.ListEndpointsResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListEndpointsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Ydb.Discovery.ListEndpointsResponse} message ListEndpointsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListEndpointsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ListEndpointsResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListEndpointsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListEndpointsResponse;
        })();

        Discovery.WhoAmIRequest = (function() {

            /**
             * Properties of a WhoAmIRequest.
             * @memberof Ydb.Discovery
             * @interface IWhoAmIRequest
             * @property {boolean|null} [includeGroups] WhoAmIRequest includeGroups
             */

            /**
             * Constructs a new WhoAmIRequest.
             * @memberof Ydb.Discovery
             * @classdesc Represents a WhoAmIRequest.
             * @implements IWhoAmIRequest
             * @constructor
             * @param {Ydb.Discovery.IWhoAmIRequest=} [properties] Properties to set
             */
            function WhoAmIRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WhoAmIRequest includeGroups.
             * @member {boolean} includeGroups
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @instance
             */
            WhoAmIRequest.prototype.includeGroups = false;

            /**
             * Creates a new WhoAmIRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Ydb.Discovery.IWhoAmIRequest=} [properties] Properties to set
             * @returns {Ydb.Discovery.WhoAmIRequest} WhoAmIRequest instance
             */
            WhoAmIRequest.create = function create(properties) {
                return new WhoAmIRequest(properties);
            };

            /**
             * Encodes the specified WhoAmIRequest message. Does not implicitly {@link Ydb.Discovery.WhoAmIRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Ydb.Discovery.IWhoAmIRequest} message WhoAmIRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.includeGroups != null && message.hasOwnProperty("includeGroups"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.includeGroups);
                return writer;
            };

            /**
             * Encodes the specified WhoAmIRequest message, length delimited. Does not implicitly {@link Ydb.Discovery.WhoAmIRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Ydb.Discovery.IWhoAmIRequest} message WhoAmIRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WhoAmIRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.WhoAmIRequest} WhoAmIRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.WhoAmIRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.includeGroups = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WhoAmIRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.WhoAmIRequest} WhoAmIRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WhoAmIRequest message.
             * @function verify
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WhoAmIRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.includeGroups != null && message.hasOwnProperty("includeGroups"))
                    if (typeof message.includeGroups !== "boolean")
                        return "includeGroups: boolean expected";
                return null;
            };

            /**
             * Creates a WhoAmIRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.WhoAmIRequest} WhoAmIRequest
             */
            WhoAmIRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.WhoAmIRequest)
                    return object;
                var message = new $root.Ydb.Discovery.WhoAmIRequest();
                if (object.includeGroups != null)
                    message.includeGroups = Boolean(object.includeGroups);
                return message;
            };

            /**
             * Creates a plain object from a WhoAmIRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Ydb.Discovery.WhoAmIRequest} message WhoAmIRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WhoAmIRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.includeGroups = false;
                if (message.includeGroups != null && message.hasOwnProperty("includeGroups"))
                    object.includeGroups = message.includeGroups;
                return object;
            };

            /**
             * Converts this WhoAmIRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WhoAmIRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WhoAmIRequest;
        })();

        Discovery.WhoAmIResult = (function() {

            /**
             * Properties of a WhoAmIResult.
             * @memberof Ydb.Discovery
             * @interface IWhoAmIResult
             * @property {string|null} [user] WhoAmIResult user
             * @property {Array.<string>|null} [groups] WhoAmIResult groups
             */

            /**
             * Constructs a new WhoAmIResult.
             * @memberof Ydb.Discovery
             * @classdesc Represents a WhoAmIResult.
             * @implements IWhoAmIResult
             * @constructor
             * @param {Ydb.Discovery.IWhoAmIResult=} [properties] Properties to set
             */
            function WhoAmIResult(properties) {
                this.groups = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WhoAmIResult user.
             * @member {string} user
             * @memberof Ydb.Discovery.WhoAmIResult
             * @instance
             */
            WhoAmIResult.prototype.user = "";

            /**
             * WhoAmIResult groups.
             * @member {Array.<string>} groups
             * @memberof Ydb.Discovery.WhoAmIResult
             * @instance
             */
            WhoAmIResult.prototype.groups = $util.emptyArray;

            /**
             * Creates a new WhoAmIResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Ydb.Discovery.IWhoAmIResult=} [properties] Properties to set
             * @returns {Ydb.Discovery.WhoAmIResult} WhoAmIResult instance
             */
            WhoAmIResult.create = function create(properties) {
                return new WhoAmIResult(properties);
            };

            /**
             * Encodes the specified WhoAmIResult message. Does not implicitly {@link Ydb.Discovery.WhoAmIResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Ydb.Discovery.IWhoAmIResult} message WhoAmIResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.user != null && message.hasOwnProperty("user"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.user);
                if (message.groups != null && message.groups.length)
                    for (var i = 0; i < message.groups.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.groups[i]);
                return writer;
            };

            /**
             * Encodes the specified WhoAmIResult message, length delimited. Does not implicitly {@link Ydb.Discovery.WhoAmIResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Ydb.Discovery.IWhoAmIResult} message WhoAmIResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WhoAmIResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.WhoAmIResult} WhoAmIResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.WhoAmIResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.user = reader.string();
                        break;
                    case 2:
                        if (!(message.groups && message.groups.length))
                            message.groups = [];
                        message.groups.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WhoAmIResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.WhoAmIResult} WhoAmIResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WhoAmIResult message.
             * @function verify
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WhoAmIResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.user != null && message.hasOwnProperty("user"))
                    if (!$util.isString(message.user))
                        return "user: string expected";
                if (message.groups != null && message.hasOwnProperty("groups")) {
                    if (!Array.isArray(message.groups))
                        return "groups: array expected";
                    for (var i = 0; i < message.groups.length; ++i)
                        if (!$util.isString(message.groups[i]))
                            return "groups: string[] expected";
                }
                return null;
            };

            /**
             * Creates a WhoAmIResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.WhoAmIResult} WhoAmIResult
             */
            WhoAmIResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.WhoAmIResult)
                    return object;
                var message = new $root.Ydb.Discovery.WhoAmIResult();
                if (object.user != null)
                    message.user = String(object.user);
                if (object.groups) {
                    if (!Array.isArray(object.groups))
                        throw TypeError(".Ydb.Discovery.WhoAmIResult.groups: array expected");
                    message.groups = [];
                    for (var i = 0; i < object.groups.length; ++i)
                        message.groups[i] = String(object.groups[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WhoAmIResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Ydb.Discovery.WhoAmIResult} message WhoAmIResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WhoAmIResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groups = [];
                if (options.defaults)
                    object.user = "";
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = message.user;
                if (message.groups && message.groups.length) {
                    object.groups = [];
                    for (var j = 0; j < message.groups.length; ++j)
                        object.groups[j] = message.groups[j];
                }
                return object;
            };

            /**
             * Converts this WhoAmIResult to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.WhoAmIResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WhoAmIResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WhoAmIResult;
        })();

        Discovery.WhoAmIResponse = (function() {

            /**
             * Properties of a WhoAmIResponse.
             * @memberof Ydb.Discovery
             * @interface IWhoAmIResponse
             * @property {Ydb.Operations.IOperation|null} [operation] WhoAmIResponse operation
             */

            /**
             * Constructs a new WhoAmIResponse.
             * @memberof Ydb.Discovery
             * @classdesc Represents a WhoAmIResponse.
             * @implements IWhoAmIResponse
             * @constructor
             * @param {Ydb.Discovery.IWhoAmIResponse=} [properties] Properties to set
             */
            function WhoAmIResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WhoAmIResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @instance
             */
            WhoAmIResponse.prototype.operation = null;

            /**
             * Creates a new WhoAmIResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Ydb.Discovery.IWhoAmIResponse=} [properties] Properties to set
             * @returns {Ydb.Discovery.WhoAmIResponse} WhoAmIResponse instance
             */
            WhoAmIResponse.create = function create(properties) {
                return new WhoAmIResponse(properties);
            };

            /**
             * Encodes the specified WhoAmIResponse message. Does not implicitly {@link Ydb.Discovery.WhoAmIResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Ydb.Discovery.IWhoAmIResponse} message WhoAmIResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WhoAmIResponse message, length delimited. Does not implicitly {@link Ydb.Discovery.WhoAmIResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Ydb.Discovery.IWhoAmIResponse} message WhoAmIResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WhoAmIResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.WhoAmIResponse} WhoAmIResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.WhoAmIResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WhoAmIResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.WhoAmIResponse} WhoAmIResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WhoAmIResponse message.
             * @function verify
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WhoAmIResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a WhoAmIResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.WhoAmIResponse} WhoAmIResponse
             */
            WhoAmIResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.WhoAmIResponse)
                    return object;
                var message = new $root.Ydb.Discovery.WhoAmIResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Discovery.WhoAmIResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a WhoAmIResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Ydb.Discovery.WhoAmIResponse} message WhoAmIResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WhoAmIResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this WhoAmIResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WhoAmIResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WhoAmIResponse;
        })();

        return Discovery;
    })();

    Ydb.Export = (function() {

        /**
         * Namespace Export.
         * @memberof Ydb
         * @namespace
         */
        var Export = {};

        Export.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Export
             * @namespace
             */
            var V1 = {};

            V1.ExportService = (function() {

                /**
                 * Constructs a new ExportService service.
                 * @memberof Ydb.Export.V1
                 * @classdesc Represents an ExportService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ExportService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (ExportService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ExportService;

                /**
                 * Creates new ExportService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Export.V1.ExportService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {ExportService} RPC service. Useful where requests and/or responses are streamed.
                 */
                ExportService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Export.V1.ExportService#exportToYt}.
                 * @memberof Ydb.Export.V1.ExportService
                 * @typedef ExportToYtCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Export.ExportToYtResponse} [response] ExportToYtResponse
                 */

                /**
                 * Calls ExportToYt.
                 * @function exportToYt
                 * @memberof Ydb.Export.V1.ExportService
                 * @instance
                 * @param {Ydb.Export.IExportToYtRequest} request ExportToYtRequest message or plain object
                 * @param {Ydb.Export.V1.ExportService.ExportToYtCallback} callback Node-style callback called with the error, if any, and ExportToYtResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ExportService.prototype.exportToYt = function exportToYt(request, callback) {
                    return this.rpcCall(exportToYt, $root.Ydb.Export.ExportToYtRequest, $root.Ydb.Export.ExportToYtResponse, request, callback);
                }, "name", { value: "ExportToYt" });

                /**
                 * Calls ExportToYt.
                 * @function exportToYt
                 * @memberof Ydb.Export.V1.ExportService
                 * @instance
                 * @param {Ydb.Export.IExportToYtRequest} request ExportToYtRequest message or plain object
                 * @returns {Promise<Ydb.Export.ExportToYtResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Export.V1.ExportService#exportToS3}.
                 * @memberof Ydb.Export.V1.ExportService
                 * @typedef ExportToS3Callback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Export.ExportToS3Response} [response] ExportToS3Response
                 */

                /**
                 * Calls ExportToS3.
                 * @function exportToS3
                 * @memberof Ydb.Export.V1.ExportService
                 * @instance
                 * @param {Ydb.Export.IExportToS3Request} request ExportToS3Request message or plain object
                 * @param {Ydb.Export.V1.ExportService.ExportToS3Callback} callback Node-style callback called with the error, if any, and ExportToS3Response
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ExportService.prototype.exportToS3 = function exportToS3(request, callback) {
                    return this.rpcCall(exportToS3, $root.Ydb.Export.ExportToS3Request, $root.Ydb.Export.ExportToS3Response, request, callback);
                }, "name", { value: "ExportToS3" });

                /**
                 * Calls ExportToS3.
                 * @function exportToS3
                 * @memberof Ydb.Export.V1.ExportService
                 * @instance
                 * @param {Ydb.Export.IExportToS3Request} request ExportToS3Request message or plain object
                 * @returns {Promise<Ydb.Export.ExportToS3Response>} Promise
                 * @variation 2
                 */

                return ExportService;
            })();

            return V1;
        })();

        Export.ExportProgress = (function() {

            /**
             * Properties of an ExportProgress.
             * @memberof Ydb.Export
             * @interface IExportProgress
             */

            /**
             * Constructs a new ExportProgress.
             * @memberof Ydb.Export
             * @classdesc Common
             * @implements IExportProgress
             * @constructor
             * @param {Ydb.Export.IExportProgress=} [properties] Properties to set
             */
            function ExportProgress(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ExportProgress instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportProgress
             * @static
             * @param {Ydb.Export.IExportProgress=} [properties] Properties to set
             * @returns {Ydb.Export.ExportProgress} ExportProgress instance
             */
            ExportProgress.create = function create(properties) {
                return new ExportProgress(properties);
            };

            /**
             * Encodes the specified ExportProgress message. Does not implicitly {@link Ydb.Export.ExportProgress.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportProgress
             * @static
             * @param {Ydb.Export.IExportProgress} message ExportProgress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportProgress.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ExportProgress message, length delimited. Does not implicitly {@link Ydb.Export.ExportProgress.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportProgress
             * @static
             * @param {Ydb.Export.IExportProgress} message ExportProgress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportProgress.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportProgress message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportProgress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportProgress} ExportProgress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportProgress.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportProgress();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportProgress message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportProgress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportProgress} ExportProgress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportProgress.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportProgress message.
             * @function verify
             * @memberof Ydb.Export.ExportProgress
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportProgress.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ExportProgress message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportProgress
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportProgress} ExportProgress
             */
            ExportProgress.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportProgress)
                    return object;
                return new $root.Ydb.Export.ExportProgress();
            };

            /**
             * Creates a plain object from an ExportProgress message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportProgress
             * @static
             * @param {Ydb.Export.ExportProgress} message ExportProgress
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportProgress.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ExportProgress to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportProgress
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportProgress.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Progress enum.
             * @name Ydb.Export.ExportProgress.Progress
             * @enum {string}
             * @property {number} PROGRESS_UNSPECIFIED=0 PROGRESS_UNSPECIFIED value
             * @property {number} PROGRESS_PREPARING=1 PROGRESS_PREPARING value
             * @property {number} PROGRESS_TRANSFER_DATA=2 PROGRESS_TRANSFER_DATA value
             * @property {number} PROGRESS_DONE=3 PROGRESS_DONE value
             * @property {number} PROGRESS_CANCELLATION=4 PROGRESS_CANCELLATION value
             * @property {number} PROGRESS_CANCELLED=5 PROGRESS_CANCELLED value
             */
            ExportProgress.Progress = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PROGRESS_UNSPECIFIED"] = 0;
                values[valuesById[1] = "PROGRESS_PREPARING"] = 1;
                values[valuesById[2] = "PROGRESS_TRANSFER_DATA"] = 2;
                values[valuesById[3] = "PROGRESS_DONE"] = 3;
                values[valuesById[4] = "PROGRESS_CANCELLATION"] = 4;
                values[valuesById[5] = "PROGRESS_CANCELLED"] = 5;
                return values;
            })();

            return ExportProgress;
        })();

        Export.ExportToYtSettings = (function() {

            /**
             * Properties of an ExportToYtSettings.
             * @memberof Ydb.Export
             * @interface IExportToYtSettings
             * @property {string|null} [host] ExportToYtSettings host
             * @property {number|null} [port] ExportToYtSettings port
             * @property {string|null} [token] ExportToYtSettings token
             * @property {Array.<Ydb.Export.ExportToYtSettings.IItem>|null} [items] ExportToYtSettings items
             * @property {string|null} [description] ExportToYtSettings description
             * @property {number|null} [numberOfRetries] ExportToYtSettings numberOfRetries
             * @property {boolean|null} [useTypeV3] ExportToYtSettings useTypeV3
             */

            /**
             * Constructs a new ExportToYtSettings.
             * @memberof Ydb.Export
             * @classdesc YT
             * @implements IExportToYtSettings
             * @constructor
             * @param {Ydb.Export.IExportToYtSettings=} [properties] Properties to set
             */
            function ExportToYtSettings(properties) {
                this.items = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExportToYtSettings host.
             * @member {string} host
             * @memberof Ydb.Export.ExportToYtSettings
             * @instance
             */
            ExportToYtSettings.prototype.host = "";

            /**
             * ExportToYtSettings port.
             * @member {number} port
             * @memberof Ydb.Export.ExportToYtSettings
             * @instance
             */
            ExportToYtSettings.prototype.port = 0;

            /**
             * ExportToYtSettings token.
             * @member {string} token
             * @memberof Ydb.Export.ExportToYtSettings
             * @instance
             */
            ExportToYtSettings.prototype.token = "";

            /**
             * ExportToYtSettings items.
             * @member {Array.<Ydb.Export.ExportToYtSettings.IItem>} items
             * @memberof Ydb.Export.ExportToYtSettings
             * @instance
             */
            ExportToYtSettings.prototype.items = $util.emptyArray;

            /**
             * ExportToYtSettings description.
             * @member {string} description
             * @memberof Ydb.Export.ExportToYtSettings
             * @instance
             */
            ExportToYtSettings.prototype.description = "";

            /**
             * ExportToYtSettings numberOfRetries.
             * @member {number} numberOfRetries
             * @memberof Ydb.Export.ExportToYtSettings
             * @instance
             */
            ExportToYtSettings.prototype.numberOfRetries = 0;

            /**
             * ExportToYtSettings useTypeV3.
             * @member {boolean} useTypeV3
             * @memberof Ydb.Export.ExportToYtSettings
             * @instance
             */
            ExportToYtSettings.prototype.useTypeV3 = false;

            /**
             * Creates a new ExportToYtSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToYtSettings
             * @static
             * @param {Ydb.Export.IExportToYtSettings=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToYtSettings} ExportToYtSettings instance
             */
            ExportToYtSettings.create = function create(properties) {
                return new ExportToYtSettings(properties);
            };

            /**
             * Encodes the specified ExportToYtSettings message. Does not implicitly {@link Ydb.Export.ExportToYtSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToYtSettings
             * @static
             * @param {Ydb.Export.IExportToYtSettings} message ExportToYtSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.token != null && message.hasOwnProperty("token"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.token);
                if (message.items != null && message.items.length)
                    for (var i = 0; i < message.items.length; ++i)
                        $root.Ydb.Export.ExportToYtSettings.Item.encode(message.items[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                if (message.numberOfRetries != null && message.hasOwnProperty("numberOfRetries"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.numberOfRetries);
                if (message.useTypeV3 != null && message.hasOwnProperty("useTypeV3"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.useTypeV3);
                return writer;
            };

            /**
             * Encodes the specified ExportToYtSettings message, length delimited. Does not implicitly {@link Ydb.Export.ExportToYtSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToYtSettings
             * @static
             * @param {Ydb.Export.IExportToYtSettings} message ExportToYtSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToYtSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToYtSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToYtSettings} ExportToYtSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToYtSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.host = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.token = reader.string();
                        break;
                    case 4:
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.Ydb.Export.ExportToYtSettings.Item.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.description = reader.string();
                        break;
                    case 6:
                        message.numberOfRetries = reader.uint32();
                        break;
                    case 7:
                        message.useTypeV3 = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToYtSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToYtSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToYtSettings} ExportToYtSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToYtSettings message.
             * @function verify
             * @memberof Ydb.Export.ExportToYtSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToYtSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.items != null && message.hasOwnProperty("items")) {
                    if (!Array.isArray(message.items))
                        return "items: array expected";
                    for (var i = 0; i < message.items.length; ++i) {
                        var error = $root.Ydb.Export.ExportToYtSettings.Item.verify(message.items[i]);
                        if (error)
                            return "items." + error;
                    }
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.numberOfRetries != null && message.hasOwnProperty("numberOfRetries"))
                    if (!$util.isInteger(message.numberOfRetries))
                        return "numberOfRetries: integer expected";
                if (message.useTypeV3 != null && message.hasOwnProperty("useTypeV3"))
                    if (typeof message.useTypeV3 !== "boolean")
                        return "useTypeV3: boolean expected";
                return null;
            };

            /**
             * Creates an ExportToYtSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToYtSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToYtSettings} ExportToYtSettings
             */
            ExportToYtSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToYtSettings)
                    return object;
                var message = new $root.Ydb.Export.ExportToYtSettings();
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.token != null)
                    message.token = String(object.token);
                if (object.items) {
                    if (!Array.isArray(object.items))
                        throw TypeError(".Ydb.Export.ExportToYtSettings.items: array expected");
                    message.items = [];
                    for (var i = 0; i < object.items.length; ++i) {
                        if (typeof object.items[i] !== "object")
                            throw TypeError(".Ydb.Export.ExportToYtSettings.items: object expected");
                        message.items[i] = $root.Ydb.Export.ExportToYtSettings.Item.fromObject(object.items[i]);
                    }
                }
                if (object.description != null)
                    message.description = String(object.description);
                if (object.numberOfRetries != null)
                    message.numberOfRetries = object.numberOfRetries >>> 0;
                if (object.useTypeV3 != null)
                    message.useTypeV3 = Boolean(object.useTypeV3);
                return message;
            };

            /**
             * Creates a plain object from an ExportToYtSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToYtSettings
             * @static
             * @param {Ydb.Export.ExportToYtSettings} message ExportToYtSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToYtSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.items = [];
                if (options.defaults) {
                    object.host = "";
                    object.port = 0;
                    object.token = "";
                    object.description = "";
                    object.numberOfRetries = 0;
                    object.useTypeV3 = false;
                }
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.items && message.items.length) {
                    object.items = [];
                    for (var j = 0; j < message.items.length; ++j)
                        object.items[j] = $root.Ydb.Export.ExportToYtSettings.Item.toObject(message.items[j], options);
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.numberOfRetries != null && message.hasOwnProperty("numberOfRetries"))
                    object.numberOfRetries = message.numberOfRetries;
                if (message.useTypeV3 != null && message.hasOwnProperty("useTypeV3"))
                    object.useTypeV3 = message.useTypeV3;
                return object;
            };

            /**
             * Converts this ExportToYtSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToYtSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToYtSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ExportToYtSettings.Item = (function() {

                /**
                 * Properties of an Item.
                 * @memberof Ydb.Export.ExportToYtSettings
                 * @interface IItem
                 * @property {string|null} [sourcePath] Item sourcePath
                 * @property {string|null} [destinationPath] Item destinationPath
                 */

                /**
                 * Constructs a new Item.
                 * @memberof Ydb.Export.ExportToYtSettings
                 * @classdesc Represents an Item.
                 * @implements IItem
                 * @constructor
                 * @param {Ydb.Export.ExportToYtSettings.IItem=} [properties] Properties to set
                 */
                function Item(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Item sourcePath.
                 * @member {string} sourcePath
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @instance
                 */
                Item.prototype.sourcePath = "";

                /**
                 * Item destinationPath.
                 * @member {string} destinationPath
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @instance
                 */
                Item.prototype.destinationPath = "";

                /**
                 * Creates a new Item instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @static
                 * @param {Ydb.Export.ExportToYtSettings.IItem=} [properties] Properties to set
                 * @returns {Ydb.Export.ExportToYtSettings.Item} Item instance
                 */
                Item.create = function create(properties) {
                    return new Item(properties);
                };

                /**
                 * Encodes the specified Item message. Does not implicitly {@link Ydb.Export.ExportToYtSettings.Item.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @static
                 * @param {Ydb.Export.ExportToYtSettings.IItem} message Item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Item.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sourcePath);
                    if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.destinationPath);
                    return writer;
                };

                /**
                 * Encodes the specified Item message, length delimited. Does not implicitly {@link Ydb.Export.ExportToYtSettings.Item.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @static
                 * @param {Ydb.Export.ExportToYtSettings.IItem} message Item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Item.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Item message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Export.ExportToYtSettings.Item} Item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Item.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToYtSettings.Item();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sourcePath = reader.string();
                            break;
                        case 2:
                            message.destinationPath = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Item message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Export.ExportToYtSettings.Item} Item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Item.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Item message.
                 * @function verify
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Item.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                        if (!$util.isString(message.sourcePath))
                            return "sourcePath: string expected";
                    if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                        if (!$util.isString(message.destinationPath))
                            return "destinationPath: string expected";
                    return null;
                };

                /**
                 * Creates an Item message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Export.ExportToYtSettings.Item} Item
                 */
                Item.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Export.ExportToYtSettings.Item)
                        return object;
                    var message = new $root.Ydb.Export.ExportToYtSettings.Item();
                    if (object.sourcePath != null)
                        message.sourcePath = String(object.sourcePath);
                    if (object.destinationPath != null)
                        message.destinationPath = String(object.destinationPath);
                    return message;
                };

                /**
                 * Creates a plain object from an Item message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @static
                 * @param {Ydb.Export.ExportToYtSettings.Item} message Item
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Item.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sourcePath = "";
                        object.destinationPath = "";
                    }
                    if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                        object.sourcePath = message.sourcePath;
                    if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                        object.destinationPath = message.destinationPath;
                    return object;
                };

                /**
                 * Converts this Item to JSON.
                 * @function toJSON
                 * @memberof Ydb.Export.ExportToYtSettings.Item
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Item.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Item;
            })();

            return ExportToYtSettings;
        })();

        Export.ExportToYtResult = (function() {

            /**
             * Properties of an ExportToYtResult.
             * @memberof Ydb.Export
             * @interface IExportToYtResult
             */

            /**
             * Constructs a new ExportToYtResult.
             * @memberof Ydb.Export
             * @classdesc Represents an ExportToYtResult.
             * @implements IExportToYtResult
             * @constructor
             * @param {Ydb.Export.IExportToYtResult=} [properties] Properties to set
             */
            function ExportToYtResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ExportToYtResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToYtResult
             * @static
             * @param {Ydb.Export.IExportToYtResult=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToYtResult} ExportToYtResult instance
             */
            ExportToYtResult.create = function create(properties) {
                return new ExportToYtResult(properties);
            };

            /**
             * Encodes the specified ExportToYtResult message. Does not implicitly {@link Ydb.Export.ExportToYtResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToYtResult
             * @static
             * @param {Ydb.Export.IExportToYtResult} message ExportToYtResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ExportToYtResult message, length delimited. Does not implicitly {@link Ydb.Export.ExportToYtResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToYtResult
             * @static
             * @param {Ydb.Export.IExportToYtResult} message ExportToYtResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToYtResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToYtResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToYtResult} ExportToYtResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToYtResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToYtResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToYtResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToYtResult} ExportToYtResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToYtResult message.
             * @function verify
             * @memberof Ydb.Export.ExportToYtResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToYtResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ExportToYtResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToYtResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToYtResult} ExportToYtResult
             */
            ExportToYtResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToYtResult)
                    return object;
                return new $root.Ydb.Export.ExportToYtResult();
            };

            /**
             * Creates a plain object from an ExportToYtResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToYtResult
             * @static
             * @param {Ydb.Export.ExportToYtResult} message ExportToYtResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToYtResult.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ExportToYtResult to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToYtResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToYtResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExportToYtResult;
        })();

        Export.ExportToYtMetadata = (function() {

            /**
             * Properties of an ExportToYtMetadata.
             * @memberof Ydb.Export
             * @interface IExportToYtMetadata
             * @property {Ydb.Export.IExportToYtSettings|null} [settings] ExportToYtMetadata settings
             * @property {Ydb.Export.ExportProgress.Progress|null} [progress] ExportToYtMetadata progress
             */

            /**
             * Constructs a new ExportToYtMetadata.
             * @memberof Ydb.Export
             * @classdesc Represents an ExportToYtMetadata.
             * @implements IExportToYtMetadata
             * @constructor
             * @param {Ydb.Export.IExportToYtMetadata=} [properties] Properties to set
             */
            function ExportToYtMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExportToYtMetadata settings.
             * @member {Ydb.Export.IExportToYtSettings|null|undefined} settings
             * @memberof Ydb.Export.ExportToYtMetadata
             * @instance
             */
            ExportToYtMetadata.prototype.settings = null;

            /**
             * ExportToYtMetadata progress.
             * @member {Ydb.Export.ExportProgress.Progress} progress
             * @memberof Ydb.Export.ExportToYtMetadata
             * @instance
             */
            ExportToYtMetadata.prototype.progress = 0;

            /**
             * Creates a new ExportToYtMetadata instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToYtMetadata
             * @static
             * @param {Ydb.Export.IExportToYtMetadata=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToYtMetadata} ExportToYtMetadata instance
             */
            ExportToYtMetadata.create = function create(properties) {
                return new ExportToYtMetadata(properties);
            };

            /**
             * Encodes the specified ExportToYtMetadata message. Does not implicitly {@link Ydb.Export.ExportToYtMetadata.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToYtMetadata
             * @static
             * @param {Ydb.Export.IExportToYtMetadata} message ExportToYtMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.settings != null && message.hasOwnProperty("settings"))
                    $root.Ydb.Export.ExportToYtSettings.encode(message.settings, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.progress != null && message.hasOwnProperty("progress"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.progress);
                return writer;
            };

            /**
             * Encodes the specified ExportToYtMetadata message, length delimited. Does not implicitly {@link Ydb.Export.ExportToYtMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToYtMetadata
             * @static
             * @param {Ydb.Export.IExportToYtMetadata} message ExportToYtMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToYtMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToYtMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToYtMetadata} ExportToYtMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToYtMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.settings = $root.Ydb.Export.ExportToYtSettings.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.progress = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToYtMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToYtMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToYtMetadata} ExportToYtMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToYtMetadata message.
             * @function verify
             * @memberof Ydb.Export.ExportToYtMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToYtMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    var error = $root.Ydb.Export.ExportToYtSettings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                if (message.progress != null && message.hasOwnProperty("progress"))
                    switch (message.progress) {
                    default:
                        return "progress: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                return null;
            };

            /**
             * Creates an ExportToYtMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToYtMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToYtMetadata} ExportToYtMetadata
             */
            ExportToYtMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToYtMetadata)
                    return object;
                var message = new $root.Ydb.Export.ExportToYtMetadata();
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".Ydb.Export.ExportToYtMetadata.settings: object expected");
                    message.settings = $root.Ydb.Export.ExportToYtSettings.fromObject(object.settings);
                }
                switch (object.progress) {
                case "PROGRESS_UNSPECIFIED":
                case 0:
                    message.progress = 0;
                    break;
                case "PROGRESS_PREPARING":
                case 1:
                    message.progress = 1;
                    break;
                case "PROGRESS_TRANSFER_DATA":
                case 2:
                    message.progress = 2;
                    break;
                case "PROGRESS_DONE":
                case 3:
                    message.progress = 3;
                    break;
                case "PROGRESS_CANCELLATION":
                case 4:
                    message.progress = 4;
                    break;
                case "PROGRESS_CANCELLED":
                case 5:
                    message.progress = 5;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ExportToYtMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToYtMetadata
             * @static
             * @param {Ydb.Export.ExportToYtMetadata} message ExportToYtMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToYtMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.settings = null;
                    object.progress = options.enums === String ? "PROGRESS_UNSPECIFIED" : 0;
                }
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.Ydb.Export.ExportToYtSettings.toObject(message.settings, options);
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = options.enums === String ? $root.Ydb.Export.ExportProgress.Progress[message.progress] : message.progress;
                return object;
            };

            /**
             * Converts this ExportToYtMetadata to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToYtMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToYtMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExportToYtMetadata;
        })();

        Export.ExportToYtRequest = (function() {

            /**
             * Properties of an ExportToYtRequest.
             * @memberof Ydb.Export
             * @interface IExportToYtRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExportToYtRequest operationParams
             * @property {Ydb.Export.IExportToYtSettings|null} [settings] ExportToYtRequest settings
             */

            /**
             * Constructs a new ExportToYtRequest.
             * @memberof Ydb.Export
             * @classdesc Represents an ExportToYtRequest.
             * @implements IExportToYtRequest
             * @constructor
             * @param {Ydb.Export.IExportToYtRequest=} [properties] Properties to set
             */
            function ExportToYtRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExportToYtRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Export.ExportToYtRequest
             * @instance
             */
            ExportToYtRequest.prototype.operationParams = null;

            /**
             * ExportToYtRequest settings.
             * @member {Ydb.Export.IExportToYtSettings|null|undefined} settings
             * @memberof Ydb.Export.ExportToYtRequest
             * @instance
             */
            ExportToYtRequest.prototype.settings = null;

            /**
             * Creates a new ExportToYtRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToYtRequest
             * @static
             * @param {Ydb.Export.IExportToYtRequest=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToYtRequest} ExportToYtRequest instance
             */
            ExportToYtRequest.create = function create(properties) {
                return new ExportToYtRequest(properties);
            };

            /**
             * Encodes the specified ExportToYtRequest message. Does not implicitly {@link Ydb.Export.ExportToYtRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToYtRequest
             * @static
             * @param {Ydb.Export.IExportToYtRequest} message ExportToYtRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.settings != null && message.hasOwnProperty("settings"))
                    $root.Ydb.Export.ExportToYtSettings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExportToYtRequest message, length delimited. Does not implicitly {@link Ydb.Export.ExportToYtRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToYtRequest
             * @static
             * @param {Ydb.Export.IExportToYtRequest} message ExportToYtRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToYtRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToYtRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToYtRequest} ExportToYtRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToYtRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.settings = $root.Ydb.Export.ExportToYtSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToYtRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToYtRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToYtRequest} ExportToYtRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToYtRequest message.
             * @function verify
             * @memberof Ydb.Export.ExportToYtRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToYtRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    var error = $root.Ydb.Export.ExportToYtSettings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                return null;
            };

            /**
             * Creates an ExportToYtRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToYtRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToYtRequest} ExportToYtRequest
             */
            ExportToYtRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToYtRequest)
                    return object;
                var message = new $root.Ydb.Export.ExportToYtRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Export.ExportToYtRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".Ydb.Export.ExportToYtRequest.settings: object expected");
                    message.settings = $root.Ydb.Export.ExportToYtSettings.fromObject(object.settings);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExportToYtRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToYtRequest
             * @static
             * @param {Ydb.Export.ExportToYtRequest} message ExportToYtRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToYtRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.settings = null;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.Ydb.Export.ExportToYtSettings.toObject(message.settings, options);
                return object;
            };

            /**
             * Converts this ExportToYtRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToYtRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToYtRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExportToYtRequest;
        })();

        Export.ExportToYtResponse = (function() {

            /**
             * Properties of an ExportToYtResponse.
             * @memberof Ydb.Export
             * @interface IExportToYtResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExportToYtResponse operation
             */

            /**
             * Constructs a new ExportToYtResponse.
             * @memberof Ydb.Export
             * @classdesc Represents an ExportToYtResponse.
             * @implements IExportToYtResponse
             * @constructor
             * @param {Ydb.Export.IExportToYtResponse=} [properties] Properties to set
             */
            function ExportToYtResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExportToYtResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Export.ExportToYtResponse
             * @instance
             */
            ExportToYtResponse.prototype.operation = null;

            /**
             * Creates a new ExportToYtResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToYtResponse
             * @static
             * @param {Ydb.Export.IExportToYtResponse=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToYtResponse} ExportToYtResponse instance
             */
            ExportToYtResponse.create = function create(properties) {
                return new ExportToYtResponse(properties);
            };

            /**
             * Encodes the specified ExportToYtResponse message. Does not implicitly {@link Ydb.Export.ExportToYtResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToYtResponse
             * @static
             * @param {Ydb.Export.IExportToYtResponse} message ExportToYtResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExportToYtResponse message, length delimited. Does not implicitly {@link Ydb.Export.ExportToYtResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToYtResponse
             * @static
             * @param {Ydb.Export.IExportToYtResponse} message ExportToYtResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToYtResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToYtResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToYtResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToYtResponse} ExportToYtResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToYtResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToYtResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToYtResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToYtResponse} ExportToYtResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToYtResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToYtResponse message.
             * @function verify
             * @memberof Ydb.Export.ExportToYtResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToYtResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExportToYtResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToYtResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToYtResponse} ExportToYtResponse
             */
            ExportToYtResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToYtResponse)
                    return object;
                var message = new $root.Ydb.Export.ExportToYtResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Export.ExportToYtResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExportToYtResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToYtResponse
             * @static
             * @param {Ydb.Export.ExportToYtResponse} message ExportToYtResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToYtResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExportToYtResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToYtResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToYtResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExportToYtResponse;
        })();

        Export.ExportToS3Settings = (function() {

            /**
             * Properties of an ExportToS3Settings.
             * @memberof Ydb.Export
             * @interface IExportToS3Settings
             * @property {string|null} [endpoint] ExportToS3Settings endpoint
             * @property {Ydb.Export.ExportToS3Settings.Scheme|null} [scheme] ExportToS3Settings scheme
             * @property {string|null} [bucket] ExportToS3Settings bucket
             * @property {string|null} [accessKey] ExportToS3Settings accessKey
             * @property {string|null} [secretKey] ExportToS3Settings secretKey
             * @property {Array.<Ydb.Export.ExportToS3Settings.IItem>|null} [items] ExportToS3Settings items
             * @property {string|null} [description] ExportToS3Settings description
             * @property {number|null} [numberOfRetries] ExportToS3Settings numberOfRetries
             */

            /**
             * Constructs a new ExportToS3Settings.
             * @memberof Ydb.Export
             * @classdesc S3
             * @implements IExportToS3Settings
             * @constructor
             * @param {Ydb.Export.IExportToS3Settings=} [properties] Properties to set
             */
            function ExportToS3Settings(properties) {
                this.items = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExportToS3Settings endpoint.
             * @member {string} endpoint
             * @memberof Ydb.Export.ExportToS3Settings
             * @instance
             */
            ExportToS3Settings.prototype.endpoint = "";

            /**
             * ExportToS3Settings scheme.
             * @member {Ydb.Export.ExportToS3Settings.Scheme} scheme
             * @memberof Ydb.Export.ExportToS3Settings
             * @instance
             */
            ExportToS3Settings.prototype.scheme = 0;

            /**
             * ExportToS3Settings bucket.
             * @member {string} bucket
             * @memberof Ydb.Export.ExportToS3Settings
             * @instance
             */
            ExportToS3Settings.prototype.bucket = "";

            /**
             * ExportToS3Settings accessKey.
             * @member {string} accessKey
             * @memberof Ydb.Export.ExportToS3Settings
             * @instance
             */
            ExportToS3Settings.prototype.accessKey = "";

            /**
             * ExportToS3Settings secretKey.
             * @member {string} secretKey
             * @memberof Ydb.Export.ExportToS3Settings
             * @instance
             */
            ExportToS3Settings.prototype.secretKey = "";

            /**
             * ExportToS3Settings items.
             * @member {Array.<Ydb.Export.ExportToS3Settings.IItem>} items
             * @memberof Ydb.Export.ExportToS3Settings
             * @instance
             */
            ExportToS3Settings.prototype.items = $util.emptyArray;

            /**
             * ExportToS3Settings description.
             * @member {string} description
             * @memberof Ydb.Export.ExportToS3Settings
             * @instance
             */
            ExportToS3Settings.prototype.description = "";

            /**
             * ExportToS3Settings numberOfRetries.
             * @member {number} numberOfRetries
             * @memberof Ydb.Export.ExportToS3Settings
             * @instance
             */
            ExportToS3Settings.prototype.numberOfRetries = 0;

            /**
             * Creates a new ExportToS3Settings instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToS3Settings
             * @static
             * @param {Ydb.Export.IExportToS3Settings=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToS3Settings} ExportToS3Settings instance
             */
            ExportToS3Settings.create = function create(properties) {
                return new ExportToS3Settings(properties);
            };

            /**
             * Encodes the specified ExportToS3Settings message. Does not implicitly {@link Ydb.Export.ExportToS3Settings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToS3Settings
             * @static
             * @param {Ydb.Export.IExportToS3Settings} message ExportToS3Settings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Settings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endpoint != null && message.hasOwnProperty("endpoint"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.endpoint);
                if (message.scheme != null && message.hasOwnProperty("scheme"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.scheme);
                if (message.bucket != null && message.hasOwnProperty("bucket"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.bucket);
                if (message.accessKey != null && message.hasOwnProperty("accessKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.accessKey);
                if (message.secretKey != null && message.hasOwnProperty("secretKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.secretKey);
                if (message.items != null && message.items.length)
                    for (var i = 0; i < message.items.length; ++i)
                        $root.Ydb.Export.ExportToS3Settings.Item.encode(message.items[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.description != null && message.hasOwnProperty("description"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
                if (message.numberOfRetries != null && message.hasOwnProperty("numberOfRetries"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.numberOfRetries);
                return writer;
            };

            /**
             * Encodes the specified ExportToS3Settings message, length delimited. Does not implicitly {@link Ydb.Export.ExportToS3Settings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToS3Settings
             * @static
             * @param {Ydb.Export.IExportToS3Settings} message ExportToS3Settings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Settings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToS3Settings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToS3Settings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToS3Settings} ExportToS3Settings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Settings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToS3Settings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.endpoint = reader.string();
                        break;
                    case 2:
                        message.scheme = reader.int32();
                        break;
                    case 3:
                        message.bucket = reader.string();
                        break;
                    case 4:
                        message.accessKey = reader.string();
                        break;
                    case 5:
                        message.secretKey = reader.string();
                        break;
                    case 6:
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.Ydb.Export.ExportToS3Settings.Item.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.description = reader.string();
                        break;
                    case 8:
                        message.numberOfRetries = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToS3Settings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToS3Settings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToS3Settings} ExportToS3Settings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Settings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToS3Settings message.
             * @function verify
             * @memberof Ydb.Export.ExportToS3Settings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToS3Settings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endpoint != null && message.hasOwnProperty("endpoint"))
                    if (!$util.isString(message.endpoint))
                        return "endpoint: string expected";
                if (message.scheme != null && message.hasOwnProperty("scheme"))
                    switch (message.scheme) {
                    default:
                        return "scheme: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.bucket != null && message.hasOwnProperty("bucket"))
                    if (!$util.isString(message.bucket))
                        return "bucket: string expected";
                if (message.accessKey != null && message.hasOwnProperty("accessKey"))
                    if (!$util.isString(message.accessKey))
                        return "accessKey: string expected";
                if (message.secretKey != null && message.hasOwnProperty("secretKey"))
                    if (!$util.isString(message.secretKey))
                        return "secretKey: string expected";
                if (message.items != null && message.hasOwnProperty("items")) {
                    if (!Array.isArray(message.items))
                        return "items: array expected";
                    for (var i = 0; i < message.items.length; ++i) {
                        var error = $root.Ydb.Export.ExportToS3Settings.Item.verify(message.items[i]);
                        if (error)
                            return "items." + error;
                    }
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.numberOfRetries != null && message.hasOwnProperty("numberOfRetries"))
                    if (!$util.isInteger(message.numberOfRetries))
                        return "numberOfRetries: integer expected";
                return null;
            };

            /**
             * Creates an ExportToS3Settings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToS3Settings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToS3Settings} ExportToS3Settings
             */
            ExportToS3Settings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToS3Settings)
                    return object;
                var message = new $root.Ydb.Export.ExportToS3Settings();
                if (object.endpoint != null)
                    message.endpoint = String(object.endpoint);
                switch (object.scheme) {
                case "UNSPECIFIED":
                case 0:
                    message.scheme = 0;
                    break;
                case "HTTP":
                case 1:
                    message.scheme = 1;
                    break;
                case "HTTPS":
                case 2:
                    message.scheme = 2;
                    break;
                }
                if (object.bucket != null)
                    message.bucket = String(object.bucket);
                if (object.accessKey != null)
                    message.accessKey = String(object.accessKey);
                if (object.secretKey != null)
                    message.secretKey = String(object.secretKey);
                if (object.items) {
                    if (!Array.isArray(object.items))
                        throw TypeError(".Ydb.Export.ExportToS3Settings.items: array expected");
                    message.items = [];
                    for (var i = 0; i < object.items.length; ++i) {
                        if (typeof object.items[i] !== "object")
                            throw TypeError(".Ydb.Export.ExportToS3Settings.items: object expected");
                        message.items[i] = $root.Ydb.Export.ExportToS3Settings.Item.fromObject(object.items[i]);
                    }
                }
                if (object.description != null)
                    message.description = String(object.description);
                if (object.numberOfRetries != null)
                    message.numberOfRetries = object.numberOfRetries >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an ExportToS3Settings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToS3Settings
             * @static
             * @param {Ydb.Export.ExportToS3Settings} message ExportToS3Settings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToS3Settings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.items = [];
                if (options.defaults) {
                    object.endpoint = "";
                    object.scheme = options.enums === String ? "UNSPECIFIED" : 0;
                    object.bucket = "";
                    object.accessKey = "";
                    object.secretKey = "";
                    object.description = "";
                    object.numberOfRetries = 0;
                }
                if (message.endpoint != null && message.hasOwnProperty("endpoint"))
                    object.endpoint = message.endpoint;
                if (message.scheme != null && message.hasOwnProperty("scheme"))
                    object.scheme = options.enums === String ? $root.Ydb.Export.ExportToS3Settings.Scheme[message.scheme] : message.scheme;
                if (message.bucket != null && message.hasOwnProperty("bucket"))
                    object.bucket = message.bucket;
                if (message.accessKey != null && message.hasOwnProperty("accessKey"))
                    object.accessKey = message.accessKey;
                if (message.secretKey != null && message.hasOwnProperty("secretKey"))
                    object.secretKey = message.secretKey;
                if (message.items && message.items.length) {
                    object.items = [];
                    for (var j = 0; j < message.items.length; ++j)
                        object.items[j] = $root.Ydb.Export.ExportToS3Settings.Item.toObject(message.items[j], options);
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.numberOfRetries != null && message.hasOwnProperty("numberOfRetries"))
                    object.numberOfRetries = message.numberOfRetries;
                return object;
            };

            /**
             * Converts this ExportToS3Settings to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToS3Settings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToS3Settings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Scheme enum.
             * @name Ydb.Export.ExportToS3Settings.Scheme
             * @enum {string}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} HTTP=1 HTTP value
             * @property {number} HTTPS=2 HTTPS value
             */
            ExportToS3Settings.Scheme = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "HTTP"] = 1;
                values[valuesById[2] = "HTTPS"] = 2;
                return values;
            })();

            ExportToS3Settings.Item = (function() {

                /**
                 * Properties of an Item.
                 * @memberof Ydb.Export.ExportToS3Settings
                 * @interface IItem
                 * @property {string|null} [sourcePath] Item sourcePath
                 * @property {string|null} [destinationPrefix] Item destinationPrefix
                 */

                /**
                 * Constructs a new Item.
                 * @memberof Ydb.Export.ExportToS3Settings
                 * @classdesc Represents an Item.
                 * @implements IItem
                 * @constructor
                 * @param {Ydb.Export.ExportToS3Settings.IItem=} [properties] Properties to set
                 */
                function Item(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Item sourcePath.
                 * @member {string} sourcePath
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @instance
                 */
                Item.prototype.sourcePath = "";

                /**
                 * Item destinationPrefix.
                 * @member {string} destinationPrefix
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @instance
                 */
                Item.prototype.destinationPrefix = "";

                /**
                 * Creates a new Item instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @static
                 * @param {Ydb.Export.ExportToS3Settings.IItem=} [properties] Properties to set
                 * @returns {Ydb.Export.ExportToS3Settings.Item} Item instance
                 */
                Item.create = function create(properties) {
                    return new Item(properties);
                };

                /**
                 * Encodes the specified Item message. Does not implicitly {@link Ydb.Export.ExportToS3Settings.Item.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @static
                 * @param {Ydb.Export.ExportToS3Settings.IItem} message Item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Item.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sourcePath);
                    if (message.destinationPrefix != null && message.hasOwnProperty("destinationPrefix"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.destinationPrefix);
                    return writer;
                };

                /**
                 * Encodes the specified Item message, length delimited. Does not implicitly {@link Ydb.Export.ExportToS3Settings.Item.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @static
                 * @param {Ydb.Export.ExportToS3Settings.IItem} message Item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Item.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Item message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Export.ExportToS3Settings.Item} Item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Item.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToS3Settings.Item();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sourcePath = reader.string();
                            break;
                        case 2:
                            message.destinationPrefix = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Item message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Export.ExportToS3Settings.Item} Item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Item.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Item message.
                 * @function verify
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Item.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                        if (!$util.isString(message.sourcePath))
                            return "sourcePath: string expected";
                    if (message.destinationPrefix != null && message.hasOwnProperty("destinationPrefix"))
                        if (!$util.isString(message.destinationPrefix))
                            return "destinationPrefix: string expected";
                    return null;
                };

                /**
                 * Creates an Item message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Export.ExportToS3Settings.Item} Item
                 */
                Item.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Export.ExportToS3Settings.Item)
                        return object;
                    var message = new $root.Ydb.Export.ExportToS3Settings.Item();
                    if (object.sourcePath != null)
                        message.sourcePath = String(object.sourcePath);
                    if (object.destinationPrefix != null)
                        message.destinationPrefix = String(object.destinationPrefix);
                    return message;
                };

                /**
                 * Creates a plain object from an Item message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @static
                 * @param {Ydb.Export.ExportToS3Settings.Item} message Item
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Item.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sourcePath = "";
                        object.destinationPrefix = "";
                    }
                    if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                        object.sourcePath = message.sourcePath;
                    if (message.destinationPrefix != null && message.hasOwnProperty("destinationPrefix"))
                        object.destinationPrefix = message.destinationPrefix;
                    return object;
                };

                /**
                 * Converts this Item to JSON.
                 * @function toJSON
                 * @memberof Ydb.Export.ExportToS3Settings.Item
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Item.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Item;
            })();

            return ExportToS3Settings;
        })();

        Export.ExportToS3Result = (function() {

            /**
             * Properties of an ExportToS3Result.
             * @memberof Ydb.Export
             * @interface IExportToS3Result
             */

            /**
             * Constructs a new ExportToS3Result.
             * @memberof Ydb.Export
             * @classdesc Represents an ExportToS3Result.
             * @implements IExportToS3Result
             * @constructor
             * @param {Ydb.Export.IExportToS3Result=} [properties] Properties to set
             */
            function ExportToS3Result(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ExportToS3Result instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToS3Result
             * @static
             * @param {Ydb.Export.IExportToS3Result=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToS3Result} ExportToS3Result instance
             */
            ExportToS3Result.create = function create(properties) {
                return new ExportToS3Result(properties);
            };

            /**
             * Encodes the specified ExportToS3Result message. Does not implicitly {@link Ydb.Export.ExportToS3Result.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToS3Result
             * @static
             * @param {Ydb.Export.IExportToS3Result} message ExportToS3Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Result.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ExportToS3Result message, length delimited. Does not implicitly {@link Ydb.Export.ExportToS3Result.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToS3Result
             * @static
             * @param {Ydb.Export.IExportToS3Result} message ExportToS3Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Result.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToS3Result message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToS3Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToS3Result} ExportToS3Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Result.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToS3Result();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToS3Result message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToS3Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToS3Result} ExportToS3Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Result.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToS3Result message.
             * @function verify
             * @memberof Ydb.Export.ExportToS3Result
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToS3Result.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ExportToS3Result message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToS3Result
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToS3Result} ExportToS3Result
             */
            ExportToS3Result.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToS3Result)
                    return object;
                return new $root.Ydb.Export.ExportToS3Result();
            };

            /**
             * Creates a plain object from an ExportToS3Result message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToS3Result
             * @static
             * @param {Ydb.Export.ExportToS3Result} message ExportToS3Result
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToS3Result.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ExportToS3Result to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToS3Result
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToS3Result.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExportToS3Result;
        })();

        Export.ExportToS3Metadata = (function() {

            /**
             * Properties of an ExportToS3Metadata.
             * @memberof Ydb.Export
             * @interface IExportToS3Metadata
             * @property {Ydb.Export.IExportToS3Settings|null} [settings] ExportToS3Metadata settings
             * @property {Ydb.Export.ExportProgress.Progress|null} [progress] ExportToS3Metadata progress
             */

            /**
             * Constructs a new ExportToS3Metadata.
             * @memberof Ydb.Export
             * @classdesc Represents an ExportToS3Metadata.
             * @implements IExportToS3Metadata
             * @constructor
             * @param {Ydb.Export.IExportToS3Metadata=} [properties] Properties to set
             */
            function ExportToS3Metadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExportToS3Metadata settings.
             * @member {Ydb.Export.IExportToS3Settings|null|undefined} settings
             * @memberof Ydb.Export.ExportToS3Metadata
             * @instance
             */
            ExportToS3Metadata.prototype.settings = null;

            /**
             * ExportToS3Metadata progress.
             * @member {Ydb.Export.ExportProgress.Progress} progress
             * @memberof Ydb.Export.ExportToS3Metadata
             * @instance
             */
            ExportToS3Metadata.prototype.progress = 0;

            /**
             * Creates a new ExportToS3Metadata instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToS3Metadata
             * @static
             * @param {Ydb.Export.IExportToS3Metadata=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToS3Metadata} ExportToS3Metadata instance
             */
            ExportToS3Metadata.create = function create(properties) {
                return new ExportToS3Metadata(properties);
            };

            /**
             * Encodes the specified ExportToS3Metadata message. Does not implicitly {@link Ydb.Export.ExportToS3Metadata.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToS3Metadata
             * @static
             * @param {Ydb.Export.IExportToS3Metadata} message ExportToS3Metadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Metadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.settings != null && message.hasOwnProperty("settings"))
                    $root.Ydb.Export.ExportToS3Settings.encode(message.settings, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.progress != null && message.hasOwnProperty("progress"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.progress);
                return writer;
            };

            /**
             * Encodes the specified ExportToS3Metadata message, length delimited. Does not implicitly {@link Ydb.Export.ExportToS3Metadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToS3Metadata
             * @static
             * @param {Ydb.Export.IExportToS3Metadata} message ExportToS3Metadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Metadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToS3Metadata message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToS3Metadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToS3Metadata} ExportToS3Metadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Metadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToS3Metadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.settings = $root.Ydb.Export.ExportToS3Settings.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.progress = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToS3Metadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToS3Metadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToS3Metadata} ExportToS3Metadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Metadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToS3Metadata message.
             * @function verify
             * @memberof Ydb.Export.ExportToS3Metadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToS3Metadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    var error = $root.Ydb.Export.ExportToS3Settings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                if (message.progress != null && message.hasOwnProperty("progress"))
                    switch (message.progress) {
                    default:
                        return "progress: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                return null;
            };

            /**
             * Creates an ExportToS3Metadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToS3Metadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToS3Metadata} ExportToS3Metadata
             */
            ExportToS3Metadata.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToS3Metadata)
                    return object;
                var message = new $root.Ydb.Export.ExportToS3Metadata();
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".Ydb.Export.ExportToS3Metadata.settings: object expected");
                    message.settings = $root.Ydb.Export.ExportToS3Settings.fromObject(object.settings);
                }
                switch (object.progress) {
                case "PROGRESS_UNSPECIFIED":
                case 0:
                    message.progress = 0;
                    break;
                case "PROGRESS_PREPARING":
                case 1:
                    message.progress = 1;
                    break;
                case "PROGRESS_TRANSFER_DATA":
                case 2:
                    message.progress = 2;
                    break;
                case "PROGRESS_DONE":
                case 3:
                    message.progress = 3;
                    break;
                case "PROGRESS_CANCELLATION":
                case 4:
                    message.progress = 4;
                    break;
                case "PROGRESS_CANCELLED":
                case 5:
                    message.progress = 5;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ExportToS3Metadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToS3Metadata
             * @static
             * @param {Ydb.Export.ExportToS3Metadata} message ExportToS3Metadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToS3Metadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.settings = null;
                    object.progress = options.enums === String ? "PROGRESS_UNSPECIFIED" : 0;
                }
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.Ydb.Export.ExportToS3Settings.toObject(message.settings, options);
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = options.enums === String ? $root.Ydb.Export.ExportProgress.Progress[message.progress] : message.progress;
                return object;
            };

            /**
             * Converts this ExportToS3Metadata to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToS3Metadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToS3Metadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExportToS3Metadata;
        })();

        Export.ExportToS3Request = (function() {

            /**
             * Properties of an ExportToS3Request.
             * @memberof Ydb.Export
             * @interface IExportToS3Request
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExportToS3Request operationParams
             * @property {Ydb.Export.IExportToS3Settings|null} [settings] ExportToS3Request settings
             */

            /**
             * Constructs a new ExportToS3Request.
             * @memberof Ydb.Export
             * @classdesc Represents an ExportToS3Request.
             * @implements IExportToS3Request
             * @constructor
             * @param {Ydb.Export.IExportToS3Request=} [properties] Properties to set
             */
            function ExportToS3Request(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExportToS3Request operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Export.ExportToS3Request
             * @instance
             */
            ExportToS3Request.prototype.operationParams = null;

            /**
             * ExportToS3Request settings.
             * @member {Ydb.Export.IExportToS3Settings|null|undefined} settings
             * @memberof Ydb.Export.ExportToS3Request
             * @instance
             */
            ExportToS3Request.prototype.settings = null;

            /**
             * Creates a new ExportToS3Request instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToS3Request
             * @static
             * @param {Ydb.Export.IExportToS3Request=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToS3Request} ExportToS3Request instance
             */
            ExportToS3Request.create = function create(properties) {
                return new ExportToS3Request(properties);
            };

            /**
             * Encodes the specified ExportToS3Request message. Does not implicitly {@link Ydb.Export.ExportToS3Request.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToS3Request
             * @static
             * @param {Ydb.Export.IExportToS3Request} message ExportToS3Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Request.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.settings != null && message.hasOwnProperty("settings"))
                    $root.Ydb.Export.ExportToS3Settings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExportToS3Request message, length delimited. Does not implicitly {@link Ydb.Export.ExportToS3Request.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToS3Request
             * @static
             * @param {Ydb.Export.IExportToS3Request} message ExportToS3Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Request.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToS3Request message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToS3Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToS3Request} ExportToS3Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Request.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToS3Request();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.settings = $root.Ydb.Export.ExportToS3Settings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToS3Request message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToS3Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToS3Request} ExportToS3Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Request.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToS3Request message.
             * @function verify
             * @memberof Ydb.Export.ExportToS3Request
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToS3Request.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    var error = $root.Ydb.Export.ExportToS3Settings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                return null;
            };

            /**
             * Creates an ExportToS3Request message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToS3Request
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToS3Request} ExportToS3Request
             */
            ExportToS3Request.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToS3Request)
                    return object;
                var message = new $root.Ydb.Export.ExportToS3Request();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Export.ExportToS3Request.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".Ydb.Export.ExportToS3Request.settings: object expected");
                    message.settings = $root.Ydb.Export.ExportToS3Settings.fromObject(object.settings);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExportToS3Request message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToS3Request
             * @static
             * @param {Ydb.Export.ExportToS3Request} message ExportToS3Request
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToS3Request.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.settings = null;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.Ydb.Export.ExportToS3Settings.toObject(message.settings, options);
                return object;
            };

            /**
             * Converts this ExportToS3Request to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToS3Request
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToS3Request.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExportToS3Request;
        })();

        Export.ExportToS3Response = (function() {

            /**
             * Properties of an ExportToS3Response.
             * @memberof Ydb.Export
             * @interface IExportToS3Response
             * @property {Ydb.Operations.IOperation|null} [operation] ExportToS3Response operation
             */

            /**
             * Constructs a new ExportToS3Response.
             * @memberof Ydb.Export
             * @classdesc Represents an ExportToS3Response.
             * @implements IExportToS3Response
             * @constructor
             * @param {Ydb.Export.IExportToS3Response=} [properties] Properties to set
             */
            function ExportToS3Response(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExportToS3Response operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Export.ExportToS3Response
             * @instance
             */
            ExportToS3Response.prototype.operation = null;

            /**
             * Creates a new ExportToS3Response instance using the specified properties.
             * @function create
             * @memberof Ydb.Export.ExportToS3Response
             * @static
             * @param {Ydb.Export.IExportToS3Response=} [properties] Properties to set
             * @returns {Ydb.Export.ExportToS3Response} ExportToS3Response instance
             */
            ExportToS3Response.create = function create(properties) {
                return new ExportToS3Response(properties);
            };

            /**
             * Encodes the specified ExportToS3Response message. Does not implicitly {@link Ydb.Export.ExportToS3Response.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Export.ExportToS3Response
             * @static
             * @param {Ydb.Export.IExportToS3Response} message ExportToS3Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Response.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExportToS3Response message, length delimited. Does not implicitly {@link Ydb.Export.ExportToS3Response.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Export.ExportToS3Response
             * @static
             * @param {Ydb.Export.IExportToS3Response} message ExportToS3Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportToS3Response.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportToS3Response message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Export.ExportToS3Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Export.ExportToS3Response} ExportToS3Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Response.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Export.ExportToS3Response();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportToS3Response message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Export.ExportToS3Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Export.ExportToS3Response} ExportToS3Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportToS3Response.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportToS3Response message.
             * @function verify
             * @memberof Ydb.Export.ExportToS3Response
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportToS3Response.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExportToS3Response message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Export.ExportToS3Response
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Export.ExportToS3Response} ExportToS3Response
             */
            ExportToS3Response.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Export.ExportToS3Response)
                    return object;
                var message = new $root.Ydb.Export.ExportToS3Response();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Export.ExportToS3Response.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExportToS3Response message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Export.ExportToS3Response
             * @static
             * @param {Ydb.Export.ExportToS3Response} message ExportToS3Response
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportToS3Response.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExportToS3Response to JSON.
             * @function toJSON
             * @memberof Ydb.Export.ExportToS3Response
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportToS3Response.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExportToS3Response;
        })();

        return Export;
    })();

    Ydb.Monitoring = (function() {

        /**
         * Namespace Monitoring.
         * @memberof Ydb
         * @namespace
         */
        var Monitoring = {};

        Monitoring.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Monitoring
             * @namespace
             */
            var V1 = {};

            V1.MonitoringService = (function() {

                /**
                 * Constructs a new MonitoringService service.
                 * @memberof Ydb.Monitoring.V1
                 * @classdesc Represents a MonitoringService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function MonitoringService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (MonitoringService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MonitoringService;

                /**
                 * Creates new MonitoringService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Monitoring.V1.MonitoringService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {MonitoringService} RPC service. Useful where requests and/or responses are streamed.
                 */
                MonitoringService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Monitoring.V1.MonitoringService#selfCheck}.
                 * @memberof Ydb.Monitoring.V1.MonitoringService
                 * @typedef SelfCheckCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Monitoring.SelfCheckResponse} [response] SelfCheckResponse
                 */

                /**
                 * Calls SelfCheck.
                 * @function selfCheck
                 * @memberof Ydb.Monitoring.V1.MonitoringService
                 * @instance
                 * @param {Ydb.Monitoring.ISelfCheckRequest} request SelfCheckRequest message or plain object
                 * @param {Ydb.Monitoring.V1.MonitoringService.SelfCheckCallback} callback Node-style callback called with the error, if any, and SelfCheckResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(MonitoringService.prototype.selfCheck = function selfCheck(request, callback) {
                    return this.rpcCall(selfCheck, $root.Ydb.Monitoring.SelfCheckRequest, $root.Ydb.Monitoring.SelfCheckResponse, request, callback);
                }, "name", { value: "SelfCheck" });

                /**
                 * Calls SelfCheck.
                 * @function selfCheck
                 * @memberof Ydb.Monitoring.V1.MonitoringService
                 * @instance
                 * @param {Ydb.Monitoring.ISelfCheckRequest} request SelfCheckRequest message or plain object
                 * @returns {Promise<Ydb.Monitoring.SelfCheckResponse>} Promise
                 * @variation 2
                 */

                return MonitoringService;
            })();

            return V1;
        })();

        Monitoring.SelfCheckRequest = (function() {

            /**
             * Properties of a SelfCheckRequest.
             * @memberof Ydb.Monitoring
             * @interface ISelfCheckRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] SelfCheckRequest operationParams
             * @property {boolean|null} [returnVerboseStatus] SelfCheckRequest returnVerboseStatus
             */

            /**
             * Constructs a new SelfCheckRequest.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a SelfCheckRequest.
             * @implements ISelfCheckRequest
             * @constructor
             * @param {Ydb.Monitoring.ISelfCheckRequest=} [properties] Properties to set
             */
            function SelfCheckRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SelfCheckRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @instance
             */
            SelfCheckRequest.prototype.operationParams = null;

            /**
             * SelfCheckRequest returnVerboseStatus.
             * @member {boolean} returnVerboseStatus
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @instance
             */
            SelfCheckRequest.prototype.returnVerboseStatus = false;

            /**
             * Creates a new SelfCheckRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @static
             * @param {Ydb.Monitoring.ISelfCheckRequest=} [properties] Properties to set
             * @returns {Ydb.Monitoring.SelfCheckRequest} SelfCheckRequest instance
             */
            SelfCheckRequest.create = function create(properties) {
                return new SelfCheckRequest(properties);
            };

            /**
             * Encodes the specified SelfCheckRequest message. Does not implicitly {@link Ydb.Monitoring.SelfCheckRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @static
             * @param {Ydb.Monitoring.ISelfCheckRequest} message SelfCheckRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelfCheckRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.returnVerboseStatus != null && message.hasOwnProperty("returnVerboseStatus"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.returnVerboseStatus);
                return writer;
            };

            /**
             * Encodes the specified SelfCheckRequest message, length delimited. Does not implicitly {@link Ydb.Monitoring.SelfCheckRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @static
             * @param {Ydb.Monitoring.ISelfCheckRequest} message SelfCheckRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelfCheckRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SelfCheckRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.SelfCheckRequest} SelfCheckRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelfCheckRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.SelfCheckRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.returnVerboseStatus = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SelfCheckRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.SelfCheckRequest} SelfCheckRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelfCheckRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SelfCheckRequest message.
             * @function verify
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SelfCheckRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.returnVerboseStatus != null && message.hasOwnProperty("returnVerboseStatus"))
                    if (typeof message.returnVerboseStatus !== "boolean")
                        return "returnVerboseStatus: boolean expected";
                return null;
            };

            /**
             * Creates a SelfCheckRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.SelfCheckRequest} SelfCheckRequest
             */
            SelfCheckRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.SelfCheckRequest)
                    return object;
                var message = new $root.Ydb.Monitoring.SelfCheckRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Monitoring.SelfCheckRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.returnVerboseStatus != null)
                    message.returnVerboseStatus = Boolean(object.returnVerboseStatus);
                return message;
            };

            /**
             * Creates a plain object from a SelfCheckRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @static
             * @param {Ydb.Monitoring.SelfCheckRequest} message SelfCheckRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SelfCheckRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.returnVerboseStatus = false;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.returnVerboseStatus != null && message.hasOwnProperty("returnVerboseStatus"))
                    object.returnVerboseStatus = message.returnVerboseStatus;
                return object;
            };

            /**
             * Converts this SelfCheckRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.SelfCheckRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SelfCheckRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SelfCheckRequest;
        })();

        Monitoring.SelfCheckResponse = (function() {

            /**
             * Properties of a SelfCheckResponse.
             * @memberof Ydb.Monitoring
             * @interface ISelfCheckResponse
             * @property {Ydb.Operations.IOperation|null} [operation] SelfCheckResponse operation
             */

            /**
             * Constructs a new SelfCheckResponse.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a SelfCheckResponse.
             * @implements ISelfCheckResponse
             * @constructor
             * @param {Ydb.Monitoring.ISelfCheckResponse=} [properties] Properties to set
             */
            function SelfCheckResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SelfCheckResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @instance
             */
            SelfCheckResponse.prototype.operation = null;

            /**
             * Creates a new SelfCheckResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @static
             * @param {Ydb.Monitoring.ISelfCheckResponse=} [properties] Properties to set
             * @returns {Ydb.Monitoring.SelfCheckResponse} SelfCheckResponse instance
             */
            SelfCheckResponse.create = function create(properties) {
                return new SelfCheckResponse(properties);
            };

            /**
             * Encodes the specified SelfCheckResponse message. Does not implicitly {@link Ydb.Monitoring.SelfCheckResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @static
             * @param {Ydb.Monitoring.ISelfCheckResponse} message SelfCheckResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelfCheckResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SelfCheckResponse message, length delimited. Does not implicitly {@link Ydb.Monitoring.SelfCheckResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @static
             * @param {Ydb.Monitoring.ISelfCheckResponse} message SelfCheckResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelfCheckResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SelfCheckResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.SelfCheckResponse} SelfCheckResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelfCheckResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.SelfCheckResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SelfCheckResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.SelfCheckResponse} SelfCheckResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelfCheckResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SelfCheckResponse message.
             * @function verify
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SelfCheckResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a SelfCheckResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.SelfCheckResponse} SelfCheckResponse
             */
            SelfCheckResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.SelfCheckResponse)
                    return object;
                var message = new $root.Ydb.Monitoring.SelfCheckResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Monitoring.SelfCheckResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a SelfCheckResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @static
             * @param {Ydb.Monitoring.SelfCheckResponse} message SelfCheckResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SelfCheckResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this SelfCheckResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.SelfCheckResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SelfCheckResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SelfCheckResponse;
        })();

        Monitoring.StatusFlag = (function() {

            /**
             * Properties of a StatusFlag.
             * @memberof Ydb.Monitoring
             * @interface IStatusFlag
             */

            /**
             * Constructs a new StatusFlag.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a StatusFlag.
             * @implements IStatusFlag
             * @constructor
             * @param {Ydb.Monitoring.IStatusFlag=} [properties] Properties to set
             */
            function StatusFlag(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StatusFlag instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.StatusFlag
             * @static
             * @param {Ydb.Monitoring.IStatusFlag=} [properties] Properties to set
             * @returns {Ydb.Monitoring.StatusFlag} StatusFlag instance
             */
            StatusFlag.create = function create(properties) {
                return new StatusFlag(properties);
            };

            /**
             * Encodes the specified StatusFlag message. Does not implicitly {@link Ydb.Monitoring.StatusFlag.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.StatusFlag
             * @static
             * @param {Ydb.Monitoring.IStatusFlag} message StatusFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StatusFlag.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StatusFlag message, length delimited. Does not implicitly {@link Ydb.Monitoring.StatusFlag.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.StatusFlag
             * @static
             * @param {Ydb.Monitoring.IStatusFlag} message StatusFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StatusFlag.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StatusFlag message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.StatusFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.StatusFlag} StatusFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StatusFlag.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.StatusFlag();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StatusFlag message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.StatusFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.StatusFlag} StatusFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StatusFlag.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StatusFlag message.
             * @function verify
             * @memberof Ydb.Monitoring.StatusFlag
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StatusFlag.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StatusFlag message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.StatusFlag
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.StatusFlag} StatusFlag
             */
            StatusFlag.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.StatusFlag)
                    return object;
                return new $root.Ydb.Monitoring.StatusFlag();
            };

            /**
             * Creates a plain object from a StatusFlag message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.StatusFlag
             * @static
             * @param {Ydb.Monitoring.StatusFlag} message StatusFlag
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StatusFlag.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StatusFlag to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.StatusFlag
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StatusFlag.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Status enum.
             * @name Ydb.Monitoring.StatusFlag.Status
             * @enum {string}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} GREY=1 GREY value
             * @property {number} GREEN=2 GREEN value
             * @property {number} BLUE=3 BLUE value
             * @property {number} YELLOW=4 YELLOW value
             * @property {number} ORANGE=5 ORANGE value
             * @property {number} RED=6 RED value
             */
            StatusFlag.Status = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "GREY"] = 1;
                values[valuesById[2] = "GREEN"] = 2;
                values[valuesById[3] = "BLUE"] = 3;
                values[valuesById[4] = "YELLOW"] = 4;
                values[valuesById[5] = "ORANGE"] = 5;
                values[valuesById[6] = "RED"] = 6;
                return values;
            })();

            return StatusFlag;
        })();

        Monitoring.SelfCheck = (function() {

            /**
             * Properties of a SelfCheck.
             * @memberof Ydb.Monitoring
             * @interface ISelfCheck
             */

            /**
             * Constructs a new SelfCheck.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a SelfCheck.
             * @implements ISelfCheck
             * @constructor
             * @param {Ydb.Monitoring.ISelfCheck=} [properties] Properties to set
             */
            function SelfCheck(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SelfCheck instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.SelfCheck
             * @static
             * @param {Ydb.Monitoring.ISelfCheck=} [properties] Properties to set
             * @returns {Ydb.Monitoring.SelfCheck} SelfCheck instance
             */
            SelfCheck.create = function create(properties) {
                return new SelfCheck(properties);
            };

            /**
             * Encodes the specified SelfCheck message. Does not implicitly {@link Ydb.Monitoring.SelfCheck.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.SelfCheck
             * @static
             * @param {Ydb.Monitoring.ISelfCheck} message SelfCheck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelfCheck.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SelfCheck message, length delimited. Does not implicitly {@link Ydb.Monitoring.SelfCheck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.SelfCheck
             * @static
             * @param {Ydb.Monitoring.ISelfCheck} message SelfCheck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelfCheck.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SelfCheck message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.SelfCheck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.SelfCheck} SelfCheck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelfCheck.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.SelfCheck();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SelfCheck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.SelfCheck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.SelfCheck} SelfCheck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelfCheck.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SelfCheck message.
             * @function verify
             * @memberof Ydb.Monitoring.SelfCheck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SelfCheck.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SelfCheck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.SelfCheck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.SelfCheck} SelfCheck
             */
            SelfCheck.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.SelfCheck)
                    return object;
                return new $root.Ydb.Monitoring.SelfCheck();
            };

            /**
             * Creates a plain object from a SelfCheck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.SelfCheck
             * @static
             * @param {Ydb.Monitoring.SelfCheck} message SelfCheck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SelfCheck.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SelfCheck to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.SelfCheck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SelfCheck.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Result enum.
             * @name Ydb.Monitoring.SelfCheck.Result
             * @enum {string}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} GOOD=1 GOOD value
             * @property {number} DEGRADED=2 DEGRADED value
             * @property {number} MAINTENANCE_REQUIRED=3 MAINTENANCE_REQUIRED value
             * @property {number} EMERGENCY=4 EMERGENCY value
             */
            SelfCheck.Result = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "GOOD"] = 1;
                values[valuesById[2] = "DEGRADED"] = 2;
                values[valuesById[3] = "MAINTENANCE_REQUIRED"] = 3;
                values[valuesById[4] = "EMERGENCY"] = 4;
                return values;
            })();

            return SelfCheck;
        })();

        Monitoring.StoragePDiskStatus = (function() {

            /**
             * Properties of a StoragePDiskStatus.
             * @memberof Ydb.Monitoring
             * @interface IStoragePDiskStatus
             * @property {string|null} [id] StoragePDiskStatus id
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] StoragePDiskStatus overall
             */

            /**
             * Constructs a new StoragePDiskStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a StoragePDiskStatus.
             * @implements IStoragePDiskStatus
             * @constructor
             * @param {Ydb.Monitoring.IStoragePDiskStatus=} [properties] Properties to set
             */
            function StoragePDiskStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoragePDiskStatus id.
             * @member {string} id
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @instance
             */
            StoragePDiskStatus.prototype.id = "";

            /**
             * StoragePDiskStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @instance
             */
            StoragePDiskStatus.prototype.overall = 0;

            /**
             * Creates a new StoragePDiskStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @static
             * @param {Ydb.Monitoring.IStoragePDiskStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.StoragePDiskStatus} StoragePDiskStatus instance
             */
            StoragePDiskStatus.create = function create(properties) {
                return new StoragePDiskStatus(properties);
            };

            /**
             * Encodes the specified StoragePDiskStatus message. Does not implicitly {@link Ydb.Monitoring.StoragePDiskStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @static
             * @param {Ydb.Monitoring.IStoragePDiskStatus} message StoragePDiskStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePDiskStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.overall);
                return writer;
            };

            /**
             * Encodes the specified StoragePDiskStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.StoragePDiskStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @static
             * @param {Ydb.Monitoring.IStoragePDiskStatus} message StoragePDiskStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePDiskStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoragePDiskStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.StoragePDiskStatus} StoragePDiskStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePDiskStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.StoragePDiskStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.overall = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoragePDiskStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.StoragePDiskStatus} StoragePDiskStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePDiskStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoragePDiskStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoragePDiskStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                return null;
            };

            /**
             * Creates a StoragePDiskStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.StoragePDiskStatus} StoragePDiskStatus
             */
            StoragePDiskStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.StoragePDiskStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.StoragePDiskStatus();
                if (object.id != null)
                    message.id = String(object.id);
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a StoragePDiskStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @static
             * @param {Ydb.Monitoring.StoragePDiskStatus} message StoragePDiskStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoragePDiskStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                return object;
            };

            /**
             * Converts this StoragePDiskStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.StoragePDiskStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoragePDiskStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoragePDiskStatus;
        })();

        Monitoring.StorageVDiskStatus = (function() {

            /**
             * Properties of a StorageVDiskStatus.
             * @memberof Ydb.Monitoring
             * @interface IStorageVDiskStatus
             * @property {string|null} [id] StorageVDiskStatus id
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] StorageVDiskStatus overall
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [vdiskStatus] StorageVDiskStatus vdiskStatus
             * @property {Ydb.Monitoring.IStoragePDiskStatus|null} [pdisk] StorageVDiskStatus pdisk
             */

            /**
             * Constructs a new StorageVDiskStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a StorageVDiskStatus.
             * @implements IStorageVDiskStatus
             * @constructor
             * @param {Ydb.Monitoring.IStorageVDiskStatus=} [properties] Properties to set
             */
            function StorageVDiskStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StorageVDiskStatus id.
             * @member {string} id
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @instance
             */
            StorageVDiskStatus.prototype.id = "";

            /**
             * StorageVDiskStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @instance
             */
            StorageVDiskStatus.prototype.overall = 0;

            /**
             * StorageVDiskStatus vdiskStatus.
             * @member {Ydb.Monitoring.StatusFlag.Status} vdiskStatus
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @instance
             */
            StorageVDiskStatus.prototype.vdiskStatus = 0;

            /**
             * StorageVDiskStatus pdisk.
             * @member {Ydb.Monitoring.IStoragePDiskStatus|null|undefined} pdisk
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @instance
             */
            StorageVDiskStatus.prototype.pdisk = null;

            /**
             * Creates a new StorageVDiskStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @static
             * @param {Ydb.Monitoring.IStorageVDiskStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.StorageVDiskStatus} StorageVDiskStatus instance
             */
            StorageVDiskStatus.create = function create(properties) {
                return new StorageVDiskStatus(properties);
            };

            /**
             * Encodes the specified StorageVDiskStatus message. Does not implicitly {@link Ydb.Monitoring.StorageVDiskStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @static
             * @param {Ydb.Monitoring.IStorageVDiskStatus} message StorageVDiskStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageVDiskStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.overall);
                if (message.vdiskStatus != null && message.hasOwnProperty("vdiskStatus"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.vdiskStatus);
                if (message.pdisk != null && message.hasOwnProperty("pdisk"))
                    $root.Ydb.Monitoring.StoragePDiskStatus.encode(message.pdisk, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StorageVDiskStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.StorageVDiskStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @static
             * @param {Ydb.Monitoring.IStorageVDiskStatus} message StorageVDiskStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageVDiskStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StorageVDiskStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.StorageVDiskStatus} StorageVDiskStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageVDiskStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.StorageVDiskStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.overall = reader.int32();
                        break;
                    case 3:
                        message.vdiskStatus = reader.int32();
                        break;
                    case 4:
                        message.pdisk = $root.Ydb.Monitoring.StoragePDiskStatus.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StorageVDiskStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.StorageVDiskStatus} StorageVDiskStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageVDiskStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StorageVDiskStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageVDiskStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.vdiskStatus != null && message.hasOwnProperty("vdiskStatus"))
                    switch (message.vdiskStatus) {
                    default:
                        return "vdiskStatus: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.pdisk != null && message.hasOwnProperty("pdisk")) {
                    var error = $root.Ydb.Monitoring.StoragePDiskStatus.verify(message.pdisk);
                    if (error)
                        return "pdisk." + error;
                }
                return null;
            };

            /**
             * Creates a StorageVDiskStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.StorageVDiskStatus} StorageVDiskStatus
             */
            StorageVDiskStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.StorageVDiskStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.StorageVDiskStatus();
                if (object.id != null)
                    message.id = String(object.id);
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                switch (object.vdiskStatus) {
                case "UNSPECIFIED":
                case 0:
                    message.vdiskStatus = 0;
                    break;
                case "GREY":
                case 1:
                    message.vdiskStatus = 1;
                    break;
                case "GREEN":
                case 2:
                    message.vdiskStatus = 2;
                    break;
                case "BLUE":
                case 3:
                    message.vdiskStatus = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.vdiskStatus = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.vdiskStatus = 5;
                    break;
                case "RED":
                case 6:
                    message.vdiskStatus = 6;
                    break;
                }
                if (object.pdisk != null) {
                    if (typeof object.pdisk !== "object")
                        throw TypeError(".Ydb.Monitoring.StorageVDiskStatus.pdisk: object expected");
                    message.pdisk = $root.Ydb.Monitoring.StoragePDiskStatus.fromObject(object.pdisk);
                }
                return message;
            };

            /**
             * Creates a plain object from a StorageVDiskStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @static
             * @param {Ydb.Monitoring.StorageVDiskStatus} message StorageVDiskStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageVDiskStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                    object.vdiskStatus = options.enums === String ? "UNSPECIFIED" : 0;
                    object.pdisk = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.vdiskStatus != null && message.hasOwnProperty("vdiskStatus"))
                    object.vdiskStatus = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.vdiskStatus] : message.vdiskStatus;
                if (message.pdisk != null && message.hasOwnProperty("pdisk"))
                    object.pdisk = $root.Ydb.Monitoring.StoragePDiskStatus.toObject(message.pdisk, options);
                return object;
            };

            /**
             * Converts this StorageVDiskStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.StorageVDiskStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageVDiskStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StorageVDiskStatus;
        })();

        Monitoring.StorageGroupStatus = (function() {

            /**
             * Properties of a StorageGroupStatus.
             * @memberof Ydb.Monitoring
             * @interface IStorageGroupStatus
             * @property {string|null} [id] StorageGroupStatus id
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] StorageGroupStatus overall
             * @property {Array.<Ydb.Monitoring.IStorageVDiskStatus>|null} [vdisks] StorageGroupStatus vdisks
             */

            /**
             * Constructs a new StorageGroupStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a StorageGroupStatus.
             * @implements IStorageGroupStatus
             * @constructor
             * @param {Ydb.Monitoring.IStorageGroupStatus=} [properties] Properties to set
             */
            function StorageGroupStatus(properties) {
                this.vdisks = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StorageGroupStatus id.
             * @member {string} id
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @instance
             */
            StorageGroupStatus.prototype.id = "";

            /**
             * StorageGroupStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @instance
             */
            StorageGroupStatus.prototype.overall = 0;

            /**
             * StorageGroupStatus vdisks.
             * @member {Array.<Ydb.Monitoring.IStorageVDiskStatus>} vdisks
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @instance
             */
            StorageGroupStatus.prototype.vdisks = $util.emptyArray;

            /**
             * Creates a new StorageGroupStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @static
             * @param {Ydb.Monitoring.IStorageGroupStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.StorageGroupStatus} StorageGroupStatus instance
             */
            StorageGroupStatus.create = function create(properties) {
                return new StorageGroupStatus(properties);
            };

            /**
             * Encodes the specified StorageGroupStatus message. Does not implicitly {@link Ydb.Monitoring.StorageGroupStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @static
             * @param {Ydb.Monitoring.IStorageGroupStatus} message StorageGroupStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageGroupStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.overall);
                if (message.vdisks != null && message.vdisks.length)
                    for (var i = 0; i < message.vdisks.length; ++i)
                        $root.Ydb.Monitoring.StorageVDiskStatus.encode(message.vdisks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StorageGroupStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.StorageGroupStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @static
             * @param {Ydb.Monitoring.IStorageGroupStatus} message StorageGroupStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageGroupStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StorageGroupStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.StorageGroupStatus} StorageGroupStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageGroupStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.StorageGroupStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.overall = reader.int32();
                        break;
                    case 3:
                        if (!(message.vdisks && message.vdisks.length))
                            message.vdisks = [];
                        message.vdisks.push($root.Ydb.Monitoring.StorageVDiskStatus.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StorageGroupStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.StorageGroupStatus} StorageGroupStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageGroupStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StorageGroupStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageGroupStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.vdisks != null && message.hasOwnProperty("vdisks")) {
                    if (!Array.isArray(message.vdisks))
                        return "vdisks: array expected";
                    for (var i = 0; i < message.vdisks.length; ++i) {
                        var error = $root.Ydb.Monitoring.StorageVDiskStatus.verify(message.vdisks[i]);
                        if (error)
                            return "vdisks." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a StorageGroupStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.StorageGroupStatus} StorageGroupStatus
             */
            StorageGroupStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.StorageGroupStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.StorageGroupStatus();
                if (object.id != null)
                    message.id = String(object.id);
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                if (object.vdisks) {
                    if (!Array.isArray(object.vdisks))
                        throw TypeError(".Ydb.Monitoring.StorageGroupStatus.vdisks: array expected");
                    message.vdisks = [];
                    for (var i = 0; i < object.vdisks.length; ++i) {
                        if (typeof object.vdisks[i] !== "object")
                            throw TypeError(".Ydb.Monitoring.StorageGroupStatus.vdisks: object expected");
                        message.vdisks[i] = $root.Ydb.Monitoring.StorageVDiskStatus.fromObject(object.vdisks[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a StorageGroupStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @static
             * @param {Ydb.Monitoring.StorageGroupStatus} message StorageGroupStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageGroupStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.vdisks = [];
                if (options.defaults) {
                    object.id = "";
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.vdisks && message.vdisks.length) {
                    object.vdisks = [];
                    for (var j = 0; j < message.vdisks.length; ++j)
                        object.vdisks[j] = $root.Ydb.Monitoring.StorageVDiskStatus.toObject(message.vdisks[j], options);
                }
                return object;
            };

            /**
             * Converts this StorageGroupStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.StorageGroupStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageGroupStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StorageGroupStatus;
        })();

        Monitoring.StoragePoolStatus = (function() {

            /**
             * Properties of a StoragePoolStatus.
             * @memberof Ydb.Monitoring
             * @interface IStoragePoolStatus
             * @property {string|null} [id] StoragePoolStatus id
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] StoragePoolStatus overall
             * @property {Array.<Ydb.Monitoring.IStorageGroupStatus>|null} [groups] StoragePoolStatus groups
             */

            /**
             * Constructs a new StoragePoolStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a StoragePoolStatus.
             * @implements IStoragePoolStatus
             * @constructor
             * @param {Ydb.Monitoring.IStoragePoolStatus=} [properties] Properties to set
             */
            function StoragePoolStatus(properties) {
                this.groups = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoragePoolStatus id.
             * @member {string} id
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @instance
             */
            StoragePoolStatus.prototype.id = "";

            /**
             * StoragePoolStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @instance
             */
            StoragePoolStatus.prototype.overall = 0;

            /**
             * StoragePoolStatus groups.
             * @member {Array.<Ydb.Monitoring.IStorageGroupStatus>} groups
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @instance
             */
            StoragePoolStatus.prototype.groups = $util.emptyArray;

            /**
             * Creates a new StoragePoolStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @static
             * @param {Ydb.Monitoring.IStoragePoolStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.StoragePoolStatus} StoragePoolStatus instance
             */
            StoragePoolStatus.create = function create(properties) {
                return new StoragePoolStatus(properties);
            };

            /**
             * Encodes the specified StoragePoolStatus message. Does not implicitly {@link Ydb.Monitoring.StoragePoolStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @static
             * @param {Ydb.Monitoring.IStoragePoolStatus} message StoragePoolStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePoolStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.overall);
                if (message.groups != null && message.groups.length)
                    for (var i = 0; i < message.groups.length; ++i)
                        $root.Ydb.Monitoring.StorageGroupStatus.encode(message.groups[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StoragePoolStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.StoragePoolStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @static
             * @param {Ydb.Monitoring.IStoragePoolStatus} message StoragePoolStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePoolStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoragePoolStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.StoragePoolStatus} StoragePoolStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePoolStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.StoragePoolStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.overall = reader.int32();
                        break;
                    case 3:
                        if (!(message.groups && message.groups.length))
                            message.groups = [];
                        message.groups.push($root.Ydb.Monitoring.StorageGroupStatus.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoragePoolStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.StoragePoolStatus} StoragePoolStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePoolStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoragePoolStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoragePoolStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.groups != null && message.hasOwnProperty("groups")) {
                    if (!Array.isArray(message.groups))
                        return "groups: array expected";
                    for (var i = 0; i < message.groups.length; ++i) {
                        var error = $root.Ydb.Monitoring.StorageGroupStatus.verify(message.groups[i]);
                        if (error)
                            return "groups." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a StoragePoolStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.StoragePoolStatus} StoragePoolStatus
             */
            StoragePoolStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.StoragePoolStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.StoragePoolStatus();
                if (object.id != null)
                    message.id = String(object.id);
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                if (object.groups) {
                    if (!Array.isArray(object.groups))
                        throw TypeError(".Ydb.Monitoring.StoragePoolStatus.groups: array expected");
                    message.groups = [];
                    for (var i = 0; i < object.groups.length; ++i) {
                        if (typeof object.groups[i] !== "object")
                            throw TypeError(".Ydb.Monitoring.StoragePoolStatus.groups: object expected");
                        message.groups[i] = $root.Ydb.Monitoring.StorageGroupStatus.fromObject(object.groups[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a StoragePoolStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @static
             * @param {Ydb.Monitoring.StoragePoolStatus} message StoragePoolStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoragePoolStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groups = [];
                if (options.defaults) {
                    object.id = "";
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.groups && message.groups.length) {
                    object.groups = [];
                    for (var j = 0; j < message.groups.length; ++j)
                        object.groups[j] = $root.Ydb.Monitoring.StorageGroupStatus.toObject(message.groups[j], options);
                }
                return object;
            };

            /**
             * Converts this StoragePoolStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.StoragePoolStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoragePoolStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoragePoolStatus;
        })();

        Monitoring.StorageStatus = (function() {

            /**
             * Properties of a StorageStatus.
             * @memberof Ydb.Monitoring
             * @interface IStorageStatus
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] StorageStatus overall
             * @property {Array.<Ydb.Monitoring.IStoragePoolStatus>|null} [pools] StorageStatus pools
             */

            /**
             * Constructs a new StorageStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a StorageStatus.
             * @implements IStorageStatus
             * @constructor
             * @param {Ydb.Monitoring.IStorageStatus=} [properties] Properties to set
             */
            function StorageStatus(properties) {
                this.pools = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StorageStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.StorageStatus
             * @instance
             */
            StorageStatus.prototype.overall = 0;

            /**
             * StorageStatus pools.
             * @member {Array.<Ydb.Monitoring.IStoragePoolStatus>} pools
             * @memberof Ydb.Monitoring.StorageStatus
             * @instance
             */
            StorageStatus.prototype.pools = $util.emptyArray;

            /**
             * Creates a new StorageStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.StorageStatus
             * @static
             * @param {Ydb.Monitoring.IStorageStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.StorageStatus} StorageStatus instance
             */
            StorageStatus.create = function create(properties) {
                return new StorageStatus(properties);
            };

            /**
             * Encodes the specified StorageStatus message. Does not implicitly {@link Ydb.Monitoring.StorageStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.StorageStatus
             * @static
             * @param {Ydb.Monitoring.IStorageStatus} message StorageStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.overall);
                if (message.pools != null && message.pools.length)
                    for (var i = 0; i < message.pools.length; ++i)
                        $root.Ydb.Monitoring.StoragePoolStatus.encode(message.pools[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StorageStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.StorageStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.StorageStatus
             * @static
             * @param {Ydb.Monitoring.IStorageStatus} message StorageStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StorageStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.StorageStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.StorageStatus} StorageStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.StorageStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.overall = reader.int32();
                        break;
                    case 2:
                        if (!(message.pools && message.pools.length))
                            message.pools = [];
                        message.pools.push($root.Ydb.Monitoring.StoragePoolStatus.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StorageStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.StorageStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.StorageStatus} StorageStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StorageStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.StorageStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.pools != null && message.hasOwnProperty("pools")) {
                    if (!Array.isArray(message.pools))
                        return "pools: array expected";
                    for (var i = 0; i < message.pools.length; ++i) {
                        var error = $root.Ydb.Monitoring.StoragePoolStatus.verify(message.pools[i]);
                        if (error)
                            return "pools." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a StorageStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.StorageStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.StorageStatus} StorageStatus
             */
            StorageStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.StorageStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.StorageStatus();
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                if (object.pools) {
                    if (!Array.isArray(object.pools))
                        throw TypeError(".Ydb.Monitoring.StorageStatus.pools: array expected");
                    message.pools = [];
                    for (var i = 0; i < object.pools.length; ++i) {
                        if (typeof object.pools[i] !== "object")
                            throw TypeError(".Ydb.Monitoring.StorageStatus.pools: object expected");
                        message.pools[i] = $root.Ydb.Monitoring.StoragePoolStatus.fromObject(object.pools[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a StorageStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.StorageStatus
             * @static
             * @param {Ydb.Monitoring.StorageStatus} message StorageStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.pools = [];
                if (options.defaults)
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.pools && message.pools.length) {
                    object.pools = [];
                    for (var j = 0; j < message.pools.length; ++j)
                        object.pools[j] = $root.Ydb.Monitoring.StoragePoolStatus.toObject(message.pools[j], options);
                }
                return object;
            };

            /**
             * Converts this StorageStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.StorageStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StorageStatus;
        })();

        Monitoring.ComputeTabletStatus = (function() {

            /**
             * Properties of a ComputeTabletStatus.
             * @memberof Ydb.Monitoring
             * @interface IComputeTabletStatus
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] ComputeTabletStatus overall
             * @property {string|null} [type] ComputeTabletStatus type
             * @property {string|null} [state] ComputeTabletStatus state
             * @property {number|null} [count] ComputeTabletStatus count
             */

            /**
             * Constructs a new ComputeTabletStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a ComputeTabletStatus.
             * @implements IComputeTabletStatus
             * @constructor
             * @param {Ydb.Monitoring.IComputeTabletStatus=} [properties] Properties to set
             */
            function ComputeTabletStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComputeTabletStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @instance
             */
            ComputeTabletStatus.prototype.overall = 0;

            /**
             * ComputeTabletStatus type.
             * @member {string} type
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @instance
             */
            ComputeTabletStatus.prototype.type = "";

            /**
             * ComputeTabletStatus state.
             * @member {string} state
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @instance
             */
            ComputeTabletStatus.prototype.state = "";

            /**
             * ComputeTabletStatus count.
             * @member {number} count
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @instance
             */
            ComputeTabletStatus.prototype.count = 0;

            /**
             * Creates a new ComputeTabletStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @static
             * @param {Ydb.Monitoring.IComputeTabletStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.ComputeTabletStatus} ComputeTabletStatus instance
             */
            ComputeTabletStatus.create = function create(properties) {
                return new ComputeTabletStatus(properties);
            };

            /**
             * Encodes the specified ComputeTabletStatus message. Does not implicitly {@link Ydb.Monitoring.ComputeTabletStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @static
             * @param {Ydb.Monitoring.IComputeTabletStatus} message ComputeTabletStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeTabletStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.overall);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
                if (message.state != null && message.hasOwnProperty("state"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.state);
                if (message.count != null && message.hasOwnProperty("count"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified ComputeTabletStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.ComputeTabletStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @static
             * @param {Ydb.Monitoring.IComputeTabletStatus} message ComputeTabletStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeTabletStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComputeTabletStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.ComputeTabletStatus} ComputeTabletStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeTabletStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.ComputeTabletStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.overall = reader.int32();
                        break;
                    case 2:
                        message.type = reader.string();
                        break;
                    case 3:
                        message.state = reader.string();
                        break;
                    case 4:
                        message.count = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ComputeTabletStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.ComputeTabletStatus} ComputeTabletStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeTabletStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComputeTabletStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComputeTabletStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    if (!$util.isString(message.state))
                        return "state: string expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a ComputeTabletStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.ComputeTabletStatus} ComputeTabletStatus
             */
            ComputeTabletStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.ComputeTabletStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.ComputeTabletStatus();
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                if (object.type != null)
                    message.type = String(object.type);
                if (object.state != null)
                    message.state = String(object.state);
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ComputeTabletStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @static
             * @param {Ydb.Monitoring.ComputeTabletStatus} message ComputeTabletStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComputeTabletStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                    object.type = "";
                    object.state = "";
                    object.count = 0;
                }
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = message.state;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this ComputeTabletStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.ComputeTabletStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComputeTabletStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ComputeTabletStatus;
        })();

        Monitoring.ThreadPoolStatus = (function() {

            /**
             * Properties of a ThreadPoolStatus.
             * @memberof Ydb.Monitoring
             * @interface IThreadPoolStatus
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] ThreadPoolStatus overall
             * @property {string|null} [name] ThreadPoolStatus name
             * @property {number|null} [usage] ThreadPoolStatus usage
             */

            /**
             * Constructs a new ThreadPoolStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a ThreadPoolStatus.
             * @implements IThreadPoolStatus
             * @constructor
             * @param {Ydb.Monitoring.IThreadPoolStatus=} [properties] Properties to set
             */
            function ThreadPoolStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ThreadPoolStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @instance
             */
            ThreadPoolStatus.prototype.overall = 0;

            /**
             * ThreadPoolStatus name.
             * @member {string} name
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @instance
             */
            ThreadPoolStatus.prototype.name = "";

            /**
             * ThreadPoolStatus usage.
             * @member {number} usage
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @instance
             */
            ThreadPoolStatus.prototype.usage = 0;

            /**
             * Creates a new ThreadPoolStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @static
             * @param {Ydb.Monitoring.IThreadPoolStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.ThreadPoolStatus} ThreadPoolStatus instance
             */
            ThreadPoolStatus.create = function create(properties) {
                return new ThreadPoolStatus(properties);
            };

            /**
             * Encodes the specified ThreadPoolStatus message. Does not implicitly {@link Ydb.Monitoring.ThreadPoolStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @static
             * @param {Ydb.Monitoring.IThreadPoolStatus} message ThreadPoolStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadPoolStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.overall);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.usage != null && message.hasOwnProperty("usage"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.usage);
                return writer;
            };

            /**
             * Encodes the specified ThreadPoolStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.ThreadPoolStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @static
             * @param {Ydb.Monitoring.IThreadPoolStatus} message ThreadPoolStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadPoolStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ThreadPoolStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.ThreadPoolStatus} ThreadPoolStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadPoolStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.ThreadPoolStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.overall = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.usage = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ThreadPoolStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.ThreadPoolStatus} ThreadPoolStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadPoolStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ThreadPoolStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ThreadPoolStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.usage != null && message.hasOwnProperty("usage"))
                    if (typeof message.usage !== "number")
                        return "usage: number expected";
                return null;
            };

            /**
             * Creates a ThreadPoolStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.ThreadPoolStatus} ThreadPoolStatus
             */
            ThreadPoolStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.ThreadPoolStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.ThreadPoolStatus();
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.usage != null)
                    message.usage = Number(object.usage);
                return message;
            };

            /**
             * Creates a plain object from a ThreadPoolStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @static
             * @param {Ydb.Monitoring.ThreadPoolStatus} message ThreadPoolStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ThreadPoolStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                    object.name = "";
                    object.usage = 0;
                }
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.usage != null && message.hasOwnProperty("usage"))
                    object.usage = options.json && !isFinite(message.usage) ? String(message.usage) : message.usage;
                return object;
            };

            /**
             * Converts this ThreadPoolStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.ThreadPoolStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ThreadPoolStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ThreadPoolStatus;
        })();

        Monitoring.LoadAverageStatus = (function() {

            /**
             * Properties of a LoadAverageStatus.
             * @memberof Ydb.Monitoring
             * @interface ILoadAverageStatus
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] LoadAverageStatus overall
             * @property {number|null} [load] LoadAverageStatus load
             * @property {number|null} [cores] LoadAverageStatus cores
             */

            /**
             * Constructs a new LoadAverageStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LoadAverageStatus.
             * @implements ILoadAverageStatus
             * @constructor
             * @param {Ydb.Monitoring.ILoadAverageStatus=} [properties] Properties to set
             */
            function LoadAverageStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadAverageStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @instance
             */
            LoadAverageStatus.prototype.overall = 0;

            /**
             * LoadAverageStatus load.
             * @member {number} load
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @instance
             */
            LoadAverageStatus.prototype.load = 0;

            /**
             * LoadAverageStatus cores.
             * @member {number} cores
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @instance
             */
            LoadAverageStatus.prototype.cores = 0;

            /**
             * Creates a new LoadAverageStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @static
             * @param {Ydb.Monitoring.ILoadAverageStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LoadAverageStatus} LoadAverageStatus instance
             */
            LoadAverageStatus.create = function create(properties) {
                return new LoadAverageStatus(properties);
            };

            /**
             * Encodes the specified LoadAverageStatus message. Does not implicitly {@link Ydb.Monitoring.LoadAverageStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @static
             * @param {Ydb.Monitoring.ILoadAverageStatus} message LoadAverageStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadAverageStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.overall);
                if (message.load != null && message.hasOwnProperty("load"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.load);
                if (message.cores != null && message.hasOwnProperty("cores"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.cores);
                return writer;
            };

            /**
             * Encodes the specified LoadAverageStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.LoadAverageStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @static
             * @param {Ydb.Monitoring.ILoadAverageStatus} message LoadAverageStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadAverageStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadAverageStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LoadAverageStatus} LoadAverageStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadAverageStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LoadAverageStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.overall = reader.int32();
                        break;
                    case 2:
                        message.load = reader.float();
                        break;
                    case 3:
                        message.cores = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadAverageStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LoadAverageStatus} LoadAverageStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadAverageStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadAverageStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadAverageStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.load != null && message.hasOwnProperty("load"))
                    if (typeof message.load !== "number")
                        return "load: number expected";
                if (message.cores != null && message.hasOwnProperty("cores"))
                    if (!$util.isInteger(message.cores))
                        return "cores: integer expected";
                return null;
            };

            /**
             * Creates a LoadAverageStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LoadAverageStatus} LoadAverageStatus
             */
            LoadAverageStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LoadAverageStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.LoadAverageStatus();
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                if (object.load != null)
                    message.load = Number(object.load);
                if (object.cores != null)
                    message.cores = object.cores >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a LoadAverageStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @static
             * @param {Ydb.Monitoring.LoadAverageStatus} message LoadAverageStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadAverageStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                    object.load = 0;
                    object.cores = 0;
                }
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.load != null && message.hasOwnProperty("load"))
                    object.load = options.json && !isFinite(message.load) ? String(message.load) : message.load;
                if (message.cores != null && message.hasOwnProperty("cores"))
                    object.cores = message.cores;
                return object;
            };

            /**
             * Converts this LoadAverageStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LoadAverageStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadAverageStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LoadAverageStatus;
        })();

        Monitoring.ComputeNodeStatus = (function() {

            /**
             * Properties of a ComputeNodeStatus.
             * @memberof Ydb.Monitoring
             * @interface IComputeNodeStatus
             * @property {string|null} [id] ComputeNodeStatus id
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] ComputeNodeStatus overall
             * @property {Array.<Ydb.Monitoring.IComputeTabletStatus>|null} [tablets] ComputeNodeStatus tablets
             * @property {Array.<Ydb.Monitoring.IThreadPoolStatus>|null} [pools] ComputeNodeStatus pools
             * @property {Ydb.Monitoring.ILoadAverageStatus|null} [load] ComputeNodeStatus load
             */

            /**
             * Constructs a new ComputeNodeStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a ComputeNodeStatus.
             * @implements IComputeNodeStatus
             * @constructor
             * @param {Ydb.Monitoring.IComputeNodeStatus=} [properties] Properties to set
             */
            function ComputeNodeStatus(properties) {
                this.tablets = [];
                this.pools = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComputeNodeStatus id.
             * @member {string} id
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @instance
             */
            ComputeNodeStatus.prototype.id = "";

            /**
             * ComputeNodeStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @instance
             */
            ComputeNodeStatus.prototype.overall = 0;

            /**
             * ComputeNodeStatus tablets.
             * @member {Array.<Ydb.Monitoring.IComputeTabletStatus>} tablets
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @instance
             */
            ComputeNodeStatus.prototype.tablets = $util.emptyArray;

            /**
             * ComputeNodeStatus pools.
             * @member {Array.<Ydb.Monitoring.IThreadPoolStatus>} pools
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @instance
             */
            ComputeNodeStatus.prototype.pools = $util.emptyArray;

            /**
             * ComputeNodeStatus load.
             * @member {Ydb.Monitoring.ILoadAverageStatus|null|undefined} load
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @instance
             */
            ComputeNodeStatus.prototype.load = null;

            /**
             * Creates a new ComputeNodeStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @static
             * @param {Ydb.Monitoring.IComputeNodeStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.ComputeNodeStatus} ComputeNodeStatus instance
             */
            ComputeNodeStatus.create = function create(properties) {
                return new ComputeNodeStatus(properties);
            };

            /**
             * Encodes the specified ComputeNodeStatus message. Does not implicitly {@link Ydb.Monitoring.ComputeNodeStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @static
             * @param {Ydb.Monitoring.IComputeNodeStatus} message ComputeNodeStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeNodeStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.overall);
                if (message.tablets != null && message.tablets.length)
                    for (var i = 0; i < message.tablets.length; ++i)
                        $root.Ydb.Monitoring.ComputeTabletStatus.encode(message.tablets[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.pools != null && message.pools.length)
                    for (var i = 0; i < message.pools.length; ++i)
                        $root.Ydb.Monitoring.ThreadPoolStatus.encode(message.pools[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.load != null && message.hasOwnProperty("load"))
                    $root.Ydb.Monitoring.LoadAverageStatus.encode(message.load, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ComputeNodeStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.ComputeNodeStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @static
             * @param {Ydb.Monitoring.IComputeNodeStatus} message ComputeNodeStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeNodeStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComputeNodeStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.ComputeNodeStatus} ComputeNodeStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeNodeStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.ComputeNodeStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.overall = reader.int32();
                        break;
                    case 3:
                        if (!(message.tablets && message.tablets.length))
                            message.tablets = [];
                        message.tablets.push($root.Ydb.Monitoring.ComputeTabletStatus.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.pools && message.pools.length))
                            message.pools = [];
                        message.pools.push($root.Ydb.Monitoring.ThreadPoolStatus.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.load = $root.Ydb.Monitoring.LoadAverageStatus.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ComputeNodeStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.ComputeNodeStatus} ComputeNodeStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeNodeStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComputeNodeStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComputeNodeStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.tablets != null && message.hasOwnProperty("tablets")) {
                    if (!Array.isArray(message.tablets))
                        return "tablets: array expected";
                    for (var i = 0; i < message.tablets.length; ++i) {
                        var error = $root.Ydb.Monitoring.ComputeTabletStatus.verify(message.tablets[i]);
                        if (error)
                            return "tablets." + error;
                    }
                }
                if (message.pools != null && message.hasOwnProperty("pools")) {
                    if (!Array.isArray(message.pools))
                        return "pools: array expected";
                    for (var i = 0; i < message.pools.length; ++i) {
                        var error = $root.Ydb.Monitoring.ThreadPoolStatus.verify(message.pools[i]);
                        if (error)
                            return "pools." + error;
                    }
                }
                if (message.load != null && message.hasOwnProperty("load")) {
                    var error = $root.Ydb.Monitoring.LoadAverageStatus.verify(message.load);
                    if (error)
                        return "load." + error;
                }
                return null;
            };

            /**
             * Creates a ComputeNodeStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.ComputeNodeStatus} ComputeNodeStatus
             */
            ComputeNodeStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.ComputeNodeStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.ComputeNodeStatus();
                if (object.id != null)
                    message.id = String(object.id);
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                if (object.tablets) {
                    if (!Array.isArray(object.tablets))
                        throw TypeError(".Ydb.Monitoring.ComputeNodeStatus.tablets: array expected");
                    message.tablets = [];
                    for (var i = 0; i < object.tablets.length; ++i) {
                        if (typeof object.tablets[i] !== "object")
                            throw TypeError(".Ydb.Monitoring.ComputeNodeStatus.tablets: object expected");
                        message.tablets[i] = $root.Ydb.Monitoring.ComputeTabletStatus.fromObject(object.tablets[i]);
                    }
                }
                if (object.pools) {
                    if (!Array.isArray(object.pools))
                        throw TypeError(".Ydb.Monitoring.ComputeNodeStatus.pools: array expected");
                    message.pools = [];
                    for (var i = 0; i < object.pools.length; ++i) {
                        if (typeof object.pools[i] !== "object")
                            throw TypeError(".Ydb.Monitoring.ComputeNodeStatus.pools: object expected");
                        message.pools[i] = $root.Ydb.Monitoring.ThreadPoolStatus.fromObject(object.pools[i]);
                    }
                }
                if (object.load != null) {
                    if (typeof object.load !== "object")
                        throw TypeError(".Ydb.Monitoring.ComputeNodeStatus.load: object expected");
                    message.load = $root.Ydb.Monitoring.LoadAverageStatus.fromObject(object.load);
                }
                return message;
            };

            /**
             * Creates a plain object from a ComputeNodeStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @static
             * @param {Ydb.Monitoring.ComputeNodeStatus} message ComputeNodeStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComputeNodeStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.tablets = [];
                    object.pools = [];
                }
                if (options.defaults) {
                    object.id = "";
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                    object.load = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.tablets && message.tablets.length) {
                    object.tablets = [];
                    for (var j = 0; j < message.tablets.length; ++j)
                        object.tablets[j] = $root.Ydb.Monitoring.ComputeTabletStatus.toObject(message.tablets[j], options);
                }
                if (message.pools && message.pools.length) {
                    object.pools = [];
                    for (var j = 0; j < message.pools.length; ++j)
                        object.pools[j] = $root.Ydb.Monitoring.ThreadPoolStatus.toObject(message.pools[j], options);
                }
                if (message.load != null && message.hasOwnProperty("load"))
                    object.load = $root.Ydb.Monitoring.LoadAverageStatus.toObject(message.load, options);
                return object;
            };

            /**
             * Converts this ComputeNodeStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.ComputeNodeStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComputeNodeStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ComputeNodeStatus;
        })();

        Monitoring.ComputeStatus = (function() {

            /**
             * Properties of a ComputeStatus.
             * @memberof Ydb.Monitoring
             * @interface IComputeStatus
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] ComputeStatus overall
             * @property {Array.<Ydb.Monitoring.IComputeNodeStatus>|null} [nodes] ComputeStatus nodes
             */

            /**
             * Constructs a new ComputeStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a ComputeStatus.
             * @implements IComputeStatus
             * @constructor
             * @param {Ydb.Monitoring.IComputeStatus=} [properties] Properties to set
             */
            function ComputeStatus(properties) {
                this.nodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComputeStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.ComputeStatus
             * @instance
             */
            ComputeStatus.prototype.overall = 0;

            /**
             * ComputeStatus nodes.
             * @member {Array.<Ydb.Monitoring.IComputeNodeStatus>} nodes
             * @memberof Ydb.Monitoring.ComputeStatus
             * @instance
             */
            ComputeStatus.prototype.nodes = $util.emptyArray;

            /**
             * Creates a new ComputeStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.ComputeStatus
             * @static
             * @param {Ydb.Monitoring.IComputeStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.ComputeStatus} ComputeStatus instance
             */
            ComputeStatus.create = function create(properties) {
                return new ComputeStatus(properties);
            };

            /**
             * Encodes the specified ComputeStatus message. Does not implicitly {@link Ydb.Monitoring.ComputeStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.ComputeStatus
             * @static
             * @param {Ydb.Monitoring.IComputeStatus} message ComputeStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.overall);
                if (message.nodes != null && message.nodes.length)
                    for (var i = 0; i < message.nodes.length; ++i)
                        $root.Ydb.Monitoring.ComputeNodeStatus.encode(message.nodes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ComputeStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.ComputeStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.ComputeStatus
             * @static
             * @param {Ydb.Monitoring.IComputeStatus} message ComputeStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComputeStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.ComputeStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.ComputeStatus} ComputeStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.ComputeStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.overall = reader.int32();
                        break;
                    case 2:
                        if (!(message.nodes && message.nodes.length))
                            message.nodes = [];
                        message.nodes.push($root.Ydb.Monitoring.ComputeNodeStatus.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ComputeStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.ComputeStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.ComputeStatus} ComputeStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComputeStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.ComputeStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComputeStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.nodes != null && message.hasOwnProperty("nodes")) {
                    if (!Array.isArray(message.nodes))
                        return "nodes: array expected";
                    for (var i = 0; i < message.nodes.length; ++i) {
                        var error = $root.Ydb.Monitoring.ComputeNodeStatus.verify(message.nodes[i]);
                        if (error)
                            return "nodes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ComputeStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.ComputeStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.ComputeStatus} ComputeStatus
             */
            ComputeStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.ComputeStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.ComputeStatus();
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                if (object.nodes) {
                    if (!Array.isArray(object.nodes))
                        throw TypeError(".Ydb.Monitoring.ComputeStatus.nodes: array expected");
                    message.nodes = [];
                    for (var i = 0; i < object.nodes.length; ++i) {
                        if (typeof object.nodes[i] !== "object")
                            throw TypeError(".Ydb.Monitoring.ComputeStatus.nodes: object expected");
                        message.nodes[i] = $root.Ydb.Monitoring.ComputeNodeStatus.fromObject(object.nodes[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ComputeStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.ComputeStatus
             * @static
             * @param {Ydb.Monitoring.ComputeStatus} message ComputeStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComputeStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.nodes = [];
                if (options.defaults)
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.nodes && message.nodes.length) {
                    object.nodes = [];
                    for (var j = 0; j < message.nodes.length; ++j)
                        object.nodes[j] = $root.Ydb.Monitoring.ComputeNodeStatus.toObject(message.nodes[j], options);
                }
                return object;
            };

            /**
             * Converts this ComputeStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.ComputeStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComputeStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ComputeStatus;
        })();

        Monitoring.LocationNode = (function() {

            /**
             * Properties of a LocationNode.
             * @memberof Ydb.Monitoring
             * @interface ILocationNode
             * @property {number|null} [id] LocationNode id
             * @property {string|null} [host] LocationNode host
             * @property {number|null} [port] LocationNode port
             */

            /**
             * Constructs a new LocationNode.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LocationNode.
             * @implements ILocationNode
             * @constructor
             * @param {Ydb.Monitoring.ILocationNode=} [properties] Properties to set
             */
            function LocationNode(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationNode id.
             * @member {number} id
             * @memberof Ydb.Monitoring.LocationNode
             * @instance
             */
            LocationNode.prototype.id = 0;

            /**
             * LocationNode host.
             * @member {string} host
             * @memberof Ydb.Monitoring.LocationNode
             * @instance
             */
            LocationNode.prototype.host = "";

            /**
             * LocationNode port.
             * @member {number} port
             * @memberof Ydb.Monitoring.LocationNode
             * @instance
             */
            LocationNode.prototype.port = 0;

            /**
             * Creates a new LocationNode instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LocationNode
             * @static
             * @param {Ydb.Monitoring.ILocationNode=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LocationNode} LocationNode instance
             */
            LocationNode.create = function create(properties) {
                return new LocationNode(properties);
            };

            /**
             * Encodes the specified LocationNode message. Does not implicitly {@link Ydb.Monitoring.LocationNode.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LocationNode
             * @static
             * @param {Ydb.Monitoring.ILocationNode} message LocationNode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationNode.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.port);
                return writer;
            };

            /**
             * Encodes the specified LocationNode message, length delimited. Does not implicitly {@link Ydb.Monitoring.LocationNode.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LocationNode
             * @static
             * @param {Ydb.Monitoring.ILocationNode} message LocationNode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationNode.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationNode message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LocationNode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LocationNode} LocationNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationNode.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LocationNode();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.host = reader.string();
                        break;
                    case 3:
                        message.port = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationNode message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LocationNode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LocationNode} LocationNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationNode.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationNode message.
             * @function verify
             * @memberof Ydb.Monitoring.LocationNode
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationNode.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                return null;
            };

            /**
             * Creates a LocationNode message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LocationNode
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LocationNode} LocationNode
             */
            LocationNode.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LocationNode)
                    return object;
                var message = new $root.Ydb.Monitoring.LocationNode();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a LocationNode message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LocationNode
             * @static
             * @param {Ydb.Monitoring.LocationNode} message LocationNode
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationNode.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.host = "";
                    object.port = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                return object;
            };

            /**
             * Converts this LocationNode to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LocationNode
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationNode.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationNode;
        })();

        Monitoring.LocationStoragePDisk = (function() {

            /**
             * Properties of a LocationStoragePDisk.
             * @memberof Ydb.Monitoring
             * @interface ILocationStoragePDisk
             * @property {string|null} [id] LocationStoragePDisk id
             * @property {string|null} [path] LocationStoragePDisk path
             */

            /**
             * Constructs a new LocationStoragePDisk.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LocationStoragePDisk.
             * @implements ILocationStoragePDisk
             * @constructor
             * @param {Ydb.Monitoring.ILocationStoragePDisk=} [properties] Properties to set
             */
            function LocationStoragePDisk(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationStoragePDisk id.
             * @member {string} id
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @instance
             */
            LocationStoragePDisk.prototype.id = "";

            /**
             * LocationStoragePDisk path.
             * @member {string} path
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @instance
             */
            LocationStoragePDisk.prototype.path = "";

            /**
             * Creates a new LocationStoragePDisk instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @static
             * @param {Ydb.Monitoring.ILocationStoragePDisk=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LocationStoragePDisk} LocationStoragePDisk instance
             */
            LocationStoragePDisk.create = function create(properties) {
                return new LocationStoragePDisk(properties);
            };

            /**
             * Encodes the specified LocationStoragePDisk message. Does not implicitly {@link Ydb.Monitoring.LocationStoragePDisk.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @static
             * @param {Ydb.Monitoring.ILocationStoragePDisk} message LocationStoragePDisk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStoragePDisk.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified LocationStoragePDisk message, length delimited. Does not implicitly {@link Ydb.Monitoring.LocationStoragePDisk.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @static
             * @param {Ydb.Monitoring.ILocationStoragePDisk} message LocationStoragePDisk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStoragePDisk.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationStoragePDisk message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LocationStoragePDisk} LocationStoragePDisk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStoragePDisk.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LocationStoragePDisk();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationStoragePDisk message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LocationStoragePDisk} LocationStoragePDisk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStoragePDisk.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationStoragePDisk message.
             * @function verify
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationStoragePDisk.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a LocationStoragePDisk message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LocationStoragePDisk} LocationStoragePDisk
             */
            LocationStoragePDisk.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LocationStoragePDisk)
                    return object;
                var message = new $root.Ydb.Monitoring.LocationStoragePDisk();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a LocationStoragePDisk message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @static
             * @param {Ydb.Monitoring.LocationStoragePDisk} message LocationStoragePDisk
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationStoragePDisk.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.path = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this LocationStoragePDisk to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LocationStoragePDisk
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationStoragePDisk.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationStoragePDisk;
        })();

        Monitoring.LocationStorageVDisk = (function() {

            /**
             * Properties of a LocationStorageVDisk.
             * @memberof Ydb.Monitoring
             * @interface ILocationStorageVDisk
             * @property {string|null} [id] LocationStorageVDisk id
             * @property {Ydb.Monitoring.ILocationStoragePDisk|null} [pdisk] LocationStorageVDisk pdisk
             */

            /**
             * Constructs a new LocationStorageVDisk.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LocationStorageVDisk.
             * @implements ILocationStorageVDisk
             * @constructor
             * @param {Ydb.Monitoring.ILocationStorageVDisk=} [properties] Properties to set
             */
            function LocationStorageVDisk(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationStorageVDisk id.
             * @member {string} id
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @instance
             */
            LocationStorageVDisk.prototype.id = "";

            /**
             * LocationStorageVDisk pdisk.
             * @member {Ydb.Monitoring.ILocationStoragePDisk|null|undefined} pdisk
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @instance
             */
            LocationStorageVDisk.prototype.pdisk = null;

            /**
             * Creates a new LocationStorageVDisk instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @static
             * @param {Ydb.Monitoring.ILocationStorageVDisk=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LocationStorageVDisk} LocationStorageVDisk instance
             */
            LocationStorageVDisk.create = function create(properties) {
                return new LocationStorageVDisk(properties);
            };

            /**
             * Encodes the specified LocationStorageVDisk message. Does not implicitly {@link Ydb.Monitoring.LocationStorageVDisk.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @static
             * @param {Ydb.Monitoring.ILocationStorageVDisk} message LocationStorageVDisk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStorageVDisk.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.pdisk != null && message.hasOwnProperty("pdisk"))
                    $root.Ydb.Monitoring.LocationStoragePDisk.encode(message.pdisk, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LocationStorageVDisk message, length delimited. Does not implicitly {@link Ydb.Monitoring.LocationStorageVDisk.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @static
             * @param {Ydb.Monitoring.ILocationStorageVDisk} message LocationStorageVDisk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStorageVDisk.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationStorageVDisk message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LocationStorageVDisk} LocationStorageVDisk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStorageVDisk.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LocationStorageVDisk();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.pdisk = $root.Ydb.Monitoring.LocationStoragePDisk.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationStorageVDisk message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LocationStorageVDisk} LocationStorageVDisk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStorageVDisk.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationStorageVDisk message.
             * @function verify
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationStorageVDisk.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.pdisk != null && message.hasOwnProperty("pdisk")) {
                    var error = $root.Ydb.Monitoring.LocationStoragePDisk.verify(message.pdisk);
                    if (error)
                        return "pdisk." + error;
                }
                return null;
            };

            /**
             * Creates a LocationStorageVDisk message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LocationStorageVDisk} LocationStorageVDisk
             */
            LocationStorageVDisk.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LocationStorageVDisk)
                    return object;
                var message = new $root.Ydb.Monitoring.LocationStorageVDisk();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.pdisk != null) {
                    if (typeof object.pdisk !== "object")
                        throw TypeError(".Ydb.Monitoring.LocationStorageVDisk.pdisk: object expected");
                    message.pdisk = $root.Ydb.Monitoring.LocationStoragePDisk.fromObject(object.pdisk);
                }
                return message;
            };

            /**
             * Creates a plain object from a LocationStorageVDisk message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @static
             * @param {Ydb.Monitoring.LocationStorageVDisk} message LocationStorageVDisk
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationStorageVDisk.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.pdisk = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.pdisk != null && message.hasOwnProperty("pdisk"))
                    object.pdisk = $root.Ydb.Monitoring.LocationStoragePDisk.toObject(message.pdisk, options);
                return object;
            };

            /**
             * Converts this LocationStorageVDisk to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LocationStorageVDisk
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationStorageVDisk.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationStorageVDisk;
        })();

        Monitoring.LocationStorageGroup = (function() {

            /**
             * Properties of a LocationStorageGroup.
             * @memberof Ydb.Monitoring
             * @interface ILocationStorageGroup
             * @property {number|null} [id] LocationStorageGroup id
             * @property {Ydb.Monitoring.ILocationStorageVDisk|null} [vdisk] LocationStorageGroup vdisk
             */

            /**
             * Constructs a new LocationStorageGroup.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LocationStorageGroup.
             * @implements ILocationStorageGroup
             * @constructor
             * @param {Ydb.Monitoring.ILocationStorageGroup=} [properties] Properties to set
             */
            function LocationStorageGroup(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationStorageGroup id.
             * @member {number} id
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @instance
             */
            LocationStorageGroup.prototype.id = 0;

            /**
             * LocationStorageGroup vdisk.
             * @member {Ydb.Monitoring.ILocationStorageVDisk|null|undefined} vdisk
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @instance
             */
            LocationStorageGroup.prototype.vdisk = null;

            /**
             * Creates a new LocationStorageGroup instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @static
             * @param {Ydb.Monitoring.ILocationStorageGroup=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LocationStorageGroup} LocationStorageGroup instance
             */
            LocationStorageGroup.create = function create(properties) {
                return new LocationStorageGroup(properties);
            };

            /**
             * Encodes the specified LocationStorageGroup message. Does not implicitly {@link Ydb.Monitoring.LocationStorageGroup.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @static
             * @param {Ydb.Monitoring.ILocationStorageGroup} message LocationStorageGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStorageGroup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.vdisk != null && message.hasOwnProperty("vdisk"))
                    $root.Ydb.Monitoring.LocationStorageVDisk.encode(message.vdisk, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LocationStorageGroup message, length delimited. Does not implicitly {@link Ydb.Monitoring.LocationStorageGroup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @static
             * @param {Ydb.Monitoring.ILocationStorageGroup} message LocationStorageGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStorageGroup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationStorageGroup message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LocationStorageGroup} LocationStorageGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStorageGroup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LocationStorageGroup();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.vdisk = $root.Ydb.Monitoring.LocationStorageVDisk.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationStorageGroup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LocationStorageGroup} LocationStorageGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStorageGroup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationStorageGroup message.
             * @function verify
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationStorageGroup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.vdisk != null && message.hasOwnProperty("vdisk")) {
                    var error = $root.Ydb.Monitoring.LocationStorageVDisk.verify(message.vdisk);
                    if (error)
                        return "vdisk." + error;
                }
                return null;
            };

            /**
             * Creates a LocationStorageGroup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LocationStorageGroup} LocationStorageGroup
             */
            LocationStorageGroup.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LocationStorageGroup)
                    return object;
                var message = new $root.Ydb.Monitoring.LocationStorageGroup();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.vdisk != null) {
                    if (typeof object.vdisk !== "object")
                        throw TypeError(".Ydb.Monitoring.LocationStorageGroup.vdisk: object expected");
                    message.vdisk = $root.Ydb.Monitoring.LocationStorageVDisk.fromObject(object.vdisk);
                }
                return message;
            };

            /**
             * Creates a plain object from a LocationStorageGroup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @static
             * @param {Ydb.Monitoring.LocationStorageGroup} message LocationStorageGroup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationStorageGroup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.vdisk = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.vdisk != null && message.hasOwnProperty("vdisk"))
                    object.vdisk = $root.Ydb.Monitoring.LocationStorageVDisk.toObject(message.vdisk, options);
                return object;
            };

            /**
             * Converts this LocationStorageGroup to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LocationStorageGroup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationStorageGroup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationStorageGroup;
        })();

        Monitoring.LocationStoragePool = (function() {

            /**
             * Properties of a LocationStoragePool.
             * @memberof Ydb.Monitoring
             * @interface ILocationStoragePool
             * @property {string|null} [name] LocationStoragePool name
             * @property {Ydb.Monitoring.ILocationStorageGroup|null} [group] LocationStoragePool group
             */

            /**
             * Constructs a new LocationStoragePool.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LocationStoragePool.
             * @implements ILocationStoragePool
             * @constructor
             * @param {Ydb.Monitoring.ILocationStoragePool=} [properties] Properties to set
             */
            function LocationStoragePool(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationStoragePool name.
             * @member {string} name
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @instance
             */
            LocationStoragePool.prototype.name = "";

            /**
             * LocationStoragePool group.
             * @member {Ydb.Monitoring.ILocationStorageGroup|null|undefined} group
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @instance
             */
            LocationStoragePool.prototype.group = null;

            /**
             * Creates a new LocationStoragePool instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @static
             * @param {Ydb.Monitoring.ILocationStoragePool=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LocationStoragePool} LocationStoragePool instance
             */
            LocationStoragePool.create = function create(properties) {
                return new LocationStoragePool(properties);
            };

            /**
             * Encodes the specified LocationStoragePool message. Does not implicitly {@link Ydb.Monitoring.LocationStoragePool.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @static
             * @param {Ydb.Monitoring.ILocationStoragePool} message LocationStoragePool message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStoragePool.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.group != null && message.hasOwnProperty("group"))
                    $root.Ydb.Monitoring.LocationStorageGroup.encode(message.group, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LocationStoragePool message, length delimited. Does not implicitly {@link Ydb.Monitoring.LocationStoragePool.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @static
             * @param {Ydb.Monitoring.ILocationStoragePool} message LocationStoragePool message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStoragePool.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationStoragePool message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LocationStoragePool} LocationStoragePool
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStoragePool.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LocationStoragePool();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.group = $root.Ydb.Monitoring.LocationStorageGroup.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationStoragePool message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LocationStoragePool} LocationStoragePool
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStoragePool.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationStoragePool message.
             * @function verify
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationStoragePool.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.group != null && message.hasOwnProperty("group")) {
                    var error = $root.Ydb.Monitoring.LocationStorageGroup.verify(message.group);
                    if (error)
                        return "group." + error;
                }
                return null;
            };

            /**
             * Creates a LocationStoragePool message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LocationStoragePool} LocationStoragePool
             */
            LocationStoragePool.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LocationStoragePool)
                    return object;
                var message = new $root.Ydb.Monitoring.LocationStoragePool();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.group != null) {
                    if (typeof object.group !== "object")
                        throw TypeError(".Ydb.Monitoring.LocationStoragePool.group: object expected");
                    message.group = $root.Ydb.Monitoring.LocationStorageGroup.fromObject(object.group);
                }
                return message;
            };

            /**
             * Creates a plain object from a LocationStoragePool message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @static
             * @param {Ydb.Monitoring.LocationStoragePool} message LocationStoragePool
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationStoragePool.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.group = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.group != null && message.hasOwnProperty("group"))
                    object.group = $root.Ydb.Monitoring.LocationStorageGroup.toObject(message.group, options);
                return object;
            };

            /**
             * Converts this LocationStoragePool to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LocationStoragePool
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationStoragePool.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationStoragePool;
        })();

        Monitoring.LocationStorage = (function() {

            /**
             * Properties of a LocationStorage.
             * @memberof Ydb.Monitoring
             * @interface ILocationStorage
             * @property {Ydb.Monitoring.ILocationNode|null} [node] LocationStorage node
             * @property {Ydb.Monitoring.ILocationStoragePool|null} [pool] LocationStorage pool
             */

            /**
             * Constructs a new LocationStorage.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LocationStorage.
             * @implements ILocationStorage
             * @constructor
             * @param {Ydb.Monitoring.ILocationStorage=} [properties] Properties to set
             */
            function LocationStorage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationStorage node.
             * @member {Ydb.Monitoring.ILocationNode|null|undefined} node
             * @memberof Ydb.Monitoring.LocationStorage
             * @instance
             */
            LocationStorage.prototype.node = null;

            /**
             * LocationStorage pool.
             * @member {Ydb.Monitoring.ILocationStoragePool|null|undefined} pool
             * @memberof Ydb.Monitoring.LocationStorage
             * @instance
             */
            LocationStorage.prototype.pool = null;

            /**
             * Creates a new LocationStorage instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LocationStorage
             * @static
             * @param {Ydb.Monitoring.ILocationStorage=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LocationStorage} LocationStorage instance
             */
            LocationStorage.create = function create(properties) {
                return new LocationStorage(properties);
            };

            /**
             * Encodes the specified LocationStorage message. Does not implicitly {@link Ydb.Monitoring.LocationStorage.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LocationStorage
             * @static
             * @param {Ydb.Monitoring.ILocationStorage} message LocationStorage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStorage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.node != null && message.hasOwnProperty("node"))
                    $root.Ydb.Monitoring.LocationNode.encode(message.node, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.pool != null && message.hasOwnProperty("pool"))
                    $root.Ydb.Monitoring.LocationStoragePool.encode(message.pool, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LocationStorage message, length delimited. Does not implicitly {@link Ydb.Monitoring.LocationStorage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LocationStorage
             * @static
             * @param {Ydb.Monitoring.ILocationStorage} message LocationStorage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationStorage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationStorage message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LocationStorage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LocationStorage} LocationStorage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStorage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LocationStorage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.node = $root.Ydb.Monitoring.LocationNode.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.pool = $root.Ydb.Monitoring.LocationStoragePool.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationStorage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LocationStorage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LocationStorage} LocationStorage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationStorage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationStorage message.
             * @function verify
             * @memberof Ydb.Monitoring.LocationStorage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationStorage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.node != null && message.hasOwnProperty("node")) {
                    var error = $root.Ydb.Monitoring.LocationNode.verify(message.node);
                    if (error)
                        return "node." + error;
                }
                if (message.pool != null && message.hasOwnProperty("pool")) {
                    var error = $root.Ydb.Monitoring.LocationStoragePool.verify(message.pool);
                    if (error)
                        return "pool." + error;
                }
                return null;
            };

            /**
             * Creates a LocationStorage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LocationStorage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LocationStorage} LocationStorage
             */
            LocationStorage.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LocationStorage)
                    return object;
                var message = new $root.Ydb.Monitoring.LocationStorage();
                if (object.node != null) {
                    if (typeof object.node !== "object")
                        throw TypeError(".Ydb.Monitoring.LocationStorage.node: object expected");
                    message.node = $root.Ydb.Monitoring.LocationNode.fromObject(object.node);
                }
                if (object.pool != null) {
                    if (typeof object.pool !== "object")
                        throw TypeError(".Ydb.Monitoring.LocationStorage.pool: object expected");
                    message.pool = $root.Ydb.Monitoring.LocationStoragePool.fromObject(object.pool);
                }
                return message;
            };

            /**
             * Creates a plain object from a LocationStorage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LocationStorage
             * @static
             * @param {Ydb.Monitoring.LocationStorage} message LocationStorage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationStorage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.node = null;
                    object.pool = null;
                }
                if (message.node != null && message.hasOwnProperty("node"))
                    object.node = $root.Ydb.Monitoring.LocationNode.toObject(message.node, options);
                if (message.pool != null && message.hasOwnProperty("pool"))
                    object.pool = $root.Ydb.Monitoring.LocationStoragePool.toObject(message.pool, options);
                return object;
            };

            /**
             * Converts this LocationStorage to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LocationStorage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationStorage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationStorage;
        })();

        Monitoring.LocationComputePool = (function() {

            /**
             * Properties of a LocationComputePool.
             * @memberof Ydb.Monitoring
             * @interface ILocationComputePool
             * @property {string|null} [name] LocationComputePool name
             */

            /**
             * Constructs a new LocationComputePool.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LocationComputePool.
             * @implements ILocationComputePool
             * @constructor
             * @param {Ydb.Monitoring.ILocationComputePool=} [properties] Properties to set
             */
            function LocationComputePool(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationComputePool name.
             * @member {string} name
             * @memberof Ydb.Monitoring.LocationComputePool
             * @instance
             */
            LocationComputePool.prototype.name = "";

            /**
             * Creates a new LocationComputePool instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LocationComputePool
             * @static
             * @param {Ydb.Monitoring.ILocationComputePool=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LocationComputePool} LocationComputePool instance
             */
            LocationComputePool.create = function create(properties) {
                return new LocationComputePool(properties);
            };

            /**
             * Encodes the specified LocationComputePool message. Does not implicitly {@link Ydb.Monitoring.LocationComputePool.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LocationComputePool
             * @static
             * @param {Ydb.Monitoring.ILocationComputePool} message LocationComputePool message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationComputePool.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified LocationComputePool message, length delimited. Does not implicitly {@link Ydb.Monitoring.LocationComputePool.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LocationComputePool
             * @static
             * @param {Ydb.Monitoring.ILocationComputePool} message LocationComputePool message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationComputePool.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationComputePool message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LocationComputePool
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LocationComputePool} LocationComputePool
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationComputePool.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LocationComputePool();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationComputePool message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LocationComputePool
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LocationComputePool} LocationComputePool
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationComputePool.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationComputePool message.
             * @function verify
             * @memberof Ydb.Monitoring.LocationComputePool
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationComputePool.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a LocationComputePool message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LocationComputePool
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LocationComputePool} LocationComputePool
             */
            LocationComputePool.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LocationComputePool)
                    return object;
                var message = new $root.Ydb.Monitoring.LocationComputePool();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a LocationComputePool message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LocationComputePool
             * @static
             * @param {Ydb.Monitoring.LocationComputePool} message LocationComputePool
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationComputePool.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this LocationComputePool to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LocationComputePool
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationComputePool.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationComputePool;
        })();

        Monitoring.LocationComputeTablet = (function() {

            /**
             * Properties of a LocationComputeTablet.
             * @memberof Ydb.Monitoring
             * @interface ILocationComputeTablet
             * @property {string|null} [type] LocationComputeTablet type
             */

            /**
             * Constructs a new LocationComputeTablet.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LocationComputeTablet.
             * @implements ILocationComputeTablet
             * @constructor
             * @param {Ydb.Monitoring.ILocationComputeTablet=} [properties] Properties to set
             */
            function LocationComputeTablet(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationComputeTablet type.
             * @member {string} type
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @instance
             */
            LocationComputeTablet.prototype.type = "";

            /**
             * Creates a new LocationComputeTablet instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @static
             * @param {Ydb.Monitoring.ILocationComputeTablet=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LocationComputeTablet} LocationComputeTablet instance
             */
            LocationComputeTablet.create = function create(properties) {
                return new LocationComputeTablet(properties);
            };

            /**
             * Encodes the specified LocationComputeTablet message. Does not implicitly {@link Ydb.Monitoring.LocationComputeTablet.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @static
             * @param {Ydb.Monitoring.ILocationComputeTablet} message LocationComputeTablet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationComputeTablet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                return writer;
            };

            /**
             * Encodes the specified LocationComputeTablet message, length delimited. Does not implicitly {@link Ydb.Monitoring.LocationComputeTablet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @static
             * @param {Ydb.Monitoring.ILocationComputeTablet} message LocationComputeTablet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationComputeTablet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationComputeTablet message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LocationComputeTablet} LocationComputeTablet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationComputeTablet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LocationComputeTablet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationComputeTablet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LocationComputeTablet} LocationComputeTablet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationComputeTablet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationComputeTablet message.
             * @function verify
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationComputeTablet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                return null;
            };

            /**
             * Creates a LocationComputeTablet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LocationComputeTablet} LocationComputeTablet
             */
            LocationComputeTablet.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LocationComputeTablet)
                    return object;
                var message = new $root.Ydb.Monitoring.LocationComputeTablet();
                if (object.type != null)
                    message.type = String(object.type);
                return message;
            };

            /**
             * Creates a plain object from a LocationComputeTablet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @static
             * @param {Ydb.Monitoring.LocationComputeTablet} message LocationComputeTablet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationComputeTablet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.type = "";
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                return object;
            };

            /**
             * Converts this LocationComputeTablet to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LocationComputeTablet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationComputeTablet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationComputeTablet;
        })();

        Monitoring.LocationCompute = (function() {

            /**
             * Properties of a LocationCompute.
             * @memberof Ydb.Monitoring
             * @interface ILocationCompute
             * @property {Ydb.Monitoring.ILocationNode|null} [node] LocationCompute node
             * @property {Ydb.Monitoring.ILocationComputePool|null} [pool] LocationCompute pool
             * @property {Ydb.Monitoring.ILocationComputeTablet|null} [tablet] LocationCompute tablet
             */

            /**
             * Constructs a new LocationCompute.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a LocationCompute.
             * @implements ILocationCompute
             * @constructor
             * @param {Ydb.Monitoring.ILocationCompute=} [properties] Properties to set
             */
            function LocationCompute(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationCompute node.
             * @member {Ydb.Monitoring.ILocationNode|null|undefined} node
             * @memberof Ydb.Monitoring.LocationCompute
             * @instance
             */
            LocationCompute.prototype.node = null;

            /**
             * LocationCompute pool.
             * @member {Ydb.Monitoring.ILocationComputePool|null|undefined} pool
             * @memberof Ydb.Monitoring.LocationCompute
             * @instance
             */
            LocationCompute.prototype.pool = null;

            /**
             * LocationCompute tablet.
             * @member {Ydb.Monitoring.ILocationComputeTablet|null|undefined} tablet
             * @memberof Ydb.Monitoring.LocationCompute
             * @instance
             */
            LocationCompute.prototype.tablet = null;

            /**
             * Creates a new LocationCompute instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.LocationCompute
             * @static
             * @param {Ydb.Monitoring.ILocationCompute=} [properties] Properties to set
             * @returns {Ydb.Monitoring.LocationCompute} LocationCompute instance
             */
            LocationCompute.create = function create(properties) {
                return new LocationCompute(properties);
            };

            /**
             * Encodes the specified LocationCompute message. Does not implicitly {@link Ydb.Monitoring.LocationCompute.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.LocationCompute
             * @static
             * @param {Ydb.Monitoring.ILocationCompute} message LocationCompute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationCompute.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.node != null && message.hasOwnProperty("node"))
                    $root.Ydb.Monitoring.LocationNode.encode(message.node, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.pool != null && message.hasOwnProperty("pool"))
                    $root.Ydb.Monitoring.LocationComputePool.encode(message.pool, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.tablet != null && message.hasOwnProperty("tablet"))
                    $root.Ydb.Monitoring.LocationComputeTablet.encode(message.tablet, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LocationCompute message, length delimited. Does not implicitly {@link Ydb.Monitoring.LocationCompute.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.LocationCompute
             * @static
             * @param {Ydb.Monitoring.ILocationCompute} message LocationCompute message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationCompute.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationCompute message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.LocationCompute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.LocationCompute} LocationCompute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationCompute.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.LocationCompute();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.node = $root.Ydb.Monitoring.LocationNode.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.pool = $root.Ydb.Monitoring.LocationComputePool.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.tablet = $root.Ydb.Monitoring.LocationComputeTablet.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationCompute message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.LocationCompute
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.LocationCompute} LocationCompute
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationCompute.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationCompute message.
             * @function verify
             * @memberof Ydb.Monitoring.LocationCompute
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationCompute.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.node != null && message.hasOwnProperty("node")) {
                    var error = $root.Ydb.Monitoring.LocationNode.verify(message.node);
                    if (error)
                        return "node." + error;
                }
                if (message.pool != null && message.hasOwnProperty("pool")) {
                    var error = $root.Ydb.Monitoring.LocationComputePool.verify(message.pool);
                    if (error)
                        return "pool." + error;
                }
                if (message.tablet != null && message.hasOwnProperty("tablet")) {
                    var error = $root.Ydb.Monitoring.LocationComputeTablet.verify(message.tablet);
                    if (error)
                        return "tablet." + error;
                }
                return null;
            };

            /**
             * Creates a LocationCompute message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.LocationCompute
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.LocationCompute} LocationCompute
             */
            LocationCompute.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.LocationCompute)
                    return object;
                var message = new $root.Ydb.Monitoring.LocationCompute();
                if (object.node != null) {
                    if (typeof object.node !== "object")
                        throw TypeError(".Ydb.Monitoring.LocationCompute.node: object expected");
                    message.node = $root.Ydb.Monitoring.LocationNode.fromObject(object.node);
                }
                if (object.pool != null) {
                    if (typeof object.pool !== "object")
                        throw TypeError(".Ydb.Monitoring.LocationCompute.pool: object expected");
                    message.pool = $root.Ydb.Monitoring.LocationComputePool.fromObject(object.pool);
                }
                if (object.tablet != null) {
                    if (typeof object.tablet !== "object")
                        throw TypeError(".Ydb.Monitoring.LocationCompute.tablet: object expected");
                    message.tablet = $root.Ydb.Monitoring.LocationComputeTablet.fromObject(object.tablet);
                }
                return message;
            };

            /**
             * Creates a plain object from a LocationCompute message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.LocationCompute
             * @static
             * @param {Ydb.Monitoring.LocationCompute} message LocationCompute
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationCompute.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.node = null;
                    object.pool = null;
                    object.tablet = null;
                }
                if (message.node != null && message.hasOwnProperty("node"))
                    object.node = $root.Ydb.Monitoring.LocationNode.toObject(message.node, options);
                if (message.pool != null && message.hasOwnProperty("pool"))
                    object.pool = $root.Ydb.Monitoring.LocationComputePool.toObject(message.pool, options);
                if (message.tablet != null && message.hasOwnProperty("tablet"))
                    object.tablet = $root.Ydb.Monitoring.LocationComputeTablet.toObject(message.tablet, options);
                return object;
            };

            /**
             * Converts this LocationCompute to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.LocationCompute
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationCompute.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LocationCompute;
        })();

        Monitoring.Location = (function() {

            /**
             * Properties of a Location.
             * @memberof Ydb.Monitoring
             * @interface ILocation
             * @property {Ydb.Monitoring.ILocationStorage|null} [storage] Location storage
             * @property {Ydb.Monitoring.ILocationCompute|null} [compute] Location compute
             */

            /**
             * Constructs a new Location.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a Location.
             * @implements ILocation
             * @constructor
             * @param {Ydb.Monitoring.ILocation=} [properties] Properties to set
             */
            function Location(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Location storage.
             * @member {Ydb.Monitoring.ILocationStorage|null|undefined} storage
             * @memberof Ydb.Monitoring.Location
             * @instance
             */
            Location.prototype.storage = null;

            /**
             * Location compute.
             * @member {Ydb.Monitoring.ILocationCompute|null|undefined} compute
             * @memberof Ydb.Monitoring.Location
             * @instance
             */
            Location.prototype.compute = null;

            /**
             * Creates a new Location instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.Location
             * @static
             * @param {Ydb.Monitoring.ILocation=} [properties] Properties to set
             * @returns {Ydb.Monitoring.Location} Location instance
             */
            Location.create = function create(properties) {
                return new Location(properties);
            };

            /**
             * Encodes the specified Location message. Does not implicitly {@link Ydb.Monitoring.Location.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.Location
             * @static
             * @param {Ydb.Monitoring.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.storage != null && message.hasOwnProperty("storage"))
                    $root.Ydb.Monitoring.LocationStorage.encode(message.storage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.compute != null && message.hasOwnProperty("compute"))
                    $root.Ydb.Monitoring.LocationCompute.encode(message.compute, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Location message, length delimited. Does not implicitly {@link Ydb.Monitoring.Location.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.Location
             * @static
             * @param {Ydb.Monitoring.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Location message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.Location();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.storage = $root.Ydb.Monitoring.LocationStorage.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.compute = $root.Ydb.Monitoring.LocationCompute.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Location message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Location message.
             * @function verify
             * @memberof Ydb.Monitoring.Location
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Location.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.storage != null && message.hasOwnProperty("storage")) {
                    var error = $root.Ydb.Monitoring.LocationStorage.verify(message.storage);
                    if (error)
                        return "storage." + error;
                }
                if (message.compute != null && message.hasOwnProperty("compute")) {
                    var error = $root.Ydb.Monitoring.LocationCompute.verify(message.compute);
                    if (error)
                        return "compute." + error;
                }
                return null;
            };

            /**
             * Creates a Location message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.Location
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.Location} Location
             */
            Location.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.Location)
                    return object;
                var message = new $root.Ydb.Monitoring.Location();
                if (object.storage != null) {
                    if (typeof object.storage !== "object")
                        throw TypeError(".Ydb.Monitoring.Location.storage: object expected");
                    message.storage = $root.Ydb.Monitoring.LocationStorage.fromObject(object.storage);
                }
                if (object.compute != null) {
                    if (typeof object.compute !== "object")
                        throw TypeError(".Ydb.Monitoring.Location.compute: object expected");
                    message.compute = $root.Ydb.Monitoring.LocationCompute.fromObject(object.compute);
                }
                return message;
            };

            /**
             * Creates a plain object from a Location message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.Location
             * @static
             * @param {Ydb.Monitoring.Location} message Location
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Location.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.storage = null;
                    object.compute = null;
                }
                if (message.storage != null && message.hasOwnProperty("storage"))
                    object.storage = $root.Ydb.Monitoring.LocationStorage.toObject(message.storage, options);
                if (message.compute != null && message.hasOwnProperty("compute"))
                    object.compute = $root.Ydb.Monitoring.LocationCompute.toObject(message.compute, options);
                return object;
            };

            /**
             * Converts this Location to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.Location
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Location.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Location;
        })();

        Monitoring.IssueLog = (function() {

            /**
             * Properties of an IssueLog.
             * @memberof Ydb.Monitoring
             * @interface IIssueLog
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [status] IssueLog status
             * @property {string|null} [message] IssueLog message
             * @property {Ydb.Monitoring.ILocation|null} [location] IssueLog location
             */

            /**
             * Constructs a new IssueLog.
             * @memberof Ydb.Monitoring
             * @classdesc Represents an IssueLog.
             * @implements IIssueLog
             * @constructor
             * @param {Ydb.Monitoring.IIssueLog=} [properties] Properties to set
             */
            function IssueLog(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IssueLog status.
             * @member {Ydb.Monitoring.StatusFlag.Status} status
             * @memberof Ydb.Monitoring.IssueLog
             * @instance
             */
            IssueLog.prototype.status = 0;

            /**
             * IssueLog message.
             * @member {string} message
             * @memberof Ydb.Monitoring.IssueLog
             * @instance
             */
            IssueLog.prototype.message = "";

            /**
             * IssueLog location.
             * @member {Ydb.Monitoring.ILocation|null|undefined} location
             * @memberof Ydb.Monitoring.IssueLog
             * @instance
             */
            IssueLog.prototype.location = null;

            /**
             * Creates a new IssueLog instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.IssueLog
             * @static
             * @param {Ydb.Monitoring.IIssueLog=} [properties] Properties to set
             * @returns {Ydb.Monitoring.IssueLog} IssueLog instance
             */
            IssueLog.create = function create(properties) {
                return new IssueLog(properties);
            };

            /**
             * Encodes the specified IssueLog message. Does not implicitly {@link Ydb.Monitoring.IssueLog.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.IssueLog
             * @static
             * @param {Ydb.Monitoring.IIssueLog} message IssueLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IssueLog.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.location != null && message.hasOwnProperty("location"))
                    $root.Ydb.Monitoring.Location.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IssueLog message, length delimited. Does not implicitly {@link Ydb.Monitoring.IssueLog.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.IssueLog
             * @static
             * @param {Ydb.Monitoring.IIssueLog} message IssueLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IssueLog.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IssueLog message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.IssueLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.IssueLog} IssueLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IssueLog.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.IssueLog();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.location = $root.Ydb.Monitoring.Location.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IssueLog message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.IssueLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.IssueLog} IssueLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IssueLog.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IssueLog message.
             * @function verify
             * @memberof Ydb.Monitoring.IssueLog
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IssueLog.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    var error = $root.Ydb.Monitoring.Location.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                return null;
            };

            /**
             * Creates an IssueLog message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.IssueLog
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.IssueLog} IssueLog
             */
            IssueLog.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.IssueLog)
                    return object;
                var message = new $root.Ydb.Monitoring.IssueLog();
                switch (object.status) {
                case "UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "GREY":
                case 1:
                    message.status = 1;
                    break;
                case "GREEN":
                case 2:
                    message.status = 2;
                    break;
                case "BLUE":
                case 3:
                    message.status = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.status = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.status = 5;
                    break;
                case "RED":
                case 6:
                    message.status = 6;
                    break;
                }
                if (object.message != null)
                    message.message = String(object.message);
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".Ydb.Monitoring.IssueLog.location: object expected");
                    message.location = $root.Ydb.Monitoring.Location.fromObject(object.location);
                }
                return message;
            };

            /**
             * Creates a plain object from an IssueLog message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.IssueLog
             * @static
             * @param {Ydb.Monitoring.IssueLog} message IssueLog
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IssueLog.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.status = options.enums === String ? "UNSPECIFIED" : 0;
                    object.message = "";
                    object.location = null;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.status] : message.status;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.Ydb.Monitoring.Location.toObject(message.location, options);
                return object;
            };

            /**
             * Converts this IssueLog to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.IssueLog
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IssueLog.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IssueLog;
        })();

        Monitoring.DatabaseStatus = (function() {

            /**
             * Properties of a DatabaseStatus.
             * @memberof Ydb.Monitoring
             * @interface IDatabaseStatus
             * @property {Ydb.Monitoring.StatusFlag.Status|null} [overall] DatabaseStatus overall
             * @property {Ydb.Monitoring.IStorageStatus|null} [storage] DatabaseStatus storage
             * @property {Ydb.Monitoring.IComputeStatus|null} [compute] DatabaseStatus compute
             */

            /**
             * Constructs a new DatabaseStatus.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a DatabaseStatus.
             * @implements IDatabaseStatus
             * @constructor
             * @param {Ydb.Monitoring.IDatabaseStatus=} [properties] Properties to set
             */
            function DatabaseStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DatabaseStatus overall.
             * @member {Ydb.Monitoring.StatusFlag.Status} overall
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @instance
             */
            DatabaseStatus.prototype.overall = 0;

            /**
             * DatabaseStatus storage.
             * @member {Ydb.Monitoring.IStorageStatus|null|undefined} storage
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @instance
             */
            DatabaseStatus.prototype.storage = null;

            /**
             * DatabaseStatus compute.
             * @member {Ydb.Monitoring.IComputeStatus|null|undefined} compute
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @instance
             */
            DatabaseStatus.prototype.compute = null;

            /**
             * Creates a new DatabaseStatus instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @static
             * @param {Ydb.Monitoring.IDatabaseStatus=} [properties] Properties to set
             * @returns {Ydb.Monitoring.DatabaseStatus} DatabaseStatus instance
             */
            DatabaseStatus.create = function create(properties) {
                return new DatabaseStatus(properties);
            };

            /**
             * Encodes the specified DatabaseStatus message. Does not implicitly {@link Ydb.Monitoring.DatabaseStatus.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @static
             * @param {Ydb.Monitoring.IDatabaseStatus} message DatabaseStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.overall != null && message.hasOwnProperty("overall"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.overall);
                if (message.storage != null && message.hasOwnProperty("storage"))
                    $root.Ydb.Monitoring.StorageStatus.encode(message.storage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.compute != null && message.hasOwnProperty("compute"))
                    $root.Ydb.Monitoring.ComputeStatus.encode(message.compute, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DatabaseStatus message, length delimited. Does not implicitly {@link Ydb.Monitoring.DatabaseStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @static
             * @param {Ydb.Monitoring.IDatabaseStatus} message DatabaseStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseStatus message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.DatabaseStatus} DatabaseStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.DatabaseStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.overall = reader.int32();
                        break;
                    case 2:
                        message.storage = $root.Ydb.Monitoring.StorageStatus.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.compute = $root.Ydb.Monitoring.ComputeStatus.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.DatabaseStatus} DatabaseStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseStatus message.
             * @function verify
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.overall != null && message.hasOwnProperty("overall"))
                    switch (message.overall) {
                    default:
                        return "overall: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.storage != null && message.hasOwnProperty("storage")) {
                    var error = $root.Ydb.Monitoring.StorageStatus.verify(message.storage);
                    if (error)
                        return "storage." + error;
                }
                if (message.compute != null && message.hasOwnProperty("compute")) {
                    var error = $root.Ydb.Monitoring.ComputeStatus.verify(message.compute);
                    if (error)
                        return "compute." + error;
                }
                return null;
            };

            /**
             * Creates a DatabaseStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.DatabaseStatus} DatabaseStatus
             */
            DatabaseStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.DatabaseStatus)
                    return object;
                var message = new $root.Ydb.Monitoring.DatabaseStatus();
                switch (object.overall) {
                case "UNSPECIFIED":
                case 0:
                    message.overall = 0;
                    break;
                case "GREY":
                case 1:
                    message.overall = 1;
                    break;
                case "GREEN":
                case 2:
                    message.overall = 2;
                    break;
                case "BLUE":
                case 3:
                    message.overall = 3;
                    break;
                case "YELLOW":
                case 4:
                    message.overall = 4;
                    break;
                case "ORANGE":
                case 5:
                    message.overall = 5;
                    break;
                case "RED":
                case 6:
                    message.overall = 6;
                    break;
                }
                if (object.storage != null) {
                    if (typeof object.storage !== "object")
                        throw TypeError(".Ydb.Monitoring.DatabaseStatus.storage: object expected");
                    message.storage = $root.Ydb.Monitoring.StorageStatus.fromObject(object.storage);
                }
                if (object.compute != null) {
                    if (typeof object.compute !== "object")
                        throw TypeError(".Ydb.Monitoring.DatabaseStatus.compute: object expected");
                    message.compute = $root.Ydb.Monitoring.ComputeStatus.fromObject(object.compute);
                }
                return message;
            };

            /**
             * Creates a plain object from a DatabaseStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @static
             * @param {Ydb.Monitoring.DatabaseStatus} message DatabaseStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.overall = options.enums === String ? "UNSPECIFIED" : 0;
                    object.storage = null;
                    object.compute = null;
                }
                if (message.overall != null && message.hasOwnProperty("overall"))
                    object.overall = options.enums === String ? $root.Ydb.Monitoring.StatusFlag.Status[message.overall] : message.overall;
                if (message.storage != null && message.hasOwnProperty("storage"))
                    object.storage = $root.Ydb.Monitoring.StorageStatus.toObject(message.storage, options);
                if (message.compute != null && message.hasOwnProperty("compute"))
                    object.compute = $root.Ydb.Monitoring.ComputeStatus.toObject(message.compute, options);
                return object;
            };

            /**
             * Converts this DatabaseStatus to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.DatabaseStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DatabaseStatus;
        })();

        Monitoring.SelfCheckResult = (function() {

            /**
             * Properties of a SelfCheckResult.
             * @memberof Ydb.Monitoring
             * @interface ISelfCheckResult
             * @property {Ydb.Monitoring.SelfCheck.Result|null} [selfCheckResult] SelfCheckResult selfCheckResult
             * @property {Array.<Ydb.Monitoring.IIssueLog>|null} [issueLog] SelfCheckResult issueLog
             * @property {Ydb.Monitoring.IDatabaseStatus|null} [databaseStatus] SelfCheckResult databaseStatus
             */

            /**
             * Constructs a new SelfCheckResult.
             * @memberof Ydb.Monitoring
             * @classdesc Represents a SelfCheckResult.
             * @implements ISelfCheckResult
             * @constructor
             * @param {Ydb.Monitoring.ISelfCheckResult=} [properties] Properties to set
             */
            function SelfCheckResult(properties) {
                this.issueLog = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SelfCheckResult selfCheckResult.
             * @member {Ydb.Monitoring.SelfCheck.Result} selfCheckResult
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @instance
             */
            SelfCheckResult.prototype.selfCheckResult = 0;

            /**
             * SelfCheckResult issueLog.
             * @member {Array.<Ydb.Monitoring.IIssueLog>} issueLog
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @instance
             */
            SelfCheckResult.prototype.issueLog = $util.emptyArray;

            /**
             * SelfCheckResult databaseStatus.
             * @member {Ydb.Monitoring.IDatabaseStatus|null|undefined} databaseStatus
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @instance
             */
            SelfCheckResult.prototype.databaseStatus = null;

            /**
             * Creates a new SelfCheckResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @static
             * @param {Ydb.Monitoring.ISelfCheckResult=} [properties] Properties to set
             * @returns {Ydb.Monitoring.SelfCheckResult} SelfCheckResult instance
             */
            SelfCheckResult.create = function create(properties) {
                return new SelfCheckResult(properties);
            };

            /**
             * Encodes the specified SelfCheckResult message. Does not implicitly {@link Ydb.Monitoring.SelfCheckResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @static
             * @param {Ydb.Monitoring.ISelfCheckResult} message SelfCheckResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelfCheckResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selfCheckResult != null && message.hasOwnProperty("selfCheckResult"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.selfCheckResult);
                if (message.issueLog != null && message.issueLog.length)
                    for (var i = 0; i < message.issueLog.length; ++i)
                        $root.Ydb.Monitoring.IssueLog.encode(message.issueLog[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.databaseStatus != null && message.hasOwnProperty("databaseStatus"))
                    $root.Ydb.Monitoring.DatabaseStatus.encode(message.databaseStatus, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SelfCheckResult message, length delimited. Does not implicitly {@link Ydb.Monitoring.SelfCheckResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @static
             * @param {Ydb.Monitoring.ISelfCheckResult} message SelfCheckResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelfCheckResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SelfCheckResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Monitoring.SelfCheckResult} SelfCheckResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelfCheckResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Monitoring.SelfCheckResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.selfCheckResult = reader.int32();
                        break;
                    case 2:
                        if (!(message.issueLog && message.issueLog.length))
                            message.issueLog = [];
                        message.issueLog.push($root.Ydb.Monitoring.IssueLog.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.databaseStatus = $root.Ydb.Monitoring.DatabaseStatus.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SelfCheckResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Monitoring.SelfCheckResult} SelfCheckResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelfCheckResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SelfCheckResult message.
             * @function verify
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SelfCheckResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.selfCheckResult != null && message.hasOwnProperty("selfCheckResult"))
                    switch (message.selfCheckResult) {
                    default:
                        return "selfCheckResult: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.issueLog != null && message.hasOwnProperty("issueLog")) {
                    if (!Array.isArray(message.issueLog))
                        return "issueLog: array expected";
                    for (var i = 0; i < message.issueLog.length; ++i) {
                        var error = $root.Ydb.Monitoring.IssueLog.verify(message.issueLog[i]);
                        if (error)
                            return "issueLog." + error;
                    }
                }
                if (message.databaseStatus != null && message.hasOwnProperty("databaseStatus")) {
                    var error = $root.Ydb.Monitoring.DatabaseStatus.verify(message.databaseStatus);
                    if (error)
                        return "databaseStatus." + error;
                }
                return null;
            };

            /**
             * Creates a SelfCheckResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Monitoring.SelfCheckResult} SelfCheckResult
             */
            SelfCheckResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Monitoring.SelfCheckResult)
                    return object;
                var message = new $root.Ydb.Monitoring.SelfCheckResult();
                switch (object.selfCheckResult) {
                case "UNSPECIFIED":
                case 0:
                    message.selfCheckResult = 0;
                    break;
                case "GOOD":
                case 1:
                    message.selfCheckResult = 1;
                    break;
                case "DEGRADED":
                case 2:
                    message.selfCheckResult = 2;
                    break;
                case "MAINTENANCE_REQUIRED":
                case 3:
                    message.selfCheckResult = 3;
                    break;
                case "EMERGENCY":
                case 4:
                    message.selfCheckResult = 4;
                    break;
                }
                if (object.issueLog) {
                    if (!Array.isArray(object.issueLog))
                        throw TypeError(".Ydb.Monitoring.SelfCheckResult.issueLog: array expected");
                    message.issueLog = [];
                    for (var i = 0; i < object.issueLog.length; ++i) {
                        if (typeof object.issueLog[i] !== "object")
                            throw TypeError(".Ydb.Monitoring.SelfCheckResult.issueLog: object expected");
                        message.issueLog[i] = $root.Ydb.Monitoring.IssueLog.fromObject(object.issueLog[i]);
                    }
                }
                if (object.databaseStatus != null) {
                    if (typeof object.databaseStatus !== "object")
                        throw TypeError(".Ydb.Monitoring.SelfCheckResult.databaseStatus: object expected");
                    message.databaseStatus = $root.Ydb.Monitoring.DatabaseStatus.fromObject(object.databaseStatus);
                }
                return message;
            };

            /**
             * Creates a plain object from a SelfCheckResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @static
             * @param {Ydb.Monitoring.SelfCheckResult} message SelfCheckResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SelfCheckResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issueLog = [];
                if (options.defaults) {
                    object.selfCheckResult = options.enums === String ? "UNSPECIFIED" : 0;
                    object.databaseStatus = null;
                }
                if (message.selfCheckResult != null && message.hasOwnProperty("selfCheckResult"))
                    object.selfCheckResult = options.enums === String ? $root.Ydb.Monitoring.SelfCheck.Result[message.selfCheckResult] : message.selfCheckResult;
                if (message.issueLog && message.issueLog.length) {
                    object.issueLog = [];
                    for (var j = 0; j < message.issueLog.length; ++j)
                        object.issueLog[j] = $root.Ydb.Monitoring.IssueLog.toObject(message.issueLog[j], options);
                }
                if (message.databaseStatus != null && message.hasOwnProperty("databaseStatus"))
                    object.databaseStatus = $root.Ydb.Monitoring.DatabaseStatus.toObject(message.databaseStatus, options);
                return object;
            };

            /**
             * Converts this SelfCheckResult to JSON.
             * @function toJSON
             * @memberof Ydb.Monitoring.SelfCheckResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SelfCheckResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SelfCheckResult;
        })();

        return Monitoring;
    })();

    Ydb.Operation = (function() {

        /**
         * Namespace Operation.
         * @memberof Ydb
         * @namespace
         */
        var Operation = {};

        Operation.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Operation
             * @namespace
             */
            var V1 = {};

            V1.OperationService = (function() {

                /**
                 * Constructs a new OperationService service.
                 * @memberof Ydb.Operation.V1
                 * @classdesc Represents an OperationService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function OperationService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (OperationService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = OperationService;

                /**
                 * Creates new OperationService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Operation.V1.OperationService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {OperationService} RPC service. Useful where requests and/or responses are streamed.
                 */
                OperationService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Operation.V1.OperationService#getOperation}.
                 * @memberof Ydb.Operation.V1.OperationService
                 * @typedef GetOperationCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Operations.GetOperationResponse} [response] GetOperationResponse
                 */

                /**
                 * Calls GetOperation.
                 * @function getOperation
                 * @memberof Ydb.Operation.V1.OperationService
                 * @instance
                 * @param {Ydb.Operations.IGetOperationRequest} request GetOperationRequest message or plain object
                 * @param {Ydb.Operation.V1.OperationService.GetOperationCallback} callback Node-style callback called with the error, if any, and GetOperationResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(OperationService.prototype.getOperation = function getOperation(request, callback) {
                    return this.rpcCall(getOperation, $root.Ydb.Operations.GetOperationRequest, $root.Ydb.Operations.GetOperationResponse, request, callback);
                }, "name", { value: "GetOperation" });

                /**
                 * Calls GetOperation.
                 * @function getOperation
                 * @memberof Ydb.Operation.V1.OperationService
                 * @instance
                 * @param {Ydb.Operations.IGetOperationRequest} request GetOperationRequest message or plain object
                 * @returns {Promise<Ydb.Operations.GetOperationResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Operation.V1.OperationService#cancelOperation}.
                 * @memberof Ydb.Operation.V1.OperationService
                 * @typedef CancelOperationCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Operations.CancelOperationResponse} [response] CancelOperationResponse
                 */

                /**
                 * Calls CancelOperation.
                 * @function cancelOperation
                 * @memberof Ydb.Operation.V1.OperationService
                 * @instance
                 * @param {Ydb.Operations.ICancelOperationRequest} request CancelOperationRequest message or plain object
                 * @param {Ydb.Operation.V1.OperationService.CancelOperationCallback} callback Node-style callback called with the error, if any, and CancelOperationResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(OperationService.prototype.cancelOperation = function cancelOperation(request, callback) {
                    return this.rpcCall(cancelOperation, $root.Ydb.Operations.CancelOperationRequest, $root.Ydb.Operations.CancelOperationResponse, request, callback);
                }, "name", { value: "CancelOperation" });

                /**
                 * Calls CancelOperation.
                 * @function cancelOperation
                 * @memberof Ydb.Operation.V1.OperationService
                 * @instance
                 * @param {Ydb.Operations.ICancelOperationRequest} request CancelOperationRequest message or plain object
                 * @returns {Promise<Ydb.Operations.CancelOperationResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Operation.V1.OperationService#forgetOperation}.
                 * @memberof Ydb.Operation.V1.OperationService
                 * @typedef ForgetOperationCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Operations.ForgetOperationResponse} [response] ForgetOperationResponse
                 */

                /**
                 * Calls ForgetOperation.
                 * @function forgetOperation
                 * @memberof Ydb.Operation.V1.OperationService
                 * @instance
                 * @param {Ydb.Operations.IForgetOperationRequest} request ForgetOperationRequest message or plain object
                 * @param {Ydb.Operation.V1.OperationService.ForgetOperationCallback} callback Node-style callback called with the error, if any, and ForgetOperationResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(OperationService.prototype.forgetOperation = function forgetOperation(request, callback) {
                    return this.rpcCall(forgetOperation, $root.Ydb.Operations.ForgetOperationRequest, $root.Ydb.Operations.ForgetOperationResponse, request, callback);
                }, "name", { value: "ForgetOperation" });

                /**
                 * Calls ForgetOperation.
                 * @function forgetOperation
                 * @memberof Ydb.Operation.V1.OperationService
                 * @instance
                 * @param {Ydb.Operations.IForgetOperationRequest} request ForgetOperationRequest message or plain object
                 * @returns {Promise<Ydb.Operations.ForgetOperationResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Operation.V1.OperationService#listOperations}.
                 * @memberof Ydb.Operation.V1.OperationService
                 * @typedef ListOperationsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Operations.ListOperationsResponse} [response] ListOperationsResponse
                 */

                /**
                 * Calls ListOperations.
                 * @function listOperations
                 * @memberof Ydb.Operation.V1.OperationService
                 * @instance
                 * @param {Ydb.Operations.IListOperationsRequest} request ListOperationsRequest message or plain object
                 * @param {Ydb.Operation.V1.OperationService.ListOperationsCallback} callback Node-style callback called with the error, if any, and ListOperationsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(OperationService.prototype.listOperations = function listOperations(request, callback) {
                    return this.rpcCall(listOperations, $root.Ydb.Operations.ListOperationsRequest, $root.Ydb.Operations.ListOperationsResponse, request, callback);
                }, "name", { value: "ListOperations" });

                /**
                 * Calls ListOperations.
                 * @function listOperations
                 * @memberof Ydb.Operation.V1.OperationService
                 * @instance
                 * @param {Ydb.Operations.IListOperationsRequest} request ListOperationsRequest message or plain object
                 * @returns {Promise<Ydb.Operations.ListOperationsResponse>} Promise
                 * @variation 2
                 */

                return OperationService;
            })();

            return V1;
        })();

        return Operation;
    })();

    Ydb.RateLimiter = (function() {

        /**
         * Namespace RateLimiter.
         * @memberof Ydb
         * @namespace
         */
        var RateLimiter = {};

        RateLimiter.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.RateLimiter
             * @namespace
             */
            var V1 = {};

            V1.RateLimiterService = (function() {

                /**
                 * Constructs a new RateLimiterService service.
                 * @memberof Ydb.RateLimiter.V1
                 * @classdesc Represents a RateLimiterService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function RateLimiterService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (RateLimiterService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = RateLimiterService;

                /**
                 * Creates new RateLimiterService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {RateLimiterService} RPC service. Useful where requests and/or responses are streamed.
                 */
                RateLimiterService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.RateLimiter.V1.RateLimiterService#createResource}.
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @typedef CreateResourceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.RateLimiter.CreateResourceResponse} [response] CreateResourceResponse
                 */

                /**
                 * Calls CreateResource.
                 * @function createResource
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.ICreateResourceRequest} request CreateResourceRequest message or plain object
                 * @param {Ydb.RateLimiter.V1.RateLimiterService.CreateResourceCallback} callback Node-style callback called with the error, if any, and CreateResourceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RateLimiterService.prototype.createResource = function createResource(request, callback) {
                    return this.rpcCall(createResource, $root.Ydb.RateLimiter.CreateResourceRequest, $root.Ydb.RateLimiter.CreateResourceResponse, request, callback);
                }, "name", { value: "CreateResource" });

                /**
                 * Calls CreateResource.
                 * @function createResource
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.ICreateResourceRequest} request CreateResourceRequest message or plain object
                 * @returns {Promise<Ydb.RateLimiter.CreateResourceResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.RateLimiter.V1.RateLimiterService#alterResource}.
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @typedef AlterResourceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.RateLimiter.AlterResourceResponse} [response] AlterResourceResponse
                 */

                /**
                 * Calls AlterResource.
                 * @function alterResource
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.IAlterResourceRequest} request AlterResourceRequest message or plain object
                 * @param {Ydb.RateLimiter.V1.RateLimiterService.AlterResourceCallback} callback Node-style callback called with the error, if any, and AlterResourceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RateLimiterService.prototype.alterResource = function alterResource(request, callback) {
                    return this.rpcCall(alterResource, $root.Ydb.RateLimiter.AlterResourceRequest, $root.Ydb.RateLimiter.AlterResourceResponse, request, callback);
                }, "name", { value: "AlterResource" });

                /**
                 * Calls AlterResource.
                 * @function alterResource
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.IAlterResourceRequest} request AlterResourceRequest message or plain object
                 * @returns {Promise<Ydb.RateLimiter.AlterResourceResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.RateLimiter.V1.RateLimiterService#dropResource}.
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @typedef DropResourceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.RateLimiter.DropResourceResponse} [response] DropResourceResponse
                 */

                /**
                 * Calls DropResource.
                 * @function dropResource
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.IDropResourceRequest} request DropResourceRequest message or plain object
                 * @param {Ydb.RateLimiter.V1.RateLimiterService.DropResourceCallback} callback Node-style callback called with the error, if any, and DropResourceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RateLimiterService.prototype.dropResource = function dropResource(request, callback) {
                    return this.rpcCall(dropResource, $root.Ydb.RateLimiter.DropResourceRequest, $root.Ydb.RateLimiter.DropResourceResponse, request, callback);
                }, "name", { value: "DropResource" });

                /**
                 * Calls DropResource.
                 * @function dropResource
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.IDropResourceRequest} request DropResourceRequest message or plain object
                 * @returns {Promise<Ydb.RateLimiter.DropResourceResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.RateLimiter.V1.RateLimiterService#listResources}.
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @typedef ListResourcesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.RateLimiter.ListResourcesResponse} [response] ListResourcesResponse
                 */

                /**
                 * Calls ListResources.
                 * @function listResources
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.IListResourcesRequest} request ListResourcesRequest message or plain object
                 * @param {Ydb.RateLimiter.V1.RateLimiterService.ListResourcesCallback} callback Node-style callback called with the error, if any, and ListResourcesResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RateLimiterService.prototype.listResources = function listResources(request, callback) {
                    return this.rpcCall(listResources, $root.Ydb.RateLimiter.ListResourcesRequest, $root.Ydb.RateLimiter.ListResourcesResponse, request, callback);
                }, "name", { value: "ListResources" });

                /**
                 * Calls ListResources.
                 * @function listResources
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.IListResourcesRequest} request ListResourcesRequest message or plain object
                 * @returns {Promise<Ydb.RateLimiter.ListResourcesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.RateLimiter.V1.RateLimiterService#describeResource}.
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @typedef DescribeResourceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.RateLimiter.DescribeResourceResponse} [response] DescribeResourceResponse
                 */

                /**
                 * Calls DescribeResource.
                 * @function describeResource
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.IDescribeResourceRequest} request DescribeResourceRequest message or plain object
                 * @param {Ydb.RateLimiter.V1.RateLimiterService.DescribeResourceCallback} callback Node-style callback called with the error, if any, and DescribeResourceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(RateLimiterService.prototype.describeResource = function describeResource(request, callback) {
                    return this.rpcCall(describeResource, $root.Ydb.RateLimiter.DescribeResourceRequest, $root.Ydb.RateLimiter.DescribeResourceResponse, request, callback);
                }, "name", { value: "DescribeResource" });

                /**
                 * Calls DescribeResource.
                 * @function describeResource
                 * @memberof Ydb.RateLimiter.V1.RateLimiterService
                 * @instance
                 * @param {Ydb.RateLimiter.IDescribeResourceRequest} request DescribeResourceRequest message or plain object
                 * @returns {Promise<Ydb.RateLimiter.DescribeResourceResponse>} Promise
                 * @variation 2
                 */

                return RateLimiterService;
            })();

            return V1;
        })();

        RateLimiter.HierarchicalDrrSettings = (function() {

            /**
             * Properties of a HierarchicalDrrSettings.
             * @memberof Ydb.RateLimiter
             * @interface IHierarchicalDrrSettings
             * @property {number|null} [maxUnitsPerSecond] HierarchicalDrrSettings maxUnitsPerSecond
             * @property {number|null} [maxBurstSizeCoefficient] HierarchicalDrrSettings maxBurstSizeCoefficient
             */

            /**
             * Constructs a new HierarchicalDrrSettings.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a HierarchicalDrrSettings.
             * @implements IHierarchicalDrrSettings
             * @constructor
             * @param {Ydb.RateLimiter.IHierarchicalDrrSettings=} [properties] Properties to set
             */
            function HierarchicalDrrSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HierarchicalDrrSettings maxUnitsPerSecond.
             * @member {number} maxUnitsPerSecond
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @instance
             */
            HierarchicalDrrSettings.prototype.maxUnitsPerSecond = 0;

            /**
             * HierarchicalDrrSettings maxBurstSizeCoefficient.
             * @member {number} maxBurstSizeCoefficient
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @instance
             */
            HierarchicalDrrSettings.prototype.maxBurstSizeCoefficient = 0;

            /**
             * Creates a new HierarchicalDrrSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @static
             * @param {Ydb.RateLimiter.IHierarchicalDrrSettings=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.HierarchicalDrrSettings} HierarchicalDrrSettings instance
             */
            HierarchicalDrrSettings.create = function create(properties) {
                return new HierarchicalDrrSettings(properties);
            };

            /**
             * Encodes the specified HierarchicalDrrSettings message. Does not implicitly {@link Ydb.RateLimiter.HierarchicalDrrSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @static
             * @param {Ydb.RateLimiter.IHierarchicalDrrSettings} message HierarchicalDrrSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HierarchicalDrrSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.maxUnitsPerSecond != null && message.hasOwnProperty("maxUnitsPerSecond"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.maxUnitsPerSecond);
                if (message.maxBurstSizeCoefficient != null && message.hasOwnProperty("maxBurstSizeCoefficient"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.maxBurstSizeCoefficient);
                return writer;
            };

            /**
             * Encodes the specified HierarchicalDrrSettings message, length delimited. Does not implicitly {@link Ydb.RateLimiter.HierarchicalDrrSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @static
             * @param {Ydb.RateLimiter.IHierarchicalDrrSettings} message HierarchicalDrrSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HierarchicalDrrSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HierarchicalDrrSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.HierarchicalDrrSettings} HierarchicalDrrSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HierarchicalDrrSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.HierarchicalDrrSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.maxUnitsPerSecond = reader.double();
                        break;
                    case 2:
                        message.maxBurstSizeCoefficient = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HierarchicalDrrSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.HierarchicalDrrSettings} HierarchicalDrrSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HierarchicalDrrSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HierarchicalDrrSettings message.
             * @function verify
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HierarchicalDrrSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.maxUnitsPerSecond != null && message.hasOwnProperty("maxUnitsPerSecond"))
                    if (typeof message.maxUnitsPerSecond !== "number")
                        return "maxUnitsPerSecond: number expected";
                if (message.maxBurstSizeCoefficient != null && message.hasOwnProperty("maxBurstSizeCoefficient"))
                    if (typeof message.maxBurstSizeCoefficient !== "number")
                        return "maxBurstSizeCoefficient: number expected";
                return null;
            };

            /**
             * Creates a HierarchicalDrrSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.HierarchicalDrrSettings} HierarchicalDrrSettings
             */
            HierarchicalDrrSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.HierarchicalDrrSettings)
                    return object;
                var message = new $root.Ydb.RateLimiter.HierarchicalDrrSettings();
                if (object.maxUnitsPerSecond != null)
                    message.maxUnitsPerSecond = Number(object.maxUnitsPerSecond);
                if (object.maxBurstSizeCoefficient != null)
                    message.maxBurstSizeCoefficient = Number(object.maxBurstSizeCoefficient);
                return message;
            };

            /**
             * Creates a plain object from a HierarchicalDrrSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @static
             * @param {Ydb.RateLimiter.HierarchicalDrrSettings} message HierarchicalDrrSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HierarchicalDrrSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.maxUnitsPerSecond = 0;
                    object.maxBurstSizeCoefficient = 0;
                }
                if (message.maxUnitsPerSecond != null && message.hasOwnProperty("maxUnitsPerSecond"))
                    object.maxUnitsPerSecond = options.json && !isFinite(message.maxUnitsPerSecond) ? String(message.maxUnitsPerSecond) : message.maxUnitsPerSecond;
                if (message.maxBurstSizeCoefficient != null && message.hasOwnProperty("maxBurstSizeCoefficient"))
                    object.maxBurstSizeCoefficient = options.json && !isFinite(message.maxBurstSizeCoefficient) ? String(message.maxBurstSizeCoefficient) : message.maxBurstSizeCoefficient;
                return object;
            };

            /**
             * Converts this HierarchicalDrrSettings to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.HierarchicalDrrSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HierarchicalDrrSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HierarchicalDrrSettings;
        })();

        RateLimiter.Resource = (function() {

            /**
             * Properties of a Resource.
             * @memberof Ydb.RateLimiter
             * @interface IResource
             * @property {string|null} [resourcePath] Resource resourcePath
             * @property {Ydb.RateLimiter.IHierarchicalDrrSettings|null} [hierarchicalDrr] Resource hierarchicalDrr
             */

            /**
             * Constructs a new Resource.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a Resource.
             * @implements IResource
             * @constructor
             * @param {Ydb.RateLimiter.IResource=} [properties] Properties to set
             */
            function Resource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Resource resourcePath.
             * @member {string} resourcePath
             * @memberof Ydb.RateLimiter.Resource
             * @instance
             */
            Resource.prototype.resourcePath = "";

            /**
             * Resource hierarchicalDrr.
             * @member {Ydb.RateLimiter.IHierarchicalDrrSettings|null|undefined} hierarchicalDrr
             * @memberof Ydb.RateLimiter.Resource
             * @instance
             */
            Resource.prototype.hierarchicalDrr = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Resource type.
             * @member {"hierarchicalDrr"|undefined} type
             * @memberof Ydb.RateLimiter.Resource
             * @instance
             */
            Object.defineProperty(Resource.prototype, "type", {
                get: $util.oneOfGetter($oneOfFields = ["hierarchicalDrr"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Resource instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.Resource
             * @static
             * @param {Ydb.RateLimiter.IResource=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.Resource} Resource instance
             */
            Resource.create = function create(properties) {
                return new Resource(properties);
            };

            /**
             * Encodes the specified Resource message. Does not implicitly {@link Ydb.RateLimiter.Resource.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.Resource
             * @static
             * @param {Ydb.RateLimiter.IResource} message Resource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Resource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.resourcePath);
                if (message.hierarchicalDrr != null && message.hasOwnProperty("hierarchicalDrr"))
                    $root.Ydb.RateLimiter.HierarchicalDrrSettings.encode(message.hierarchicalDrr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Resource message, length delimited. Does not implicitly {@link Ydb.RateLimiter.Resource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.Resource
             * @static
             * @param {Ydb.RateLimiter.IResource} message Resource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Resource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Resource message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.Resource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.Resource} Resource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Resource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.Resource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resourcePath = reader.string();
                        break;
                    case 2:
                        message.hierarchicalDrr = $root.Ydb.RateLimiter.HierarchicalDrrSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Resource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.Resource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.Resource} Resource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Resource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Resource message.
             * @function verify
             * @memberof Ydb.RateLimiter.Resource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Resource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    if (!$util.isString(message.resourcePath))
                        return "resourcePath: string expected";
                if (message.hierarchicalDrr != null && message.hasOwnProperty("hierarchicalDrr")) {
                    properties.type = 1;
                    {
                        var error = $root.Ydb.RateLimiter.HierarchicalDrrSettings.verify(message.hierarchicalDrr);
                        if (error)
                            return "hierarchicalDrr." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Resource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.Resource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.Resource} Resource
             */
            Resource.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.Resource)
                    return object;
                var message = new $root.Ydb.RateLimiter.Resource();
                if (object.resourcePath != null)
                    message.resourcePath = String(object.resourcePath);
                if (object.hierarchicalDrr != null) {
                    if (typeof object.hierarchicalDrr !== "object")
                        throw TypeError(".Ydb.RateLimiter.Resource.hierarchicalDrr: object expected");
                    message.hierarchicalDrr = $root.Ydb.RateLimiter.HierarchicalDrrSettings.fromObject(object.hierarchicalDrr);
                }
                return message;
            };

            /**
             * Creates a plain object from a Resource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.Resource
             * @static
             * @param {Ydb.RateLimiter.Resource} message Resource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Resource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.resourcePath = "";
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    object.resourcePath = message.resourcePath;
                if (message.hierarchicalDrr != null && message.hasOwnProperty("hierarchicalDrr")) {
                    object.hierarchicalDrr = $root.Ydb.RateLimiter.HierarchicalDrrSettings.toObject(message.hierarchicalDrr, options);
                    if (options.oneofs)
                        object.type = "hierarchicalDrr";
                }
                return object;
            };

            /**
             * Converts this Resource to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.Resource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Resource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Resource;
        })();

        RateLimiter.CreateResourceRequest = (function() {

            /**
             * Properties of a CreateResourceRequest.
             * @memberof Ydb.RateLimiter
             * @interface ICreateResourceRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CreateResourceRequest operationParams
             * @property {string|null} [coordinationNodePath] CreateResourceRequest coordinationNodePath
             * @property {Ydb.RateLimiter.IResource|null} [resource] CreateResourceRequest resource
             */

            /**
             * Constructs a new CreateResourceRequest.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a CreateResourceRequest.
             * @implements ICreateResourceRequest
             * @constructor
             * @param {Ydb.RateLimiter.ICreateResourceRequest=} [properties] Properties to set
             */
            function CreateResourceRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateResourceRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @instance
             */
            CreateResourceRequest.prototype.operationParams = null;

            /**
             * CreateResourceRequest coordinationNodePath.
             * @member {string} coordinationNodePath
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @instance
             */
            CreateResourceRequest.prototype.coordinationNodePath = "";

            /**
             * CreateResourceRequest resource.
             * @member {Ydb.RateLimiter.IResource|null|undefined} resource
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @instance
             */
            CreateResourceRequest.prototype.resource = null;

            /**
             * Creates a new CreateResourceRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @static
             * @param {Ydb.RateLimiter.ICreateResourceRequest=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.CreateResourceRequest} CreateResourceRequest instance
             */
            CreateResourceRequest.create = function create(properties) {
                return new CreateResourceRequest(properties);
            };

            /**
             * Encodes the specified CreateResourceRequest message. Does not implicitly {@link Ydb.RateLimiter.CreateResourceRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @static
             * @param {Ydb.RateLimiter.ICreateResourceRequest} message CreateResourceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateResourceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.coordinationNodePath);
                if (message.resource != null && message.hasOwnProperty("resource"))
                    $root.Ydb.RateLimiter.Resource.encode(message.resource, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateResourceRequest message, length delimited. Does not implicitly {@link Ydb.RateLimiter.CreateResourceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @static
             * @param {Ydb.RateLimiter.ICreateResourceRequest} message CreateResourceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateResourceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateResourceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.CreateResourceRequest} CreateResourceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateResourceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.CreateResourceRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.coordinationNodePath = reader.string();
                        break;
                    case 3:
                        message.resource = $root.Ydb.RateLimiter.Resource.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateResourceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.CreateResourceRequest} CreateResourceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateResourceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateResourceRequest message.
             * @function verify
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateResourceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    if (!$util.isString(message.coordinationNodePath))
                        return "coordinationNodePath: string expected";
                if (message.resource != null && message.hasOwnProperty("resource")) {
                    var error = $root.Ydb.RateLimiter.Resource.verify(message.resource);
                    if (error)
                        return "resource." + error;
                }
                return null;
            };

            /**
             * Creates a CreateResourceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.CreateResourceRequest} CreateResourceRequest
             */
            CreateResourceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.CreateResourceRequest)
                    return object;
                var message = new $root.Ydb.RateLimiter.CreateResourceRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.RateLimiter.CreateResourceRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.coordinationNodePath != null)
                    message.coordinationNodePath = String(object.coordinationNodePath);
                if (object.resource != null) {
                    if (typeof object.resource !== "object")
                        throw TypeError(".Ydb.RateLimiter.CreateResourceRequest.resource: object expected");
                    message.resource = $root.Ydb.RateLimiter.Resource.fromObject(object.resource);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateResourceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @static
             * @param {Ydb.RateLimiter.CreateResourceRequest} message CreateResourceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateResourceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.coordinationNodePath = "";
                    object.resource = null;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    object.coordinationNodePath = message.coordinationNodePath;
                if (message.resource != null && message.hasOwnProperty("resource"))
                    object.resource = $root.Ydb.RateLimiter.Resource.toObject(message.resource, options);
                return object;
            };

            /**
             * Converts this CreateResourceRequest to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.CreateResourceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateResourceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateResourceRequest;
        })();

        RateLimiter.CreateResourceResponse = (function() {

            /**
             * Properties of a CreateResourceResponse.
             * @memberof Ydb.RateLimiter
             * @interface ICreateResourceResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CreateResourceResponse operation
             */

            /**
             * Constructs a new CreateResourceResponse.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a CreateResourceResponse.
             * @implements ICreateResourceResponse
             * @constructor
             * @param {Ydb.RateLimiter.ICreateResourceResponse=} [properties] Properties to set
             */
            function CreateResourceResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateResourceResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @instance
             */
            CreateResourceResponse.prototype.operation = null;

            /**
             * Creates a new CreateResourceResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @static
             * @param {Ydb.RateLimiter.ICreateResourceResponse=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.CreateResourceResponse} CreateResourceResponse instance
             */
            CreateResourceResponse.create = function create(properties) {
                return new CreateResourceResponse(properties);
            };

            /**
             * Encodes the specified CreateResourceResponse message. Does not implicitly {@link Ydb.RateLimiter.CreateResourceResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @static
             * @param {Ydb.RateLimiter.ICreateResourceResponse} message CreateResourceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateResourceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateResourceResponse message, length delimited. Does not implicitly {@link Ydb.RateLimiter.CreateResourceResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @static
             * @param {Ydb.RateLimiter.ICreateResourceResponse} message CreateResourceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateResourceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateResourceResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.CreateResourceResponse} CreateResourceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateResourceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.CreateResourceResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateResourceResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.CreateResourceResponse} CreateResourceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateResourceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateResourceResponse message.
             * @function verify
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateResourceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CreateResourceResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.CreateResourceResponse} CreateResourceResponse
             */
            CreateResourceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.CreateResourceResponse)
                    return object;
                var message = new $root.Ydb.RateLimiter.CreateResourceResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.RateLimiter.CreateResourceResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateResourceResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @static
             * @param {Ydb.RateLimiter.CreateResourceResponse} message CreateResourceResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateResourceResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CreateResourceResponse to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.CreateResourceResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateResourceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateResourceResponse;
        })();

        RateLimiter.CreateResourceResult = (function() {

            /**
             * Properties of a CreateResourceResult.
             * @memberof Ydb.RateLimiter
             * @interface ICreateResourceResult
             */

            /**
             * Constructs a new CreateResourceResult.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a CreateResourceResult.
             * @implements ICreateResourceResult
             * @constructor
             * @param {Ydb.RateLimiter.ICreateResourceResult=} [properties] Properties to set
             */
            function CreateResourceResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new CreateResourceResult instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.CreateResourceResult
             * @static
             * @param {Ydb.RateLimiter.ICreateResourceResult=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.CreateResourceResult} CreateResourceResult instance
             */
            CreateResourceResult.create = function create(properties) {
                return new CreateResourceResult(properties);
            };

            /**
             * Encodes the specified CreateResourceResult message. Does not implicitly {@link Ydb.RateLimiter.CreateResourceResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.CreateResourceResult
             * @static
             * @param {Ydb.RateLimiter.ICreateResourceResult} message CreateResourceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateResourceResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified CreateResourceResult message, length delimited. Does not implicitly {@link Ydb.RateLimiter.CreateResourceResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.CreateResourceResult
             * @static
             * @param {Ydb.RateLimiter.ICreateResourceResult} message CreateResourceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateResourceResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateResourceResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.CreateResourceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.CreateResourceResult} CreateResourceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateResourceResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.CreateResourceResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateResourceResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.CreateResourceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.CreateResourceResult} CreateResourceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateResourceResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateResourceResult message.
             * @function verify
             * @memberof Ydb.RateLimiter.CreateResourceResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateResourceResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a CreateResourceResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.CreateResourceResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.CreateResourceResult} CreateResourceResult
             */
            CreateResourceResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.CreateResourceResult)
                    return object;
                return new $root.Ydb.RateLimiter.CreateResourceResult();
            };

            /**
             * Creates a plain object from a CreateResourceResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.CreateResourceResult
             * @static
             * @param {Ydb.RateLimiter.CreateResourceResult} message CreateResourceResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateResourceResult.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this CreateResourceResult to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.CreateResourceResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateResourceResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateResourceResult;
        })();

        RateLimiter.AlterResourceRequest = (function() {

            /**
             * Properties of an AlterResourceRequest.
             * @memberof Ydb.RateLimiter
             * @interface IAlterResourceRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] AlterResourceRequest operationParams
             * @property {string|null} [coordinationNodePath] AlterResourceRequest coordinationNodePath
             * @property {Ydb.RateLimiter.IResource|null} [resource] AlterResourceRequest resource
             */

            /**
             * Constructs a new AlterResourceRequest.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents an AlterResourceRequest.
             * @implements IAlterResourceRequest
             * @constructor
             * @param {Ydb.RateLimiter.IAlterResourceRequest=} [properties] Properties to set
             */
            function AlterResourceRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterResourceRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @instance
             */
            AlterResourceRequest.prototype.operationParams = null;

            /**
             * AlterResourceRequest coordinationNodePath.
             * @member {string} coordinationNodePath
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @instance
             */
            AlterResourceRequest.prototype.coordinationNodePath = "";

            /**
             * AlterResourceRequest resource.
             * @member {Ydb.RateLimiter.IResource|null|undefined} resource
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @instance
             */
            AlterResourceRequest.prototype.resource = null;

            /**
             * Creates a new AlterResourceRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @static
             * @param {Ydb.RateLimiter.IAlterResourceRequest=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.AlterResourceRequest} AlterResourceRequest instance
             */
            AlterResourceRequest.create = function create(properties) {
                return new AlterResourceRequest(properties);
            };

            /**
             * Encodes the specified AlterResourceRequest message. Does not implicitly {@link Ydb.RateLimiter.AlterResourceRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @static
             * @param {Ydb.RateLimiter.IAlterResourceRequest} message AlterResourceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterResourceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.coordinationNodePath);
                if (message.resource != null && message.hasOwnProperty("resource"))
                    $root.Ydb.RateLimiter.Resource.encode(message.resource, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlterResourceRequest message, length delimited. Does not implicitly {@link Ydb.RateLimiter.AlterResourceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @static
             * @param {Ydb.RateLimiter.IAlterResourceRequest} message AlterResourceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterResourceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterResourceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.AlterResourceRequest} AlterResourceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterResourceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.AlterResourceRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.coordinationNodePath = reader.string();
                        break;
                    case 3:
                        message.resource = $root.Ydb.RateLimiter.Resource.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterResourceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.AlterResourceRequest} AlterResourceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterResourceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterResourceRequest message.
             * @function verify
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterResourceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    if (!$util.isString(message.coordinationNodePath))
                        return "coordinationNodePath: string expected";
                if (message.resource != null && message.hasOwnProperty("resource")) {
                    var error = $root.Ydb.RateLimiter.Resource.verify(message.resource);
                    if (error)
                        return "resource." + error;
                }
                return null;
            };

            /**
             * Creates an AlterResourceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.AlterResourceRequest} AlterResourceRequest
             */
            AlterResourceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.AlterResourceRequest)
                    return object;
                var message = new $root.Ydb.RateLimiter.AlterResourceRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.RateLimiter.AlterResourceRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.coordinationNodePath != null)
                    message.coordinationNodePath = String(object.coordinationNodePath);
                if (object.resource != null) {
                    if (typeof object.resource !== "object")
                        throw TypeError(".Ydb.RateLimiter.AlterResourceRequest.resource: object expected");
                    message.resource = $root.Ydb.RateLimiter.Resource.fromObject(object.resource);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlterResourceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @static
             * @param {Ydb.RateLimiter.AlterResourceRequest} message AlterResourceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterResourceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.coordinationNodePath = "";
                    object.resource = null;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    object.coordinationNodePath = message.coordinationNodePath;
                if (message.resource != null && message.hasOwnProperty("resource"))
                    object.resource = $root.Ydb.RateLimiter.Resource.toObject(message.resource, options);
                return object;
            };

            /**
             * Converts this AlterResourceRequest to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.AlterResourceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterResourceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterResourceRequest;
        })();

        RateLimiter.AlterResourceResponse = (function() {

            /**
             * Properties of an AlterResourceResponse.
             * @memberof Ydb.RateLimiter
             * @interface IAlterResourceResponse
             * @property {Ydb.Operations.IOperation|null} [operation] AlterResourceResponse operation
             */

            /**
             * Constructs a new AlterResourceResponse.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents an AlterResourceResponse.
             * @implements IAlterResourceResponse
             * @constructor
             * @param {Ydb.RateLimiter.IAlterResourceResponse=} [properties] Properties to set
             */
            function AlterResourceResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterResourceResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @instance
             */
            AlterResourceResponse.prototype.operation = null;

            /**
             * Creates a new AlterResourceResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @static
             * @param {Ydb.RateLimiter.IAlterResourceResponse=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.AlterResourceResponse} AlterResourceResponse instance
             */
            AlterResourceResponse.create = function create(properties) {
                return new AlterResourceResponse(properties);
            };

            /**
             * Encodes the specified AlterResourceResponse message. Does not implicitly {@link Ydb.RateLimiter.AlterResourceResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @static
             * @param {Ydb.RateLimiter.IAlterResourceResponse} message AlterResourceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterResourceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlterResourceResponse message, length delimited. Does not implicitly {@link Ydb.RateLimiter.AlterResourceResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @static
             * @param {Ydb.RateLimiter.IAlterResourceResponse} message AlterResourceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterResourceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterResourceResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.AlterResourceResponse} AlterResourceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterResourceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.AlterResourceResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterResourceResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.AlterResourceResponse} AlterResourceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterResourceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterResourceResponse message.
             * @function verify
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterResourceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an AlterResourceResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.AlterResourceResponse} AlterResourceResponse
             */
            AlterResourceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.AlterResourceResponse)
                    return object;
                var message = new $root.Ydb.RateLimiter.AlterResourceResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.RateLimiter.AlterResourceResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlterResourceResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @static
             * @param {Ydb.RateLimiter.AlterResourceResponse} message AlterResourceResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterResourceResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this AlterResourceResponse to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.AlterResourceResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterResourceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterResourceResponse;
        })();

        RateLimiter.AlterResourceResult = (function() {

            /**
             * Properties of an AlterResourceResult.
             * @memberof Ydb.RateLimiter
             * @interface IAlterResourceResult
             */

            /**
             * Constructs a new AlterResourceResult.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents an AlterResourceResult.
             * @implements IAlterResourceResult
             * @constructor
             * @param {Ydb.RateLimiter.IAlterResourceResult=} [properties] Properties to set
             */
            function AlterResourceResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AlterResourceResult instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.AlterResourceResult
             * @static
             * @param {Ydb.RateLimiter.IAlterResourceResult=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.AlterResourceResult} AlterResourceResult instance
             */
            AlterResourceResult.create = function create(properties) {
                return new AlterResourceResult(properties);
            };

            /**
             * Encodes the specified AlterResourceResult message. Does not implicitly {@link Ydb.RateLimiter.AlterResourceResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.AlterResourceResult
             * @static
             * @param {Ydb.RateLimiter.IAlterResourceResult} message AlterResourceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterResourceResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AlterResourceResult message, length delimited. Does not implicitly {@link Ydb.RateLimiter.AlterResourceResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.AlterResourceResult
             * @static
             * @param {Ydb.RateLimiter.IAlterResourceResult} message AlterResourceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterResourceResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterResourceResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.AlterResourceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.AlterResourceResult} AlterResourceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterResourceResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.AlterResourceResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterResourceResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.AlterResourceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.AlterResourceResult} AlterResourceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterResourceResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterResourceResult message.
             * @function verify
             * @memberof Ydb.RateLimiter.AlterResourceResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterResourceResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AlterResourceResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.AlterResourceResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.AlterResourceResult} AlterResourceResult
             */
            AlterResourceResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.AlterResourceResult)
                    return object;
                return new $root.Ydb.RateLimiter.AlterResourceResult();
            };

            /**
             * Creates a plain object from an AlterResourceResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.AlterResourceResult
             * @static
             * @param {Ydb.RateLimiter.AlterResourceResult} message AlterResourceResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterResourceResult.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AlterResourceResult to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.AlterResourceResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterResourceResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterResourceResult;
        })();

        RateLimiter.DropResourceRequest = (function() {

            /**
             * Properties of a DropResourceRequest.
             * @memberof Ydb.RateLimiter
             * @interface IDropResourceRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DropResourceRequest operationParams
             * @property {string|null} [coordinationNodePath] DropResourceRequest coordinationNodePath
             * @property {string|null} [resourcePath] DropResourceRequest resourcePath
             */

            /**
             * Constructs a new DropResourceRequest.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a DropResourceRequest.
             * @implements IDropResourceRequest
             * @constructor
             * @param {Ydb.RateLimiter.IDropResourceRequest=} [properties] Properties to set
             */
            function DropResourceRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DropResourceRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @instance
             */
            DropResourceRequest.prototype.operationParams = null;

            /**
             * DropResourceRequest coordinationNodePath.
             * @member {string} coordinationNodePath
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @instance
             */
            DropResourceRequest.prototype.coordinationNodePath = "";

            /**
             * DropResourceRequest resourcePath.
             * @member {string} resourcePath
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @instance
             */
            DropResourceRequest.prototype.resourcePath = "";

            /**
             * Creates a new DropResourceRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @static
             * @param {Ydb.RateLimiter.IDropResourceRequest=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.DropResourceRequest} DropResourceRequest instance
             */
            DropResourceRequest.create = function create(properties) {
                return new DropResourceRequest(properties);
            };

            /**
             * Encodes the specified DropResourceRequest message. Does not implicitly {@link Ydb.RateLimiter.DropResourceRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @static
             * @param {Ydb.RateLimiter.IDropResourceRequest} message DropResourceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropResourceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.coordinationNodePath);
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.resourcePath);
                return writer;
            };

            /**
             * Encodes the specified DropResourceRequest message, length delimited. Does not implicitly {@link Ydb.RateLimiter.DropResourceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @static
             * @param {Ydb.RateLimiter.IDropResourceRequest} message DropResourceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropResourceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropResourceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.DropResourceRequest} DropResourceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropResourceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.DropResourceRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.coordinationNodePath = reader.string();
                        break;
                    case 3:
                        message.resourcePath = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropResourceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.DropResourceRequest} DropResourceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropResourceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropResourceRequest message.
             * @function verify
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropResourceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    if (!$util.isString(message.coordinationNodePath))
                        return "coordinationNodePath: string expected";
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    if (!$util.isString(message.resourcePath))
                        return "resourcePath: string expected";
                return null;
            };

            /**
             * Creates a DropResourceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.DropResourceRequest} DropResourceRequest
             */
            DropResourceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.DropResourceRequest)
                    return object;
                var message = new $root.Ydb.RateLimiter.DropResourceRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.RateLimiter.DropResourceRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.coordinationNodePath != null)
                    message.coordinationNodePath = String(object.coordinationNodePath);
                if (object.resourcePath != null)
                    message.resourcePath = String(object.resourcePath);
                return message;
            };

            /**
             * Creates a plain object from a DropResourceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @static
             * @param {Ydb.RateLimiter.DropResourceRequest} message DropResourceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropResourceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.coordinationNodePath = "";
                    object.resourcePath = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    object.coordinationNodePath = message.coordinationNodePath;
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    object.resourcePath = message.resourcePath;
                return object;
            };

            /**
             * Converts this DropResourceRequest to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.DropResourceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropResourceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropResourceRequest;
        })();

        RateLimiter.DropResourceResponse = (function() {

            /**
             * Properties of a DropResourceResponse.
             * @memberof Ydb.RateLimiter
             * @interface IDropResourceResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DropResourceResponse operation
             */

            /**
             * Constructs a new DropResourceResponse.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a DropResourceResponse.
             * @implements IDropResourceResponse
             * @constructor
             * @param {Ydb.RateLimiter.IDropResourceResponse=} [properties] Properties to set
             */
            function DropResourceResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DropResourceResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @instance
             */
            DropResourceResponse.prototype.operation = null;

            /**
             * Creates a new DropResourceResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @static
             * @param {Ydb.RateLimiter.IDropResourceResponse=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.DropResourceResponse} DropResourceResponse instance
             */
            DropResourceResponse.create = function create(properties) {
                return new DropResourceResponse(properties);
            };

            /**
             * Encodes the specified DropResourceResponse message. Does not implicitly {@link Ydb.RateLimiter.DropResourceResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @static
             * @param {Ydb.RateLimiter.IDropResourceResponse} message DropResourceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropResourceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DropResourceResponse message, length delimited. Does not implicitly {@link Ydb.RateLimiter.DropResourceResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @static
             * @param {Ydb.RateLimiter.IDropResourceResponse} message DropResourceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropResourceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropResourceResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.DropResourceResponse} DropResourceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropResourceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.DropResourceResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropResourceResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.DropResourceResponse} DropResourceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropResourceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropResourceResponse message.
             * @function verify
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropResourceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DropResourceResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.DropResourceResponse} DropResourceResponse
             */
            DropResourceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.DropResourceResponse)
                    return object;
                var message = new $root.Ydb.RateLimiter.DropResourceResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.RateLimiter.DropResourceResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DropResourceResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @static
             * @param {Ydb.RateLimiter.DropResourceResponse} message DropResourceResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropResourceResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DropResourceResponse to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.DropResourceResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropResourceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropResourceResponse;
        })();

        RateLimiter.DropResourceResult = (function() {

            /**
             * Properties of a DropResourceResult.
             * @memberof Ydb.RateLimiter
             * @interface IDropResourceResult
             */

            /**
             * Constructs a new DropResourceResult.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a DropResourceResult.
             * @implements IDropResourceResult
             * @constructor
             * @param {Ydb.RateLimiter.IDropResourceResult=} [properties] Properties to set
             */
            function DropResourceResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DropResourceResult instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.DropResourceResult
             * @static
             * @param {Ydb.RateLimiter.IDropResourceResult=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.DropResourceResult} DropResourceResult instance
             */
            DropResourceResult.create = function create(properties) {
                return new DropResourceResult(properties);
            };

            /**
             * Encodes the specified DropResourceResult message. Does not implicitly {@link Ydb.RateLimiter.DropResourceResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.DropResourceResult
             * @static
             * @param {Ydb.RateLimiter.IDropResourceResult} message DropResourceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropResourceResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DropResourceResult message, length delimited. Does not implicitly {@link Ydb.RateLimiter.DropResourceResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.DropResourceResult
             * @static
             * @param {Ydb.RateLimiter.IDropResourceResult} message DropResourceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropResourceResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropResourceResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.DropResourceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.DropResourceResult} DropResourceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropResourceResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.DropResourceResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropResourceResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.DropResourceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.DropResourceResult} DropResourceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropResourceResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropResourceResult message.
             * @function verify
             * @memberof Ydb.RateLimiter.DropResourceResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropResourceResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DropResourceResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.DropResourceResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.DropResourceResult} DropResourceResult
             */
            DropResourceResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.DropResourceResult)
                    return object;
                return new $root.Ydb.RateLimiter.DropResourceResult();
            };

            /**
             * Creates a plain object from a DropResourceResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.DropResourceResult
             * @static
             * @param {Ydb.RateLimiter.DropResourceResult} message DropResourceResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropResourceResult.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DropResourceResult to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.DropResourceResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropResourceResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropResourceResult;
        })();

        RateLimiter.ListResourcesRequest = (function() {

            /**
             * Properties of a ListResourcesRequest.
             * @memberof Ydb.RateLimiter
             * @interface IListResourcesRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ListResourcesRequest operationParams
             * @property {string|null} [coordinationNodePath] ListResourcesRequest coordinationNodePath
             * @property {string|null} [resourcePath] ListResourcesRequest resourcePath
             * @property {boolean|null} [recursive] ListResourcesRequest recursive
             */

            /**
             * Constructs a new ListResourcesRequest.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a ListResourcesRequest.
             * @implements IListResourcesRequest
             * @constructor
             * @param {Ydb.RateLimiter.IListResourcesRequest=} [properties] Properties to set
             */
            function ListResourcesRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListResourcesRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @instance
             */
            ListResourcesRequest.prototype.operationParams = null;

            /**
             * ListResourcesRequest coordinationNodePath.
             * @member {string} coordinationNodePath
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @instance
             */
            ListResourcesRequest.prototype.coordinationNodePath = "";

            /**
             * ListResourcesRequest resourcePath.
             * @member {string} resourcePath
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @instance
             */
            ListResourcesRequest.prototype.resourcePath = "";

            /**
             * ListResourcesRequest recursive.
             * @member {boolean} recursive
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @instance
             */
            ListResourcesRequest.prototype.recursive = false;

            /**
             * Creates a new ListResourcesRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @static
             * @param {Ydb.RateLimiter.IListResourcesRequest=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.ListResourcesRequest} ListResourcesRequest instance
             */
            ListResourcesRequest.create = function create(properties) {
                return new ListResourcesRequest(properties);
            };

            /**
             * Encodes the specified ListResourcesRequest message. Does not implicitly {@link Ydb.RateLimiter.ListResourcesRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @static
             * @param {Ydb.RateLimiter.IListResourcesRequest} message ListResourcesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListResourcesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.coordinationNodePath);
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.resourcePath);
                if (message.recursive != null && message.hasOwnProperty("recursive"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.recursive);
                return writer;
            };

            /**
             * Encodes the specified ListResourcesRequest message, length delimited. Does not implicitly {@link Ydb.RateLimiter.ListResourcesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @static
             * @param {Ydb.RateLimiter.IListResourcesRequest} message ListResourcesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListResourcesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListResourcesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.ListResourcesRequest} ListResourcesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListResourcesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.ListResourcesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.coordinationNodePath = reader.string();
                        break;
                    case 3:
                        message.resourcePath = reader.string();
                        break;
                    case 4:
                        message.recursive = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListResourcesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.ListResourcesRequest} ListResourcesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListResourcesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListResourcesRequest message.
             * @function verify
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListResourcesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    if (!$util.isString(message.coordinationNodePath))
                        return "coordinationNodePath: string expected";
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    if (!$util.isString(message.resourcePath))
                        return "resourcePath: string expected";
                if (message.recursive != null && message.hasOwnProperty("recursive"))
                    if (typeof message.recursive !== "boolean")
                        return "recursive: boolean expected";
                return null;
            };

            /**
             * Creates a ListResourcesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.ListResourcesRequest} ListResourcesRequest
             */
            ListResourcesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.ListResourcesRequest)
                    return object;
                var message = new $root.Ydb.RateLimiter.ListResourcesRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.RateLimiter.ListResourcesRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.coordinationNodePath != null)
                    message.coordinationNodePath = String(object.coordinationNodePath);
                if (object.resourcePath != null)
                    message.resourcePath = String(object.resourcePath);
                if (object.recursive != null)
                    message.recursive = Boolean(object.recursive);
                return message;
            };

            /**
             * Creates a plain object from a ListResourcesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @static
             * @param {Ydb.RateLimiter.ListResourcesRequest} message ListResourcesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListResourcesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.coordinationNodePath = "";
                    object.resourcePath = "";
                    object.recursive = false;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    object.coordinationNodePath = message.coordinationNodePath;
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    object.resourcePath = message.resourcePath;
                if (message.recursive != null && message.hasOwnProperty("recursive"))
                    object.recursive = message.recursive;
                return object;
            };

            /**
             * Converts this ListResourcesRequest to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.ListResourcesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListResourcesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListResourcesRequest;
        })();

        RateLimiter.ListResourcesResponse = (function() {

            /**
             * Properties of a ListResourcesResponse.
             * @memberof Ydb.RateLimiter
             * @interface IListResourcesResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ListResourcesResponse operation
             */

            /**
             * Constructs a new ListResourcesResponse.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a ListResourcesResponse.
             * @implements IListResourcesResponse
             * @constructor
             * @param {Ydb.RateLimiter.IListResourcesResponse=} [properties] Properties to set
             */
            function ListResourcesResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListResourcesResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @instance
             */
            ListResourcesResponse.prototype.operation = null;

            /**
             * Creates a new ListResourcesResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @static
             * @param {Ydb.RateLimiter.IListResourcesResponse=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.ListResourcesResponse} ListResourcesResponse instance
             */
            ListResourcesResponse.create = function create(properties) {
                return new ListResourcesResponse(properties);
            };

            /**
             * Encodes the specified ListResourcesResponse message. Does not implicitly {@link Ydb.RateLimiter.ListResourcesResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @static
             * @param {Ydb.RateLimiter.IListResourcesResponse} message ListResourcesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListResourcesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListResourcesResponse message, length delimited. Does not implicitly {@link Ydb.RateLimiter.ListResourcesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @static
             * @param {Ydb.RateLimiter.IListResourcesResponse} message ListResourcesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListResourcesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListResourcesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.ListResourcesResponse} ListResourcesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListResourcesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.ListResourcesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListResourcesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.ListResourcesResponse} ListResourcesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListResourcesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListResourcesResponse message.
             * @function verify
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListResourcesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a ListResourcesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.ListResourcesResponse} ListResourcesResponse
             */
            ListResourcesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.ListResourcesResponse)
                    return object;
                var message = new $root.Ydb.RateLimiter.ListResourcesResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.RateLimiter.ListResourcesResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListResourcesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @static
             * @param {Ydb.RateLimiter.ListResourcesResponse} message ListResourcesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListResourcesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ListResourcesResponse to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.ListResourcesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListResourcesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListResourcesResponse;
        })();

        RateLimiter.ListResourcesResult = (function() {

            /**
             * Properties of a ListResourcesResult.
             * @memberof Ydb.RateLimiter
             * @interface IListResourcesResult
             * @property {Array.<string>|null} [resourcePaths] ListResourcesResult resourcePaths
             */

            /**
             * Constructs a new ListResourcesResult.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a ListResourcesResult.
             * @implements IListResourcesResult
             * @constructor
             * @param {Ydb.RateLimiter.IListResourcesResult=} [properties] Properties to set
             */
            function ListResourcesResult(properties) {
                this.resourcePaths = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListResourcesResult resourcePaths.
             * @member {Array.<string>} resourcePaths
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @instance
             */
            ListResourcesResult.prototype.resourcePaths = $util.emptyArray;

            /**
             * Creates a new ListResourcesResult instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @static
             * @param {Ydb.RateLimiter.IListResourcesResult=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.ListResourcesResult} ListResourcesResult instance
             */
            ListResourcesResult.create = function create(properties) {
                return new ListResourcesResult(properties);
            };

            /**
             * Encodes the specified ListResourcesResult message. Does not implicitly {@link Ydb.RateLimiter.ListResourcesResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @static
             * @param {Ydb.RateLimiter.IListResourcesResult} message ListResourcesResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListResourcesResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resourcePaths != null && message.resourcePaths.length)
                    for (var i = 0; i < message.resourcePaths.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.resourcePaths[i]);
                return writer;
            };

            /**
             * Encodes the specified ListResourcesResult message, length delimited. Does not implicitly {@link Ydb.RateLimiter.ListResourcesResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @static
             * @param {Ydb.RateLimiter.IListResourcesResult} message ListResourcesResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListResourcesResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListResourcesResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.ListResourcesResult} ListResourcesResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListResourcesResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.ListResourcesResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.resourcePaths && message.resourcePaths.length))
                            message.resourcePaths = [];
                        message.resourcePaths.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListResourcesResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.ListResourcesResult} ListResourcesResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListResourcesResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListResourcesResult message.
             * @function verify
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListResourcesResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resourcePaths != null && message.hasOwnProperty("resourcePaths")) {
                    if (!Array.isArray(message.resourcePaths))
                        return "resourcePaths: array expected";
                    for (var i = 0; i < message.resourcePaths.length; ++i)
                        if (!$util.isString(message.resourcePaths[i]))
                            return "resourcePaths: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ListResourcesResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.ListResourcesResult} ListResourcesResult
             */
            ListResourcesResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.ListResourcesResult)
                    return object;
                var message = new $root.Ydb.RateLimiter.ListResourcesResult();
                if (object.resourcePaths) {
                    if (!Array.isArray(object.resourcePaths))
                        throw TypeError(".Ydb.RateLimiter.ListResourcesResult.resourcePaths: array expected");
                    message.resourcePaths = [];
                    for (var i = 0; i < object.resourcePaths.length; ++i)
                        message.resourcePaths[i] = String(object.resourcePaths[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListResourcesResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @static
             * @param {Ydb.RateLimiter.ListResourcesResult} message ListResourcesResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListResourcesResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.resourcePaths = [];
                if (message.resourcePaths && message.resourcePaths.length) {
                    object.resourcePaths = [];
                    for (var j = 0; j < message.resourcePaths.length; ++j)
                        object.resourcePaths[j] = message.resourcePaths[j];
                }
                return object;
            };

            /**
             * Converts this ListResourcesResult to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.ListResourcesResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListResourcesResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListResourcesResult;
        })();

        RateLimiter.DescribeResourceRequest = (function() {

            /**
             * Properties of a DescribeResourceRequest.
             * @memberof Ydb.RateLimiter
             * @interface IDescribeResourceRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DescribeResourceRequest operationParams
             * @property {string|null} [coordinationNodePath] DescribeResourceRequest coordinationNodePath
             * @property {string|null} [resourcePath] DescribeResourceRequest resourcePath
             */

            /**
             * Constructs a new DescribeResourceRequest.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a DescribeResourceRequest.
             * @implements IDescribeResourceRequest
             * @constructor
             * @param {Ydb.RateLimiter.IDescribeResourceRequest=} [properties] Properties to set
             */
            function DescribeResourceRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeResourceRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @instance
             */
            DescribeResourceRequest.prototype.operationParams = null;

            /**
             * DescribeResourceRequest coordinationNodePath.
             * @member {string} coordinationNodePath
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @instance
             */
            DescribeResourceRequest.prototype.coordinationNodePath = "";

            /**
             * DescribeResourceRequest resourcePath.
             * @member {string} resourcePath
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @instance
             */
            DescribeResourceRequest.prototype.resourcePath = "";

            /**
             * Creates a new DescribeResourceRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @static
             * @param {Ydb.RateLimiter.IDescribeResourceRequest=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.DescribeResourceRequest} DescribeResourceRequest instance
             */
            DescribeResourceRequest.create = function create(properties) {
                return new DescribeResourceRequest(properties);
            };

            /**
             * Encodes the specified DescribeResourceRequest message. Does not implicitly {@link Ydb.RateLimiter.DescribeResourceRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @static
             * @param {Ydb.RateLimiter.IDescribeResourceRequest} message DescribeResourceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeResourceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.coordinationNodePath);
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.resourcePath);
                return writer;
            };

            /**
             * Encodes the specified DescribeResourceRequest message, length delimited. Does not implicitly {@link Ydb.RateLimiter.DescribeResourceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @static
             * @param {Ydb.RateLimiter.IDescribeResourceRequest} message DescribeResourceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeResourceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeResourceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.DescribeResourceRequest} DescribeResourceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeResourceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.DescribeResourceRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.coordinationNodePath = reader.string();
                        break;
                    case 3:
                        message.resourcePath = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeResourceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.DescribeResourceRequest} DescribeResourceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeResourceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeResourceRequest message.
             * @function verify
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeResourceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    if (!$util.isString(message.coordinationNodePath))
                        return "coordinationNodePath: string expected";
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    if (!$util.isString(message.resourcePath))
                        return "resourcePath: string expected";
                return null;
            };

            /**
             * Creates a DescribeResourceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.DescribeResourceRequest} DescribeResourceRequest
             */
            DescribeResourceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.DescribeResourceRequest)
                    return object;
                var message = new $root.Ydb.RateLimiter.DescribeResourceRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.RateLimiter.DescribeResourceRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.coordinationNodePath != null)
                    message.coordinationNodePath = String(object.coordinationNodePath);
                if (object.resourcePath != null)
                    message.resourcePath = String(object.resourcePath);
                return message;
            };

            /**
             * Creates a plain object from a DescribeResourceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @static
             * @param {Ydb.RateLimiter.DescribeResourceRequest} message DescribeResourceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeResourceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.coordinationNodePath = "";
                    object.resourcePath = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.coordinationNodePath != null && message.hasOwnProperty("coordinationNodePath"))
                    object.coordinationNodePath = message.coordinationNodePath;
                if (message.resourcePath != null && message.hasOwnProperty("resourcePath"))
                    object.resourcePath = message.resourcePath;
                return object;
            };

            /**
             * Converts this DescribeResourceRequest to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.DescribeResourceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeResourceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeResourceRequest;
        })();

        RateLimiter.DescribeResourceResponse = (function() {

            /**
             * Properties of a DescribeResourceResponse.
             * @memberof Ydb.RateLimiter
             * @interface IDescribeResourceResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DescribeResourceResponse operation
             */

            /**
             * Constructs a new DescribeResourceResponse.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a DescribeResourceResponse.
             * @implements IDescribeResourceResponse
             * @constructor
             * @param {Ydb.RateLimiter.IDescribeResourceResponse=} [properties] Properties to set
             */
            function DescribeResourceResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeResourceResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @instance
             */
            DescribeResourceResponse.prototype.operation = null;

            /**
             * Creates a new DescribeResourceResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @static
             * @param {Ydb.RateLimiter.IDescribeResourceResponse=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.DescribeResourceResponse} DescribeResourceResponse instance
             */
            DescribeResourceResponse.create = function create(properties) {
                return new DescribeResourceResponse(properties);
            };

            /**
             * Encodes the specified DescribeResourceResponse message. Does not implicitly {@link Ydb.RateLimiter.DescribeResourceResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @static
             * @param {Ydb.RateLimiter.IDescribeResourceResponse} message DescribeResourceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeResourceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeResourceResponse message, length delimited. Does not implicitly {@link Ydb.RateLimiter.DescribeResourceResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @static
             * @param {Ydb.RateLimiter.IDescribeResourceResponse} message DescribeResourceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeResourceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeResourceResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.DescribeResourceResponse} DescribeResourceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeResourceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.DescribeResourceResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeResourceResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.DescribeResourceResponse} DescribeResourceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeResourceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeResourceResponse message.
             * @function verify
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeResourceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeResourceResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.DescribeResourceResponse} DescribeResourceResponse
             */
            DescribeResourceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.DescribeResourceResponse)
                    return object;
                var message = new $root.Ydb.RateLimiter.DescribeResourceResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.RateLimiter.DescribeResourceResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeResourceResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @static
             * @param {Ydb.RateLimiter.DescribeResourceResponse} message DescribeResourceResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeResourceResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DescribeResourceResponse to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.DescribeResourceResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeResourceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeResourceResponse;
        })();

        RateLimiter.DescribeResourceResult = (function() {

            /**
             * Properties of a DescribeResourceResult.
             * @memberof Ydb.RateLimiter
             * @interface IDescribeResourceResult
             * @property {Ydb.RateLimiter.IResource|null} [resource] DescribeResourceResult resource
             */

            /**
             * Constructs a new DescribeResourceResult.
             * @memberof Ydb.RateLimiter
             * @classdesc Represents a DescribeResourceResult.
             * @implements IDescribeResourceResult
             * @constructor
             * @param {Ydb.RateLimiter.IDescribeResourceResult=} [properties] Properties to set
             */
            function DescribeResourceResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeResourceResult resource.
             * @member {Ydb.RateLimiter.IResource|null|undefined} resource
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @instance
             */
            DescribeResourceResult.prototype.resource = null;

            /**
             * Creates a new DescribeResourceResult instance using the specified properties.
             * @function create
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @static
             * @param {Ydb.RateLimiter.IDescribeResourceResult=} [properties] Properties to set
             * @returns {Ydb.RateLimiter.DescribeResourceResult} DescribeResourceResult instance
             */
            DescribeResourceResult.create = function create(properties) {
                return new DescribeResourceResult(properties);
            };

            /**
             * Encodes the specified DescribeResourceResult message. Does not implicitly {@link Ydb.RateLimiter.DescribeResourceResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @static
             * @param {Ydb.RateLimiter.IDescribeResourceResult} message DescribeResourceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeResourceResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resource != null && message.hasOwnProperty("resource"))
                    $root.Ydb.RateLimiter.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeResourceResult message, length delimited. Does not implicitly {@link Ydb.RateLimiter.DescribeResourceResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @static
             * @param {Ydb.RateLimiter.IDescribeResourceResult} message DescribeResourceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeResourceResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeResourceResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.RateLimiter.DescribeResourceResult} DescribeResourceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeResourceResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.RateLimiter.DescribeResourceResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resource = $root.Ydb.RateLimiter.Resource.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeResourceResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.RateLimiter.DescribeResourceResult} DescribeResourceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeResourceResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeResourceResult message.
             * @function verify
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeResourceResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resource != null && message.hasOwnProperty("resource")) {
                    var error = $root.Ydb.RateLimiter.Resource.verify(message.resource);
                    if (error)
                        return "resource." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeResourceResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.RateLimiter.DescribeResourceResult} DescribeResourceResult
             */
            DescribeResourceResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.RateLimiter.DescribeResourceResult)
                    return object;
                var message = new $root.Ydb.RateLimiter.DescribeResourceResult();
                if (object.resource != null) {
                    if (typeof object.resource !== "object")
                        throw TypeError(".Ydb.RateLimiter.DescribeResourceResult.resource: object expected");
                    message.resource = $root.Ydb.RateLimiter.Resource.fromObject(object.resource);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeResourceResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @static
             * @param {Ydb.RateLimiter.DescribeResourceResult} message DescribeResourceResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeResourceResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.resource = null;
                if (message.resource != null && message.hasOwnProperty("resource"))
                    object.resource = $root.Ydb.RateLimiter.Resource.toObject(message.resource, options);
                return object;
            };

            /**
             * Converts this DescribeResourceResult to JSON.
             * @function toJSON
             * @memberof Ydb.RateLimiter.DescribeResourceResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeResourceResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeResourceResult;
        })();

        return RateLimiter;
    })();

    Ydb.Scripting = (function() {

        /**
         * Namespace Scripting.
         * @memberof Ydb
         * @namespace
         */
        var Scripting = {};

        Scripting.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Scripting
             * @namespace
             */
            var V1 = {};

            V1.ScriptingService = (function() {

                /**
                 * Constructs a new ScriptingService service.
                 * @memberof Ydb.Scripting.V1
                 * @classdesc Represents a ScriptingService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ScriptingService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (ScriptingService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ScriptingService;

                /**
                 * Creates new ScriptingService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {ScriptingService} RPC service. Useful where requests and/or responses are streamed.
                 */
                ScriptingService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Scripting.V1.ScriptingService#executeYql}.
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @typedef ExecuteYqlCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Scripting.ExecuteYqlResponse} [response] ExecuteYqlResponse
                 */

                /**
                 * Calls ExecuteYql.
                 * @function executeYql
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @instance
                 * @param {Ydb.Scripting.IExecuteYqlRequest} request ExecuteYqlRequest message or plain object
                 * @param {Ydb.Scripting.V1.ScriptingService.ExecuteYqlCallback} callback Node-style callback called with the error, if any, and ExecuteYqlResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ScriptingService.prototype.executeYql = function executeYql(request, callback) {
                    return this.rpcCall(executeYql, $root.Ydb.Scripting.ExecuteYqlRequest, $root.Ydb.Scripting.ExecuteYqlResponse, request, callback);
                }, "name", { value: "ExecuteYql" });

                /**
                 * Calls ExecuteYql.
                 * @function executeYql
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @instance
                 * @param {Ydb.Scripting.IExecuteYqlRequest} request ExecuteYqlRequest message or plain object
                 * @returns {Promise<Ydb.Scripting.ExecuteYqlResponse>} Promise
                 * @variation 2
                 */

                return ScriptingService;
            })();

            return V1;
        })();

        Scripting.ExecuteYqlRequest = (function() {

            /**
             * Properties of an ExecuteYqlRequest.
             * @memberof Ydb.Scripting
             * @interface IExecuteYqlRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExecuteYqlRequest operationParams
             * @property {string|null} [script] ExecuteYqlRequest script
             * @property {Object.<string,Ydb.ITypedValue>|null} [parameters] ExecuteYqlRequest parameters
             */

            /**
             * Constructs a new ExecuteYqlRequest.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExecuteYqlRequest.
             * @implements IExecuteYqlRequest
             * @constructor
             * @param {Ydb.Scripting.IExecuteYqlRequest=} [properties] Properties to set
             */
            function ExecuteYqlRequest(properties) {
                this.parameters = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteYqlRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @instance
             */
            ExecuteYqlRequest.prototype.operationParams = null;

            /**
             * ExecuteYqlRequest script.
             * @member {string} script
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @instance
             */
            ExecuteYqlRequest.prototype.script = "";

            /**
             * ExecuteYqlRequest parameters.
             * @member {Object.<string,Ydb.ITypedValue>} parameters
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @instance
             */
            ExecuteYqlRequest.prototype.parameters = $util.emptyObject;

            /**
             * Creates a new ExecuteYqlRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Ydb.Scripting.IExecuteYqlRequest=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExecuteYqlRequest} ExecuteYqlRequest instance
             */
            ExecuteYqlRequest.create = function create(properties) {
                return new ExecuteYqlRequest(properties);
            };

            /**
             * Encodes the specified ExecuteYqlRequest message. Does not implicitly {@link Ydb.Scripting.ExecuteYqlRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Ydb.Scripting.IExecuteYqlRequest} message ExecuteYqlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.script != null && message.hasOwnProperty("script"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.script);
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.TypedValue.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified ExecuteYqlRequest message, length delimited. Does not implicitly {@link Ydb.Scripting.ExecuteYqlRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Ydb.Scripting.IExecuteYqlRequest} message ExecuteYqlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteYqlRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExecuteYqlRequest} ExecuteYqlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExecuteYqlRequest(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.script = reader.string();
                        break;
                    case 3:
                        reader.skip().pos++;
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        key = reader.string();
                        reader.pos++;
                        message.parameters[key] = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteYqlRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExecuteYqlRequest} ExecuteYqlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteYqlRequest message.
             * @function verify
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteYqlRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.script != null && message.hasOwnProperty("script"))
                    if (!$util.isString(message.script))
                        return "script: string expected";
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!$util.isObject(message.parameters))
                        return "parameters: object expected";
                    var key = Object.keys(message.parameters);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.parameters[key[i]]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExecuteYqlRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExecuteYqlRequest} ExecuteYqlRequest
             */
            ExecuteYqlRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExecuteYqlRequest)
                    return object;
                var message = new $root.Ydb.Scripting.ExecuteYqlRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.script != null)
                    message.script = String(object.script);
                if (object.parameters) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlRequest.parameters: object expected");
                    message.parameters = {};
                    for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                        if (typeof object.parameters[keys[i]] !== "object")
                            throw TypeError(".Ydb.Scripting.ExecuteYqlRequest.parameters: object expected");
                        message.parameters[keys[i]] = $root.Ydb.TypedValue.fromObject(object.parameters[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteYqlRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Ydb.Scripting.ExecuteYqlRequest} message ExecuteYqlRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteYqlRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parameters = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.script = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.script != null && message.hasOwnProperty("script"))
                    object.script = message.script;
                var keys2;
                if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                    object.parameters = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parameters[keys2[j]] = $root.Ydb.TypedValue.toObject(message.parameters[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this ExecuteYqlRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteYqlRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteYqlRequest;
        })();

        Scripting.ExecuteYqlResponse = (function() {

            /**
             * Properties of an ExecuteYqlResponse.
             * @memberof Ydb.Scripting
             * @interface IExecuteYqlResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExecuteYqlResponse operation
             */

            /**
             * Constructs a new ExecuteYqlResponse.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExecuteYqlResponse.
             * @implements IExecuteYqlResponse
             * @constructor
             * @param {Ydb.Scripting.IExecuteYqlResponse=} [properties] Properties to set
             */
            function ExecuteYqlResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteYqlResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @instance
             */
            ExecuteYqlResponse.prototype.operation = null;

            /**
             * Creates a new ExecuteYqlResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResponse=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExecuteYqlResponse} ExecuteYqlResponse instance
             */
            ExecuteYqlResponse.create = function create(properties) {
                return new ExecuteYqlResponse(properties);
            };

            /**
             * Encodes the specified ExecuteYqlResponse message. Does not implicitly {@link Ydb.Scripting.ExecuteYqlResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResponse} message ExecuteYqlResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteYqlResponse message, length delimited. Does not implicitly {@link Ydb.Scripting.ExecuteYqlResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResponse} message ExecuteYqlResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteYqlResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExecuteYqlResponse} ExecuteYqlResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExecuteYqlResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteYqlResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExecuteYqlResponse} ExecuteYqlResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteYqlResponse message.
             * @function verify
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteYqlResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteYqlResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExecuteYqlResponse} ExecuteYqlResponse
             */
            ExecuteYqlResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExecuteYqlResponse)
                    return object;
                var message = new $root.Ydb.Scripting.ExecuteYqlResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteYqlResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Ydb.Scripting.ExecuteYqlResponse} message ExecuteYqlResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteYqlResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExecuteYqlResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteYqlResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteYqlResponse;
        })();

        Scripting.ExecuteYqlResult = (function() {

            /**
             * Properties of an ExecuteYqlResult.
             * @memberof Ydb.Scripting
             * @interface IExecuteYqlResult
             * @property {Array.<Ydb.IResultSet>|null} [resultSets] ExecuteYqlResult resultSets
             */

            /**
             * Constructs a new ExecuteYqlResult.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExecuteYqlResult.
             * @implements IExecuteYqlResult
             * @constructor
             * @param {Ydb.Scripting.IExecuteYqlResult=} [properties] Properties to set
             */
            function ExecuteYqlResult(properties) {
                this.resultSets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteYqlResult resultSets.
             * @member {Array.<Ydb.IResultSet>} resultSets
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @instance
             */
            ExecuteYqlResult.prototype.resultSets = $util.emptyArray;

            /**
             * Creates a new ExecuteYqlResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResult=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExecuteYqlResult} ExecuteYqlResult instance
             */
            ExecuteYqlResult.create = function create(properties) {
                return new ExecuteYqlResult(properties);
            };

            /**
             * Encodes the specified ExecuteYqlResult message. Does not implicitly {@link Ydb.Scripting.ExecuteYqlResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResult} message ExecuteYqlResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultSets != null && message.resultSets.length)
                    for (var i = 0; i < message.resultSets.length; ++i)
                        $root.Ydb.ResultSet.encode(message.resultSets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteYqlResult message, length delimited. Does not implicitly {@link Ydb.Scripting.ExecuteYqlResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResult} message ExecuteYqlResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteYqlResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExecuteYqlResult} ExecuteYqlResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExecuteYqlResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.resultSets && message.resultSets.length))
                            message.resultSets = [];
                        message.resultSets.push($root.Ydb.ResultSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteYqlResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExecuteYqlResult} ExecuteYqlResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteYqlResult message.
             * @function verify
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteYqlResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultSets != null && message.hasOwnProperty("resultSets")) {
                    if (!Array.isArray(message.resultSets))
                        return "resultSets: array expected";
                    for (var i = 0; i < message.resultSets.length; ++i) {
                        var error = $root.Ydb.ResultSet.verify(message.resultSets[i]);
                        if (error)
                            return "resultSets." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExecuteYqlResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExecuteYqlResult} ExecuteYqlResult
             */
            ExecuteYqlResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExecuteYqlResult)
                    return object;
                var message = new $root.Ydb.Scripting.ExecuteYqlResult();
                if (object.resultSets) {
                    if (!Array.isArray(object.resultSets))
                        throw TypeError(".Ydb.Scripting.ExecuteYqlResult.resultSets: array expected");
                    message.resultSets = [];
                    for (var i = 0; i < object.resultSets.length; ++i) {
                        if (typeof object.resultSets[i] !== "object")
                            throw TypeError(".Ydb.Scripting.ExecuteYqlResult.resultSets: object expected");
                        message.resultSets[i] = $root.Ydb.ResultSet.fromObject(object.resultSets[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteYqlResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Ydb.Scripting.ExecuteYqlResult} message ExecuteYqlResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteYqlResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.resultSets = [];
                if (message.resultSets && message.resultSets.length) {
                    object.resultSets = [];
                    for (var j = 0; j < message.resultSets.length; ++j)
                        object.resultSets[j] = $root.Ydb.ResultSet.toObject(message.resultSets[j], options);
                }
                return object;
            };

            /**
             * Converts this ExecuteYqlResult to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteYqlResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteYqlResult;
        })();

        return Scripting;
    })();

    Ydb.DecimalType = (function() {

        /**
         * Properties of a DecimalType.
         * @memberof Ydb
         * @interface IDecimalType
         * @property {number|null} [precision] DecimalType precision
         * @property {number|null} [scale] DecimalType scale
         */

        /**
         * Constructs a new DecimalType.
         * @memberof Ydb
         * @classdesc Represents a DecimalType.
         * @implements IDecimalType
         * @constructor
         * @param {Ydb.IDecimalType=} [properties] Properties to set
         */
        function DecimalType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecimalType precision.
         * @member {number} precision
         * @memberof Ydb.DecimalType
         * @instance
         */
        DecimalType.prototype.precision = 0;

        /**
         * DecimalType scale.
         * @member {number} scale
         * @memberof Ydb.DecimalType
         * @instance
         */
        DecimalType.prototype.scale = 0;

        /**
         * Creates a new DecimalType instance using the specified properties.
         * @function create
         * @memberof Ydb.DecimalType
         * @static
         * @param {Ydb.IDecimalType=} [properties] Properties to set
         * @returns {Ydb.DecimalType} DecimalType instance
         */
        DecimalType.create = function create(properties) {
            return new DecimalType(properties);
        };

        /**
         * Encodes the specified DecimalType message. Does not implicitly {@link Ydb.DecimalType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.DecimalType
         * @static
         * @param {Ydb.IDecimalType} message DecimalType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecimalType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.precision != null && message.hasOwnProperty("precision"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.precision);
            if (message.scale != null && message.hasOwnProperty("scale"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.scale);
            return writer;
        };

        /**
         * Encodes the specified DecimalType message, length delimited. Does not implicitly {@link Ydb.DecimalType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.DecimalType
         * @static
         * @param {Ydb.IDecimalType} message DecimalType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecimalType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecimalType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.DecimalType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.DecimalType} DecimalType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecimalType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.DecimalType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.precision = reader.uint32();
                    break;
                case 2:
                    message.scale = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DecimalType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.DecimalType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.DecimalType} DecimalType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecimalType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecimalType message.
         * @function verify
         * @memberof Ydb.DecimalType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecimalType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.precision != null && message.hasOwnProperty("precision"))
                if (!$util.isInteger(message.precision))
                    return "precision: integer expected";
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (!$util.isInteger(message.scale))
                    return "scale: integer expected";
            return null;
        };

        /**
         * Creates a DecimalType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.DecimalType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.DecimalType} DecimalType
         */
        DecimalType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.DecimalType)
                return object;
            var message = new $root.Ydb.DecimalType();
            if (object.precision != null)
                message.precision = object.precision >>> 0;
            if (object.scale != null)
                message.scale = object.scale >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DecimalType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.DecimalType
         * @static
         * @param {Ydb.DecimalType} message DecimalType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecimalType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.precision = 0;
                object.scale = 0;
            }
            if (message.precision != null && message.hasOwnProperty("precision"))
                object.precision = message.precision;
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = message.scale;
            return object;
        };

        /**
         * Converts this DecimalType to JSON.
         * @function toJSON
         * @memberof Ydb.DecimalType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecimalType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DecimalType;
    })();

    Ydb.OptionalType = (function() {

        /**
         * Properties of an OptionalType.
         * @memberof Ydb
         * @interface IOptionalType
         * @property {Ydb.IType|null} [item] OptionalType item
         */

        /**
         * Constructs a new OptionalType.
         * @memberof Ydb
         * @classdesc Represents an OptionalType.
         * @implements IOptionalType
         * @constructor
         * @param {Ydb.IOptionalType=} [properties] Properties to set
         */
        function OptionalType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionalType item.
         * @member {Ydb.IType|null|undefined} item
         * @memberof Ydb.OptionalType
         * @instance
         */
        OptionalType.prototype.item = null;

        /**
         * Creates a new OptionalType instance using the specified properties.
         * @function create
         * @memberof Ydb.OptionalType
         * @static
         * @param {Ydb.IOptionalType=} [properties] Properties to set
         * @returns {Ydb.OptionalType} OptionalType instance
         */
        OptionalType.create = function create(properties) {
            return new OptionalType(properties);
        };

        /**
         * Encodes the specified OptionalType message. Does not implicitly {@link Ydb.OptionalType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.OptionalType
         * @static
         * @param {Ydb.IOptionalType} message OptionalType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionalType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && message.hasOwnProperty("item"))
                $root.Ydb.Type.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OptionalType message, length delimited. Does not implicitly {@link Ydb.OptionalType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.OptionalType
         * @static
         * @param {Ydb.IOptionalType} message OptionalType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionalType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionalType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.OptionalType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.OptionalType} OptionalType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionalType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.OptionalType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OptionalType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.OptionalType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.OptionalType} OptionalType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionalType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionalType message.
         * @function verify
         * @memberof Ydb.OptionalType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionalType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.Ydb.Type.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates an OptionalType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.OptionalType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.OptionalType} OptionalType
         */
        OptionalType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.OptionalType)
                return object;
            var message = new $root.Ydb.OptionalType();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".Ydb.OptionalType.item: object expected");
                message.item = $root.Ydb.Type.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from an OptionalType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.OptionalType
         * @static
         * @param {Ydb.OptionalType} message OptionalType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionalType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.Ydb.Type.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this OptionalType to JSON.
         * @function toJSON
         * @memberof Ydb.OptionalType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionalType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionalType;
    })();

    Ydb.ListType = (function() {

        /**
         * Properties of a ListType.
         * @memberof Ydb
         * @interface IListType
         * @property {Ydb.IType|null} [item] ListType item
         */

        /**
         * Constructs a new ListType.
         * @memberof Ydb
         * @classdesc Represents a ListType.
         * @implements IListType
         * @constructor
         * @param {Ydb.IListType=} [properties] Properties to set
         */
        function ListType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListType item.
         * @member {Ydb.IType|null|undefined} item
         * @memberof Ydb.ListType
         * @instance
         */
        ListType.prototype.item = null;

        /**
         * Creates a new ListType instance using the specified properties.
         * @function create
         * @memberof Ydb.ListType
         * @static
         * @param {Ydb.IListType=} [properties] Properties to set
         * @returns {Ydb.ListType} ListType instance
         */
        ListType.create = function create(properties) {
            return new ListType(properties);
        };

        /**
         * Encodes the specified ListType message. Does not implicitly {@link Ydb.ListType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.ListType
         * @static
         * @param {Ydb.IListType} message ListType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && message.hasOwnProperty("item"))
                $root.Ydb.Type.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListType message, length delimited. Does not implicitly {@link Ydb.ListType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.ListType
         * @static
         * @param {Ydb.IListType} message ListType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.ListType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.ListType} ListType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.ListType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.ListType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.ListType} ListType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListType message.
         * @function verify
         * @memberof Ydb.ListType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.Ydb.Type.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a ListType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.ListType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.ListType} ListType
         */
        ListType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.ListType)
                return object;
            var message = new $root.Ydb.ListType();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".Ydb.ListType.item: object expected");
                message.item = $root.Ydb.Type.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a ListType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.ListType
         * @static
         * @param {Ydb.ListType} message ListType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.Ydb.Type.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this ListType to JSON.
         * @function toJSON
         * @memberof Ydb.ListType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListType;
    })();

    Ydb.VariantType = (function() {

        /**
         * Properties of a VariantType.
         * @memberof Ydb
         * @interface IVariantType
         * @property {Ydb.ITupleType|null} [tupleItems] VariantType tupleItems
         * @property {Ydb.IStructType|null} [structItems] VariantType structItems
         */

        /**
         * Constructs a new VariantType.
         * @memberof Ydb
         * @classdesc Represents a VariantType.
         * @implements IVariantType
         * @constructor
         * @param {Ydb.IVariantType=} [properties] Properties to set
         */
        function VariantType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VariantType tupleItems.
         * @member {Ydb.ITupleType|null|undefined} tupleItems
         * @memberof Ydb.VariantType
         * @instance
         */
        VariantType.prototype.tupleItems = null;

        /**
         * VariantType structItems.
         * @member {Ydb.IStructType|null|undefined} structItems
         * @memberof Ydb.VariantType
         * @instance
         */
        VariantType.prototype.structItems = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * VariantType type.
         * @member {"tupleItems"|"structItems"|undefined} type
         * @memberof Ydb.VariantType
         * @instance
         */
        Object.defineProperty(VariantType.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["tupleItems", "structItems"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new VariantType instance using the specified properties.
         * @function create
         * @memberof Ydb.VariantType
         * @static
         * @param {Ydb.IVariantType=} [properties] Properties to set
         * @returns {Ydb.VariantType} VariantType instance
         */
        VariantType.create = function create(properties) {
            return new VariantType(properties);
        };

        /**
         * Encodes the specified VariantType message. Does not implicitly {@link Ydb.VariantType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.VariantType
         * @static
         * @param {Ydb.IVariantType} message VariantType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VariantType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tupleItems != null && message.hasOwnProperty("tupleItems"))
                $root.Ydb.TupleType.encode(message.tupleItems, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.structItems != null && message.hasOwnProperty("structItems"))
                $root.Ydb.StructType.encode(message.structItems, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VariantType message, length delimited. Does not implicitly {@link Ydb.VariantType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.VariantType
         * @static
         * @param {Ydb.IVariantType} message VariantType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VariantType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VariantType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.VariantType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.VariantType} VariantType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VariantType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.VariantType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tupleItems = $root.Ydb.TupleType.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.structItems = $root.Ydb.StructType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VariantType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.VariantType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.VariantType} VariantType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VariantType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VariantType message.
         * @function verify
         * @memberof Ydb.VariantType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VariantType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.tupleItems != null && message.hasOwnProperty("tupleItems")) {
                properties.type = 1;
                {
                    var error = $root.Ydb.TupleType.verify(message.tupleItems);
                    if (error)
                        return "tupleItems." + error;
                }
            }
            if (message.structItems != null && message.hasOwnProperty("structItems")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.StructType.verify(message.structItems);
                    if (error)
                        return "structItems." + error;
                }
            }
            return null;
        };

        /**
         * Creates a VariantType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.VariantType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.VariantType} VariantType
         */
        VariantType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.VariantType)
                return object;
            var message = new $root.Ydb.VariantType();
            if (object.tupleItems != null) {
                if (typeof object.tupleItems !== "object")
                    throw TypeError(".Ydb.VariantType.tupleItems: object expected");
                message.tupleItems = $root.Ydb.TupleType.fromObject(object.tupleItems);
            }
            if (object.structItems != null) {
                if (typeof object.structItems !== "object")
                    throw TypeError(".Ydb.VariantType.structItems: object expected");
                message.structItems = $root.Ydb.StructType.fromObject(object.structItems);
            }
            return message;
        };

        /**
         * Creates a plain object from a VariantType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.VariantType
         * @static
         * @param {Ydb.VariantType} message VariantType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VariantType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.tupleItems != null && message.hasOwnProperty("tupleItems")) {
                object.tupleItems = $root.Ydb.TupleType.toObject(message.tupleItems, options);
                if (options.oneofs)
                    object.type = "tupleItems";
            }
            if (message.structItems != null && message.hasOwnProperty("structItems")) {
                object.structItems = $root.Ydb.StructType.toObject(message.structItems, options);
                if (options.oneofs)
                    object.type = "structItems";
            }
            return object;
        };

        /**
         * Converts this VariantType to JSON.
         * @function toJSON
         * @memberof Ydb.VariantType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VariantType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VariantType;
    })();

    Ydb.TupleType = (function() {

        /**
         * Properties of a TupleType.
         * @memberof Ydb
         * @interface ITupleType
         * @property {Array.<Ydb.IType>|null} [elements] TupleType elements
         */

        /**
         * Constructs a new TupleType.
         * @memberof Ydb
         * @classdesc Represents a TupleType.
         * @implements ITupleType
         * @constructor
         * @param {Ydb.ITupleType=} [properties] Properties to set
         */
        function TupleType(properties) {
            this.elements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TupleType elements.
         * @member {Array.<Ydb.IType>} elements
         * @memberof Ydb.TupleType
         * @instance
         */
        TupleType.prototype.elements = $util.emptyArray;

        /**
         * Creates a new TupleType instance using the specified properties.
         * @function create
         * @memberof Ydb.TupleType
         * @static
         * @param {Ydb.ITupleType=} [properties] Properties to set
         * @returns {Ydb.TupleType} TupleType instance
         */
        TupleType.create = function create(properties) {
            return new TupleType(properties);
        };

        /**
         * Encodes the specified TupleType message. Does not implicitly {@link Ydb.TupleType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.TupleType
         * @static
         * @param {Ydb.ITupleType} message TupleType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TupleType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elements != null && message.elements.length)
                for (var i = 0; i < message.elements.length; ++i)
                    $root.Ydb.Type.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TupleType message, length delimited. Does not implicitly {@link Ydb.TupleType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.TupleType
         * @static
         * @param {Ydb.ITupleType} message TupleType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TupleType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TupleType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.TupleType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.TupleType} TupleType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TupleType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TupleType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.elements && message.elements.length))
                        message.elements = [];
                    message.elements.push($root.Ydb.Type.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TupleType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.TupleType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.TupleType} TupleType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TupleType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TupleType message.
         * @function verify
         * @memberof Ydb.TupleType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TupleType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elements != null && message.hasOwnProperty("elements")) {
                if (!Array.isArray(message.elements))
                    return "elements: array expected";
                for (var i = 0; i < message.elements.length; ++i) {
                    var error = $root.Ydb.Type.verify(message.elements[i]);
                    if (error)
                        return "elements." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TupleType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.TupleType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.TupleType} TupleType
         */
        TupleType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.TupleType)
                return object;
            var message = new $root.Ydb.TupleType();
            if (object.elements) {
                if (!Array.isArray(object.elements))
                    throw TypeError(".Ydb.TupleType.elements: array expected");
                message.elements = [];
                for (var i = 0; i < object.elements.length; ++i) {
                    if (typeof object.elements[i] !== "object")
                        throw TypeError(".Ydb.TupleType.elements: object expected");
                    message.elements[i] = $root.Ydb.Type.fromObject(object.elements[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TupleType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.TupleType
         * @static
         * @param {Ydb.TupleType} message TupleType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TupleType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.elements = [];
            if (message.elements && message.elements.length) {
                object.elements = [];
                for (var j = 0; j < message.elements.length; ++j)
                    object.elements[j] = $root.Ydb.Type.toObject(message.elements[j], options);
            }
            return object;
        };

        /**
         * Converts this TupleType to JSON.
         * @function toJSON
         * @memberof Ydb.TupleType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TupleType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TupleType;
    })();

    Ydb.StructMember = (function() {

        /**
         * Properties of a StructMember.
         * @memberof Ydb
         * @interface IStructMember
         * @property {string|null} [name] StructMember name
         * @property {Ydb.IType|null} [type] StructMember type
         */

        /**
         * Constructs a new StructMember.
         * @memberof Ydb
         * @classdesc Represents a StructMember.
         * @implements IStructMember
         * @constructor
         * @param {Ydb.IStructMember=} [properties] Properties to set
         */
        function StructMember(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StructMember name.
         * @member {string} name
         * @memberof Ydb.StructMember
         * @instance
         */
        StructMember.prototype.name = "";

        /**
         * StructMember type.
         * @member {Ydb.IType|null|undefined} type
         * @memberof Ydb.StructMember
         * @instance
         */
        StructMember.prototype.type = null;

        /**
         * Creates a new StructMember instance using the specified properties.
         * @function create
         * @memberof Ydb.StructMember
         * @static
         * @param {Ydb.IStructMember=} [properties] Properties to set
         * @returns {Ydb.StructMember} StructMember instance
         */
        StructMember.create = function create(properties) {
            return new StructMember(properties);
        };

        /**
         * Encodes the specified StructMember message. Does not implicitly {@link Ydb.StructMember.verify|verify} messages.
         * @function encode
         * @memberof Ydb.StructMember
         * @static
         * @param {Ydb.IStructMember} message StructMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StructMember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && message.hasOwnProperty("type"))
                $root.Ydb.Type.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StructMember message, length delimited. Does not implicitly {@link Ydb.StructMember.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.StructMember
         * @static
         * @param {Ydb.IStructMember} message StructMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StructMember.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StructMember message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.StructMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.StructMember} StructMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StructMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.StructMember();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StructMember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.StructMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.StructMember} StructMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StructMember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StructMember message.
         * @function verify
         * @memberof Ydb.StructMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StructMember.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.Ydb.Type.verify(message.type);
                if (error)
                    return "type." + error;
            }
            return null;
        };

        /**
         * Creates a StructMember message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.StructMember
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.StructMember} StructMember
         */
        StructMember.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.StructMember)
                return object;
            var message = new $root.Ydb.StructMember();
            if (object.name != null)
                message.name = String(object.name);
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".Ydb.StructMember.type: object expected");
                message.type = $root.Ydb.Type.fromObject(object.type);
            }
            return message;
        };

        /**
         * Creates a plain object from a StructMember message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.StructMember
         * @static
         * @param {Ydb.StructMember} message StructMember
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StructMember.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.Ydb.Type.toObject(message.type, options);
            return object;
        };

        /**
         * Converts this StructMember to JSON.
         * @function toJSON
         * @memberof Ydb.StructMember
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StructMember.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StructMember;
    })();

    Ydb.StructType = (function() {

        /**
         * Properties of a StructType.
         * @memberof Ydb
         * @interface IStructType
         * @property {Array.<Ydb.IStructMember>|null} [members] StructType members
         */

        /**
         * Constructs a new StructType.
         * @memberof Ydb
         * @classdesc Represents a StructType.
         * @implements IStructType
         * @constructor
         * @param {Ydb.IStructType=} [properties] Properties to set
         */
        function StructType(properties) {
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StructType members.
         * @member {Array.<Ydb.IStructMember>} members
         * @memberof Ydb.StructType
         * @instance
         */
        StructType.prototype.members = $util.emptyArray;

        /**
         * Creates a new StructType instance using the specified properties.
         * @function create
         * @memberof Ydb.StructType
         * @static
         * @param {Ydb.IStructType=} [properties] Properties to set
         * @returns {Ydb.StructType} StructType instance
         */
        StructType.create = function create(properties) {
            return new StructType(properties);
        };

        /**
         * Encodes the specified StructType message. Does not implicitly {@link Ydb.StructType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.StructType
         * @static
         * @param {Ydb.IStructType} message StructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.Ydb.StructMember.encode(message.members[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StructType message, length delimited. Does not implicitly {@link Ydb.StructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.StructType
         * @static
         * @param {Ydb.IStructType} message StructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StructType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.StructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.StructType} StructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.StructType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.Ydb.StructMember.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.StructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.StructType} StructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StructType message.
         * @function verify
         * @memberof Ydb.StructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (var i = 0; i < message.members.length; ++i) {
                    var error = $root.Ydb.StructMember.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            return null;
        };

        /**
         * Creates a StructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.StructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.StructType} StructType
         */
        StructType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.StructType)
                return object;
            var message = new $root.Ydb.StructType();
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".Ydb.StructType.members: array expected");
                message.members = [];
                for (var i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".Ydb.StructType.members: object expected");
                    message.members[i] = $root.Ydb.StructMember.fromObject(object.members[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a StructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.StructType
         * @static
         * @param {Ydb.StructType} message StructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StructType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.members = [];
            if (message.members && message.members.length) {
                object.members = [];
                for (var j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.Ydb.StructMember.toObject(message.members[j], options);
            }
            return object;
        };

        /**
         * Converts this StructType to JSON.
         * @function toJSON
         * @memberof Ydb.StructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StructType;
    })();

    Ydb.DictType = (function() {

        /**
         * Properties of a DictType.
         * @memberof Ydb
         * @interface IDictType
         * @property {Ydb.IType|null} [key] DictType key
         * @property {Ydb.IType|null} [payload] DictType payload
         */

        /**
         * Constructs a new DictType.
         * @memberof Ydb
         * @classdesc Represents a DictType.
         * @implements IDictType
         * @constructor
         * @param {Ydb.IDictType=} [properties] Properties to set
         */
        function DictType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DictType key.
         * @member {Ydb.IType|null|undefined} key
         * @memberof Ydb.DictType
         * @instance
         */
        DictType.prototype.key = null;

        /**
         * DictType payload.
         * @member {Ydb.IType|null|undefined} payload
         * @memberof Ydb.DictType
         * @instance
         */
        DictType.prototype.payload = null;

        /**
         * Creates a new DictType instance using the specified properties.
         * @function create
         * @memberof Ydb.DictType
         * @static
         * @param {Ydb.IDictType=} [properties] Properties to set
         * @returns {Ydb.DictType} DictType instance
         */
        DictType.create = function create(properties) {
            return new DictType(properties);
        };

        /**
         * Encodes the specified DictType message. Does not implicitly {@link Ydb.DictType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.DictType
         * @static
         * @param {Ydb.IDictType} message DictType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DictType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                $root.Ydb.Type.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.payload != null && message.hasOwnProperty("payload"))
                $root.Ydb.Type.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DictType message, length delimited. Does not implicitly {@link Ydb.DictType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.DictType
         * @static
         * @param {Ydb.IDictType} message DictType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DictType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DictType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.DictType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.DictType} DictType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DictType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.DictType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.payload = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DictType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.DictType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.DictType} DictType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DictType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DictType message.
         * @function verify
         * @memberof Ydb.DictType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DictType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.Ydb.Type.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.Ydb.Type.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates a DictType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.DictType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.DictType} DictType
         */
        DictType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.DictType)
                return object;
            var message = new $root.Ydb.DictType();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".Ydb.DictType.key: object expected");
                message.key = $root.Ydb.Type.fromObject(object.key);
            }
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".Ydb.DictType.payload: object expected");
                message.payload = $root.Ydb.Type.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from a DictType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.DictType
         * @static
         * @param {Ydb.DictType} message DictType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DictType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.payload = null;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.Ydb.Type.toObject(message.key, options);
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.Ydb.Type.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this DictType to JSON.
         * @function toJSON
         * @memberof Ydb.DictType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DictType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DictType;
    })();

    Ydb.Type = (function() {

        /**
         * Properties of a Type.
         * @memberof Ydb
         * @interface IType
         * @property {Ydb.Type.PrimitiveTypeId|null} [typeId] Type typeId
         * @property {Ydb.IDecimalType|null} [decimalType] Type decimalType
         * @property {Ydb.IOptionalType|null} [optionalType] Type optionalType
         * @property {Ydb.IListType|null} [listType] Type listType
         * @property {Ydb.ITupleType|null} [tupleType] Type tupleType
         * @property {Ydb.IStructType|null} [structType] Type structType
         * @property {Ydb.IDictType|null} [dictType] Type dictType
         * @property {Ydb.IVariantType|null} [variantType] Type variantType
         * @property {google.protobuf.NullValue|null} [voidType] Type voidType
         */

        /**
         * Constructs a new Type.
         * @memberof Ydb
         * @classdesc Represents a Type.
         * @implements IType
         * @constructor
         * @param {Ydb.IType=} [properties] Properties to set
         */
        function Type(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Type typeId.
         * @member {Ydb.Type.PrimitiveTypeId} typeId
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.typeId = 0;

        /**
         * Type decimalType.
         * @member {Ydb.IDecimalType|null|undefined} decimalType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.decimalType = null;

        /**
         * Type optionalType.
         * @member {Ydb.IOptionalType|null|undefined} optionalType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.optionalType = null;

        /**
         * Type listType.
         * @member {Ydb.IListType|null|undefined} listType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.listType = null;

        /**
         * Type tupleType.
         * @member {Ydb.ITupleType|null|undefined} tupleType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.tupleType = null;

        /**
         * Type structType.
         * @member {Ydb.IStructType|null|undefined} structType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.structType = null;

        /**
         * Type dictType.
         * @member {Ydb.IDictType|null|undefined} dictType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.dictType = null;

        /**
         * Type variantType.
         * @member {Ydb.IVariantType|null|undefined} variantType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.variantType = null;

        /**
         * Type voidType.
         * @member {google.protobuf.NullValue} voidType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.voidType = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Type type.
         * @member {"typeId"|"decimalType"|"optionalType"|"listType"|"tupleType"|"structType"|"dictType"|"variantType"|"voidType"|undefined} type
         * @memberof Ydb.Type
         * @instance
         */
        Object.defineProperty(Type.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["typeId", "decimalType", "optionalType", "listType", "tupleType", "structType", "dictType", "variantType", "voidType"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Type instance using the specified properties.
         * @function create
         * @memberof Ydb.Type
         * @static
         * @param {Ydb.IType=} [properties] Properties to set
         * @returns {Ydb.Type} Type instance
         */
        Type.create = function create(properties) {
            return new Type(properties);
        };

        /**
         * Encodes the specified Type message. Does not implicitly {@link Ydb.Type.verify|verify} messages.
         * @function encode
         * @memberof Ydb.Type
         * @static
         * @param {Ydb.IType} message Type message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Type.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.typeId);
            if (message.decimalType != null && message.hasOwnProperty("decimalType"))
                $root.Ydb.DecimalType.encode(message.decimalType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.optionalType != null && message.hasOwnProperty("optionalType"))
                $root.Ydb.OptionalType.encode(message.optionalType, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.listType != null && message.hasOwnProperty("listType"))
                $root.Ydb.ListType.encode(message.listType, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            if (message.tupleType != null && message.hasOwnProperty("tupleType"))
                $root.Ydb.TupleType.encode(message.tupleType, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
            if (message.structType != null && message.hasOwnProperty("structType"))
                $root.Ydb.StructType.encode(message.structType, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
            if (message.dictType != null && message.hasOwnProperty("dictType"))
                $root.Ydb.DictType.encode(message.dictType, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
            if (message.variantType != null && message.hasOwnProperty("variantType"))
                $root.Ydb.VariantType.encode(message.variantType, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
            if (message.voidType != null && message.hasOwnProperty("voidType"))
                writer.uint32(/* id 201, wireType 0 =*/1608).int32(message.voidType);
            return writer;
        };

        /**
         * Encodes the specified Type message, length delimited. Does not implicitly {@link Ydb.Type.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.Type
         * @static
         * @param {Ydb.IType} message Type message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Type.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Type message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.Type
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.Type} Type
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Type.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Type();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeId = reader.int32();
                    break;
                case 2:
                    message.decimalType = $root.Ydb.DecimalType.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.optionalType = $root.Ydb.OptionalType.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.listType = $root.Ydb.ListType.decode(reader, reader.uint32());
                    break;
                case 103:
                    message.tupleType = $root.Ydb.TupleType.decode(reader, reader.uint32());
                    break;
                case 104:
                    message.structType = $root.Ydb.StructType.decode(reader, reader.uint32());
                    break;
                case 105:
                    message.dictType = $root.Ydb.DictType.decode(reader, reader.uint32());
                    break;
                case 106:
                    message.variantType = $root.Ydb.VariantType.decode(reader, reader.uint32());
                    break;
                case 201:
                    message.voidType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Type message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.Type
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.Type} Type
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Type.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Type message.
         * @function verify
         * @memberof Ydb.Type
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Type.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.typeId != null && message.hasOwnProperty("typeId")) {
                properties.type = 1;
                switch (message.typeId) {
                default:
                    return "typeId: enum value expected";
                case 0:
                case 6:
                case 7:
                case 5:
                case 8:
                case 9:
                case 1:
                case 2:
                case 3:
                case 4:
                case 33:
                case 32:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 4097:
                case 4608:
                case 4609:
                case 4610:
                case 4611:
                    break;
                }
            }
            if (message.decimalType != null && message.hasOwnProperty("decimalType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.DecimalType.verify(message.decimalType);
                    if (error)
                        return "decimalType." + error;
                }
            }
            if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.OptionalType.verify(message.optionalType);
                    if (error)
                        return "optionalType." + error;
                }
            }
            if (message.listType != null && message.hasOwnProperty("listType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.ListType.verify(message.listType);
                    if (error)
                        return "listType." + error;
                }
            }
            if (message.tupleType != null && message.hasOwnProperty("tupleType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.TupleType.verify(message.tupleType);
                    if (error)
                        return "tupleType." + error;
                }
            }
            if (message.structType != null && message.hasOwnProperty("structType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.StructType.verify(message.structType);
                    if (error)
                        return "structType." + error;
                }
            }
            if (message.dictType != null && message.hasOwnProperty("dictType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.DictType.verify(message.dictType);
                    if (error)
                        return "dictType." + error;
                }
            }
            if (message.variantType != null && message.hasOwnProperty("variantType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.VariantType.verify(message.variantType);
                    if (error)
                        return "variantType." + error;
                }
            }
            if (message.voidType != null && message.hasOwnProperty("voidType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                switch (message.voidType) {
                default:
                    return "voidType: enum value expected";
                case 0:
                    break;
                }
            }
            return null;
        };

        /**
         * Creates a Type message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.Type
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.Type} Type
         */
        Type.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.Type)
                return object;
            var message = new $root.Ydb.Type();
            switch (object.typeId) {
            case "PRIMITIVE_TYPE_ID_UNSPECIFIED":
            case 0:
                message.typeId = 0;
                break;
            case "BOOL":
            case 6:
                message.typeId = 6;
                break;
            case "INT8":
            case 7:
                message.typeId = 7;
                break;
            case "UINT8":
            case 5:
                message.typeId = 5;
                break;
            case "INT16":
            case 8:
                message.typeId = 8;
                break;
            case "UINT16":
            case 9:
                message.typeId = 9;
                break;
            case "INT32":
            case 1:
                message.typeId = 1;
                break;
            case "UINT32":
            case 2:
                message.typeId = 2;
                break;
            case "INT64":
            case 3:
                message.typeId = 3;
                break;
            case "UINT64":
            case 4:
                message.typeId = 4;
                break;
            case "FLOAT":
            case 33:
                message.typeId = 33;
                break;
            case "DOUBLE":
            case 32:
                message.typeId = 32;
                break;
            case "DATE":
            case 48:
                message.typeId = 48;
                break;
            case "DATETIME":
            case 49:
                message.typeId = 49;
                break;
            case "TIMESTAMP":
            case 50:
                message.typeId = 50;
                break;
            case "INTERVAL":
            case 51:
                message.typeId = 51;
                break;
            case "TZ_DATE":
            case 52:
                message.typeId = 52;
                break;
            case "TZ_DATETIME":
            case 53:
                message.typeId = 53;
                break;
            case "TZ_TIMESTAMP":
            case 54:
                message.typeId = 54;
                break;
            case "STRING":
            case 4097:
                message.typeId = 4097;
                break;
            case "UTF8":
            case 4608:
                message.typeId = 4608;
                break;
            case "YSON":
            case 4609:
                message.typeId = 4609;
                break;
            case "JSON":
            case 4610:
                message.typeId = 4610;
                break;
            case "UUID":
            case 4611:
                message.typeId = 4611;
                break;
            }
            if (object.decimalType != null) {
                if (typeof object.decimalType !== "object")
                    throw TypeError(".Ydb.Type.decimalType: object expected");
                message.decimalType = $root.Ydb.DecimalType.fromObject(object.decimalType);
            }
            if (object.optionalType != null) {
                if (typeof object.optionalType !== "object")
                    throw TypeError(".Ydb.Type.optionalType: object expected");
                message.optionalType = $root.Ydb.OptionalType.fromObject(object.optionalType);
            }
            if (object.listType != null) {
                if (typeof object.listType !== "object")
                    throw TypeError(".Ydb.Type.listType: object expected");
                message.listType = $root.Ydb.ListType.fromObject(object.listType);
            }
            if (object.tupleType != null) {
                if (typeof object.tupleType !== "object")
                    throw TypeError(".Ydb.Type.tupleType: object expected");
                message.tupleType = $root.Ydb.TupleType.fromObject(object.tupleType);
            }
            if (object.structType != null) {
                if (typeof object.structType !== "object")
                    throw TypeError(".Ydb.Type.structType: object expected");
                message.structType = $root.Ydb.StructType.fromObject(object.structType);
            }
            if (object.dictType != null) {
                if (typeof object.dictType !== "object")
                    throw TypeError(".Ydb.Type.dictType: object expected");
                message.dictType = $root.Ydb.DictType.fromObject(object.dictType);
            }
            if (object.variantType != null) {
                if (typeof object.variantType !== "object")
                    throw TypeError(".Ydb.Type.variantType: object expected");
                message.variantType = $root.Ydb.VariantType.fromObject(object.variantType);
            }
            switch (object.voidType) {
            case "NULL_VALUE":
            case 0:
                message.voidType = 0;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Type message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.Type
         * @static
         * @param {Ydb.Type} message Type
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Type.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.typeId != null && message.hasOwnProperty("typeId")) {
                object.typeId = options.enums === String ? $root.Ydb.Type.PrimitiveTypeId[message.typeId] : message.typeId;
                if (options.oneofs)
                    object.type = "typeId";
            }
            if (message.decimalType != null && message.hasOwnProperty("decimalType")) {
                object.decimalType = $root.Ydb.DecimalType.toObject(message.decimalType, options);
                if (options.oneofs)
                    object.type = "decimalType";
            }
            if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
                object.optionalType = $root.Ydb.OptionalType.toObject(message.optionalType, options);
                if (options.oneofs)
                    object.type = "optionalType";
            }
            if (message.listType != null && message.hasOwnProperty("listType")) {
                object.listType = $root.Ydb.ListType.toObject(message.listType, options);
                if (options.oneofs)
                    object.type = "listType";
            }
            if (message.tupleType != null && message.hasOwnProperty("tupleType")) {
                object.tupleType = $root.Ydb.TupleType.toObject(message.tupleType, options);
                if (options.oneofs)
                    object.type = "tupleType";
            }
            if (message.structType != null && message.hasOwnProperty("structType")) {
                object.structType = $root.Ydb.StructType.toObject(message.structType, options);
                if (options.oneofs)
                    object.type = "structType";
            }
            if (message.dictType != null && message.hasOwnProperty("dictType")) {
                object.dictType = $root.Ydb.DictType.toObject(message.dictType, options);
                if (options.oneofs)
                    object.type = "dictType";
            }
            if (message.variantType != null && message.hasOwnProperty("variantType")) {
                object.variantType = $root.Ydb.VariantType.toObject(message.variantType, options);
                if (options.oneofs)
                    object.type = "variantType";
            }
            if (message.voidType != null && message.hasOwnProperty("voidType")) {
                object.voidType = options.enums === String ? $root.google.protobuf.NullValue[message.voidType] : message.voidType;
                if (options.oneofs)
                    object.type = "voidType";
            }
            return object;
        };

        /**
         * Converts this Type to JSON.
         * @function toJSON
         * @memberof Ydb.Type
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Type.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PrimitiveTypeId enum.
         * @name Ydb.Type.PrimitiveTypeId
         * @enum {string}
         * @property {number} PRIMITIVE_TYPE_ID_UNSPECIFIED=0 PRIMITIVE_TYPE_ID_UNSPECIFIED value
         * @property {number} BOOL=6 BOOL value
         * @property {number} INT8=7 INT8 value
         * @property {number} UINT8=5 UINT8 value
         * @property {number} INT16=8 INT16 value
         * @property {number} UINT16=9 UINT16 value
         * @property {number} INT32=1 INT32 value
         * @property {number} UINT32=2 UINT32 value
         * @property {number} INT64=3 INT64 value
         * @property {number} UINT64=4 UINT64 value
         * @property {number} FLOAT=33 FLOAT value
         * @property {number} DOUBLE=32 DOUBLE value
         * @property {number} DATE=48 DATE value
         * @property {number} DATETIME=49 DATETIME value
         * @property {number} TIMESTAMP=50 TIMESTAMP value
         * @property {number} INTERVAL=51 INTERVAL value
         * @property {number} TZ_DATE=52 TZ_DATE value
         * @property {number} TZ_DATETIME=53 TZ_DATETIME value
         * @property {number} TZ_TIMESTAMP=54 TZ_TIMESTAMP value
         * @property {number} STRING=4097 STRING value
         * @property {number} UTF8=4608 UTF8 value
         * @property {number} YSON=4609 YSON value
         * @property {number} JSON=4610 JSON value
         * @property {number} UUID=4611 UUID value
         */
        Type.PrimitiveTypeId = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PRIMITIVE_TYPE_ID_UNSPECIFIED"] = 0;
            values[valuesById[6] = "BOOL"] = 6;
            values[valuesById[7] = "INT8"] = 7;
            values[valuesById[5] = "UINT8"] = 5;
            values[valuesById[8] = "INT16"] = 8;
            values[valuesById[9] = "UINT16"] = 9;
            values[valuesById[1] = "INT32"] = 1;
            values[valuesById[2] = "UINT32"] = 2;
            values[valuesById[3] = "INT64"] = 3;
            values[valuesById[4] = "UINT64"] = 4;
            values[valuesById[33] = "FLOAT"] = 33;
            values[valuesById[32] = "DOUBLE"] = 32;
            values[valuesById[48] = "DATE"] = 48;
            values[valuesById[49] = "DATETIME"] = 49;
            values[valuesById[50] = "TIMESTAMP"] = 50;
            values[valuesById[51] = "INTERVAL"] = 51;
            values[valuesById[52] = "TZ_DATE"] = 52;
            values[valuesById[53] = "TZ_DATETIME"] = 53;
            values[valuesById[54] = "TZ_TIMESTAMP"] = 54;
            values[valuesById[4097] = "STRING"] = 4097;
            values[valuesById[4608] = "UTF8"] = 4608;
            values[valuesById[4609] = "YSON"] = 4609;
            values[valuesById[4610] = "JSON"] = 4610;
            values[valuesById[4611] = "UUID"] = 4611;
            return values;
        })();

        return Type;
    })();

    Ydb.ValuePair = (function() {

        /**
         * Properties of a ValuePair.
         * @memberof Ydb
         * @interface IValuePair
         * @property {Ydb.IValue|null} [key] ValuePair key
         * @property {Ydb.IValue|null} [payload] ValuePair payload
         */

        /**
         * Constructs a new ValuePair.
         * @memberof Ydb
         * @classdesc Represents a ValuePair.
         * @implements IValuePair
         * @constructor
         * @param {Ydb.IValuePair=} [properties] Properties to set
         */
        function ValuePair(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValuePair key.
         * @member {Ydb.IValue|null|undefined} key
         * @memberof Ydb.ValuePair
         * @instance
         */
        ValuePair.prototype.key = null;

        /**
         * ValuePair payload.
         * @member {Ydb.IValue|null|undefined} payload
         * @memberof Ydb.ValuePair
         * @instance
         */
        ValuePair.prototype.payload = null;

        /**
         * Creates a new ValuePair instance using the specified properties.
         * @function create
         * @memberof Ydb.ValuePair
         * @static
         * @param {Ydb.IValuePair=} [properties] Properties to set
         * @returns {Ydb.ValuePair} ValuePair instance
         */
        ValuePair.create = function create(properties) {
            return new ValuePair(properties);
        };

        /**
         * Encodes the specified ValuePair message. Does not implicitly {@link Ydb.ValuePair.verify|verify} messages.
         * @function encode
         * @memberof Ydb.ValuePair
         * @static
         * @param {Ydb.IValuePair} message ValuePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValuePair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                $root.Ydb.Value.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.payload != null && message.hasOwnProperty("payload"))
                $root.Ydb.Value.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ValuePair message, length delimited. Does not implicitly {@link Ydb.ValuePair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.ValuePair
         * @static
         * @param {Ydb.IValuePair} message ValuePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValuePair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValuePair message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.ValuePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.ValuePair} ValuePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValuePair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.ValuePair();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.Ydb.Value.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.payload = $root.Ydb.Value.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValuePair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.ValuePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.ValuePair} ValuePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValuePair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValuePair message.
         * @function verify
         * @memberof Ydb.ValuePair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValuePair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.Ydb.Value.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.Ydb.Value.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates a ValuePair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.ValuePair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.ValuePair} ValuePair
         */
        ValuePair.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.ValuePair)
                return object;
            var message = new $root.Ydb.ValuePair();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".Ydb.ValuePair.key: object expected");
                message.key = $root.Ydb.Value.fromObject(object.key);
            }
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".Ydb.ValuePair.payload: object expected");
                message.payload = $root.Ydb.Value.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from a ValuePair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.ValuePair
         * @static
         * @param {Ydb.ValuePair} message ValuePair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValuePair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.payload = null;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.Ydb.Value.toObject(message.key, options);
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.Ydb.Value.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this ValuePair to JSON.
         * @function toJSON
         * @memberof Ydb.ValuePair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValuePair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValuePair;
    })();

    Ydb.Value = (function() {

        /**
         * Properties of a Value.
         * @memberof Ydb
         * @interface IValue
         * @property {boolean|null} [boolValue] Value boolValue
         * @property {number|null} [int32Value] Value int32Value
         * @property {number|null} [uint32Value] Value uint32Value
         * @property {number|Long|null} [int64Value] Value int64Value
         * @property {number|Long|null} [uint64Value] Value uint64Value
         * @property {number|null} [floatValue] Value floatValue
         * @property {number|null} [doubleValue] Value doubleValue
         * @property {Uint8Array|null} [bytesValue] Value bytesValue
         * @property {string|null} [textValue] Value textValue
         * @property {google.protobuf.NullValue|null} [nullFlagValue] Value nullFlagValue
         * @property {Ydb.IValue|null} [nestedValue] Value nestedValue
         * @property {number|Long|null} [low_128] Value low_128
         * @property {Array.<Ydb.IValue>|null} [items] Value items
         * @property {Array.<Ydb.IValuePair>|null} [pairs] Value pairs
         * @property {number|null} [variantIndex] Value variantIndex
         * @property {number|Long|null} [high_128] Value high_128
         */

        /**
         * Constructs a new Value.
         * @memberof Ydb
         * @classdesc Represents a Value.
         * @implements IValue
         * @constructor
         * @param {Ydb.IValue=} [properties] Properties to set
         */
        function Value(properties) {
            this.items = [];
            this.pairs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Value boolValue.
         * @member {boolean} boolValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.boolValue = false;

        /**
         * Value int32Value.
         * @member {number} int32Value
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.int32Value = 0;

        /**
         * Value uint32Value.
         * @member {number} uint32Value
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.uint32Value = 0;

        /**
         * Value int64Value.
         * @member {number|Long} int64Value
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.int64Value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Value uint64Value.
         * @member {number|Long} uint64Value
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.uint64Value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Value floatValue.
         * @member {number} floatValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.floatValue = 0;

        /**
         * Value doubleValue.
         * @member {number} doubleValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.doubleValue = 0;

        /**
         * Value bytesValue.
         * @member {Uint8Array} bytesValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.bytesValue = $util.newBuffer([]);

        /**
         * Value textValue.
         * @member {string} textValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.textValue = "";

        /**
         * Value nullFlagValue.
         * @member {google.protobuf.NullValue} nullFlagValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.nullFlagValue = 0;

        /**
         * Value nestedValue.
         * @member {Ydb.IValue|null|undefined} nestedValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.nestedValue = null;

        /**
         * Value low_128.
         * @member {number|Long} low_128
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.low_128 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Value items.
         * @member {Array.<Ydb.IValue>} items
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.items = $util.emptyArray;

        /**
         * Value pairs.
         * @member {Array.<Ydb.IValuePair>} pairs
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.pairs = $util.emptyArray;

        /**
         * Value variantIndex.
         * @member {number} variantIndex
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.variantIndex = 0;

        /**
         * Value high_128.
         * @member {number|Long} high_128
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.high_128 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Value value.
         * @member {"boolValue"|"int32Value"|"uint32Value"|"int64Value"|"uint64Value"|"floatValue"|"doubleValue"|"bytesValue"|"textValue"|"nullFlagValue"|"nestedValue"|"low_128"|undefined} value
         * @memberof Ydb.Value
         * @instance
         */
        Object.defineProperty(Value.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["boolValue", "int32Value", "uint32Value", "int64Value", "uint64Value", "floatValue", "doubleValue", "bytesValue", "textValue", "nullFlagValue", "nestedValue", "low_128"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Value instance using the specified properties.
         * @function create
         * @memberof Ydb.Value
         * @static
         * @param {Ydb.IValue=} [properties] Properties to set
         * @returns {Ydb.Value} Value instance
         */
        Value.create = function create(properties) {
            return new Value(properties);
        };

        /**
         * Encodes the specified Value message. Does not implicitly {@link Ydb.Value.verify|verify} messages.
         * @function encode
         * @memberof Ydb.Value
         * @static
         * @param {Ydb.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.boolValue != null && message.hasOwnProperty("boolValue"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.boolValue);
            if (message.int32Value != null && message.hasOwnProperty("int32Value"))
                writer.uint32(/* id 2, wireType 5 =*/21).sfixed32(message.int32Value);
            if (message.uint32Value != null && message.hasOwnProperty("uint32Value"))
                writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.uint32Value);
            if (message.int64Value != null && message.hasOwnProperty("int64Value"))
                writer.uint32(/* id 4, wireType 1 =*/33).sfixed64(message.int64Value);
            if (message.uint64Value != null && message.hasOwnProperty("uint64Value"))
                writer.uint32(/* id 5, wireType 1 =*/41).fixed64(message.uint64Value);
            if (message.floatValue != null && message.hasOwnProperty("floatValue"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.floatValue);
            if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.doubleValue);
            if (message.bytesValue != null && message.hasOwnProperty("bytesValue"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.bytesValue);
            if (message.textValue != null && message.hasOwnProperty("textValue"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.textValue);
            if (message.nullFlagValue != null && message.hasOwnProperty("nullFlagValue"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.nullFlagValue);
            if (message.nestedValue != null && message.hasOwnProperty("nestedValue"))
                $root.Ydb.Value.encode(message.nestedValue, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.Ydb.Value.encode(message.items[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.pairs != null && message.pairs.length)
                for (var i = 0; i < message.pairs.length; ++i)
                    $root.Ydb.ValuePair.encode(message.pairs[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.variantIndex != null && message.hasOwnProperty("variantIndex"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.variantIndex);
            if (message.low_128 != null && message.hasOwnProperty("low_128"))
                writer.uint32(/* id 15, wireType 1 =*/121).fixed64(message.low_128);
            if (message.high_128 != null && message.hasOwnProperty("high_128"))
                writer.uint32(/* id 16, wireType 1 =*/129).fixed64(message.high_128);
            return writer;
        };

        /**
         * Encodes the specified Value message, length delimited. Does not implicitly {@link Ydb.Value.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.Value
         * @static
         * @param {Ydb.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Value message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Value();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.boolValue = reader.bool();
                    break;
                case 2:
                    message.int32Value = reader.sfixed32();
                    break;
                case 3:
                    message.uint32Value = reader.fixed32();
                    break;
                case 4:
                    message.int64Value = reader.sfixed64();
                    break;
                case 5:
                    message.uint64Value = reader.fixed64();
                    break;
                case 6:
                    message.floatValue = reader.float();
                    break;
                case 7:
                    message.doubleValue = reader.double();
                    break;
                case 8:
                    message.bytesValue = reader.bytes();
                    break;
                case 9:
                    message.textValue = reader.string();
                    break;
                case 10:
                    message.nullFlagValue = reader.int32();
                    break;
                case 11:
                    message.nestedValue = $root.Ydb.Value.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.low_128 = reader.fixed64();
                    break;
                case 12:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.Ydb.Value.decode(reader, reader.uint32()));
                    break;
                case 13:
                    if (!(message.pairs && message.pairs.length))
                        message.pairs = [];
                    message.pairs.push($root.Ydb.ValuePair.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.variantIndex = reader.uint32();
                    break;
                case 16:
                    message.high_128 = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Value message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Value message.
         * @function verify
         * @memberof Ydb.Value
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Value.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                properties.value = 1;
                if (typeof message.boolValue !== "boolean")
                    return "boolValue: boolean expected";
            }
            if (message.int32Value != null && message.hasOwnProperty("int32Value")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.int32Value))
                    return "int32Value: integer expected";
            }
            if (message.uint32Value != null && message.hasOwnProperty("uint32Value")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.uint32Value))
                    return "uint32Value: integer expected";
            }
            if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.int64Value) && !(message.int64Value && $util.isInteger(message.int64Value.low) && $util.isInteger(message.int64Value.high)))
                    return "int64Value: integer|Long expected";
            }
            if (message.uint64Value != null && message.hasOwnProperty("uint64Value")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.uint64Value) && !(message.uint64Value && $util.isInteger(message.uint64Value.low) && $util.isInteger(message.uint64Value.high)))
                    return "uint64Value: integer|Long expected";
            }
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (typeof message.floatValue !== "number")
                    return "floatValue: number expected";
            }
            if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (typeof message.doubleValue !== "number")
                    return "doubleValue: number expected";
            }
            if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
                    return "bytesValue: buffer expected";
            }
            if (message.textValue != null && message.hasOwnProperty("textValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.textValue))
                    return "textValue: string expected";
            }
            if (message.nullFlagValue != null && message.hasOwnProperty("nullFlagValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                switch (message.nullFlagValue) {
                default:
                    return "nullFlagValue: enum value expected";
                case 0:
                    break;
                }
            }
            if (message.nestedValue != null && message.hasOwnProperty("nestedValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.Ydb.Value.verify(message.nestedValue);
                    if (error)
                        return "nestedValue." + error;
                }
            }
            if (message.low_128 != null && message.hasOwnProperty("low_128")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.low_128) && !(message.low_128 && $util.isInteger(message.low_128.low) && $util.isInteger(message.low_128.high)))
                    return "low_128: integer|Long expected";
            }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.Ydb.Value.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.pairs != null && message.hasOwnProperty("pairs")) {
                if (!Array.isArray(message.pairs))
                    return "pairs: array expected";
                for (var i = 0; i < message.pairs.length; ++i) {
                    var error = $root.Ydb.ValuePair.verify(message.pairs[i]);
                    if (error)
                        return "pairs." + error;
                }
            }
            if (message.variantIndex != null && message.hasOwnProperty("variantIndex"))
                if (!$util.isInteger(message.variantIndex))
                    return "variantIndex: integer expected";
            if (message.high_128 != null && message.hasOwnProperty("high_128"))
                if (!$util.isInteger(message.high_128) && !(message.high_128 && $util.isInteger(message.high_128.low) && $util.isInteger(message.high_128.high)))
                    return "high_128: integer|Long expected";
            return null;
        };

        /**
         * Creates a Value message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.Value
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.Value} Value
         */
        Value.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.Value)
                return object;
            var message = new $root.Ydb.Value();
            if (object.boolValue != null)
                message.boolValue = Boolean(object.boolValue);
            if (object.int32Value != null)
                message.int32Value = object.int32Value | 0;
            if (object.uint32Value != null)
                message.uint32Value = object.uint32Value >>> 0;
            if (object.int64Value != null)
                if ($util.Long)
                    (message.int64Value = $util.Long.fromValue(object.int64Value)).unsigned = false;
                else if (typeof object.int64Value === "string")
                    message.int64Value = parseInt(object.int64Value, 10);
                else if (typeof object.int64Value === "number")
                    message.int64Value = object.int64Value;
                else if (typeof object.int64Value === "object")
                    message.int64Value = new $util.LongBits(object.int64Value.low >>> 0, object.int64Value.high >>> 0).toNumber();
            if (object.uint64Value != null)
                if ($util.Long)
                    (message.uint64Value = $util.Long.fromValue(object.uint64Value)).unsigned = false;
                else if (typeof object.uint64Value === "string")
                    message.uint64Value = parseInt(object.uint64Value, 10);
                else if (typeof object.uint64Value === "number")
                    message.uint64Value = object.uint64Value;
                else if (typeof object.uint64Value === "object")
                    message.uint64Value = new $util.LongBits(object.uint64Value.low >>> 0, object.uint64Value.high >>> 0).toNumber();
            if (object.floatValue != null)
                message.floatValue = Number(object.floatValue);
            if (object.doubleValue != null)
                message.doubleValue = Number(object.doubleValue);
            if (object.bytesValue != null)
                if (typeof object.bytesValue === "string")
                    $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
                else if (object.bytesValue.length)
                    message.bytesValue = object.bytesValue;
            if (object.textValue != null)
                message.textValue = String(object.textValue);
            switch (object.nullFlagValue) {
            case "NULL_VALUE":
            case 0:
                message.nullFlagValue = 0;
                break;
            }
            if (object.nestedValue != null) {
                if (typeof object.nestedValue !== "object")
                    throw TypeError(".Ydb.Value.nestedValue: object expected");
                message.nestedValue = $root.Ydb.Value.fromObject(object.nestedValue);
            }
            if (object.low_128 != null)
                if ($util.Long)
                    (message.low_128 = $util.Long.fromValue(object.low_128)).unsigned = false;
                else if (typeof object.low_128 === "string")
                    message.low_128 = parseInt(object.low_128, 10);
                else if (typeof object.low_128 === "number")
                    message.low_128 = object.low_128;
                else if (typeof object.low_128 === "object")
                    message.low_128 = new $util.LongBits(object.low_128.low >>> 0, object.low_128.high >>> 0).toNumber();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".Ydb.Value.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".Ydb.Value.items: object expected");
                    message.items[i] = $root.Ydb.Value.fromObject(object.items[i]);
                }
            }
            if (object.pairs) {
                if (!Array.isArray(object.pairs))
                    throw TypeError(".Ydb.Value.pairs: array expected");
                message.pairs = [];
                for (var i = 0; i < object.pairs.length; ++i) {
                    if (typeof object.pairs[i] !== "object")
                        throw TypeError(".Ydb.Value.pairs: object expected");
                    message.pairs[i] = $root.Ydb.ValuePair.fromObject(object.pairs[i]);
                }
            }
            if (object.variantIndex != null)
                message.variantIndex = object.variantIndex >>> 0;
            if (object.high_128 != null)
                if ($util.Long)
                    (message.high_128 = $util.Long.fromValue(object.high_128)).unsigned = false;
                else if (typeof object.high_128 === "string")
                    message.high_128 = parseInt(object.high_128, 10);
                else if (typeof object.high_128 === "number")
                    message.high_128 = object.high_128;
                else if (typeof object.high_128 === "object")
                    message.high_128 = new $util.LongBits(object.high_128.low >>> 0, object.high_128.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Value message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.Value
         * @static
         * @param {Ydb.Value} message Value
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Value.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.items = [];
                object.pairs = [];
            }
            if (options.defaults) {
                object.variantIndex = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.high_128 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.high_128 = options.longs === String ? "0" : 0;
            }
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                object.boolValue = message.boolValue;
                if (options.oneofs)
                    object.value = "boolValue";
            }
            if (message.int32Value != null && message.hasOwnProperty("int32Value")) {
                object.int32Value = message.int32Value;
                if (options.oneofs)
                    object.value = "int32Value";
            }
            if (message.uint32Value != null && message.hasOwnProperty("uint32Value")) {
                object.uint32Value = message.uint32Value;
                if (options.oneofs)
                    object.value = "uint32Value";
            }
            if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                if (typeof message.int64Value === "number")
                    object.int64Value = options.longs === String ? String(message.int64Value) : message.int64Value;
                else
                    object.int64Value = options.longs === String ? $util.Long.prototype.toString.call(message.int64Value) : options.longs === Number ? new $util.LongBits(message.int64Value.low >>> 0, message.int64Value.high >>> 0).toNumber() : message.int64Value;
                if (options.oneofs)
                    object.value = "int64Value";
            }
            if (message.uint64Value != null && message.hasOwnProperty("uint64Value")) {
                if (typeof message.uint64Value === "number")
                    object.uint64Value = options.longs === String ? String(message.uint64Value) : message.uint64Value;
                else
                    object.uint64Value = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Value) : options.longs === Number ? new $util.LongBits(message.uint64Value.low >>> 0, message.uint64Value.high >>> 0).toNumber() : message.uint64Value;
                if (options.oneofs)
                    object.value = "uint64Value";
            }
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;
                if (options.oneofs)
                    object.value = "floatValue";
            }
            if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (options.oneofs)
                    object.value = "doubleValue";
            }
            if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
                if (options.oneofs)
                    object.value = "bytesValue";
            }
            if (message.textValue != null && message.hasOwnProperty("textValue")) {
                object.textValue = message.textValue;
                if (options.oneofs)
                    object.value = "textValue";
            }
            if (message.nullFlagValue != null && message.hasOwnProperty("nullFlagValue")) {
                object.nullFlagValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullFlagValue] : message.nullFlagValue;
                if (options.oneofs)
                    object.value = "nullFlagValue";
            }
            if (message.nestedValue != null && message.hasOwnProperty("nestedValue")) {
                object.nestedValue = $root.Ydb.Value.toObject(message.nestedValue, options);
                if (options.oneofs)
                    object.value = "nestedValue";
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.Ydb.Value.toObject(message.items[j], options);
            }
            if (message.pairs && message.pairs.length) {
                object.pairs = [];
                for (var j = 0; j < message.pairs.length; ++j)
                    object.pairs[j] = $root.Ydb.ValuePair.toObject(message.pairs[j], options);
            }
            if (message.variantIndex != null && message.hasOwnProperty("variantIndex"))
                object.variantIndex = message.variantIndex;
            if (message.low_128 != null && message.hasOwnProperty("low_128")) {
                if (typeof message.low_128 === "number")
                    object.low_128 = options.longs === String ? String(message.low_128) : message.low_128;
                else
                    object.low_128 = options.longs === String ? $util.Long.prototype.toString.call(message.low_128) : options.longs === Number ? new $util.LongBits(message.low_128.low >>> 0, message.low_128.high >>> 0).toNumber() : message.low_128;
                if (options.oneofs)
                    object.value = "low_128";
            }
            if (message.high_128 != null && message.hasOwnProperty("high_128"))
                if (typeof message.high_128 === "number")
                    object.high_128 = options.longs === String ? String(message.high_128) : message.high_128;
                else
                    object.high_128 = options.longs === String ? $util.Long.prototype.toString.call(message.high_128) : options.longs === Number ? new $util.LongBits(message.high_128.low >>> 0, message.high_128.high >>> 0).toNumber() : message.high_128;
            return object;
        };

        /**
         * Converts this Value to JSON.
         * @function toJSON
         * @memberof Ydb.Value
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Value.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Value;
    })();

    Ydb.TypedValue = (function() {

        /**
         * Properties of a TypedValue.
         * @memberof Ydb
         * @interface ITypedValue
         * @property {Ydb.IType|null} [type] TypedValue type
         * @property {Ydb.IValue|null} [value] TypedValue value
         */

        /**
         * Constructs a new TypedValue.
         * @memberof Ydb
         * @classdesc Represents a TypedValue.
         * @implements ITypedValue
         * @constructor
         * @param {Ydb.ITypedValue=} [properties] Properties to set
         */
        function TypedValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TypedValue type.
         * @member {Ydb.IType|null|undefined} type
         * @memberof Ydb.TypedValue
         * @instance
         */
        TypedValue.prototype.type = null;

        /**
         * TypedValue value.
         * @member {Ydb.IValue|null|undefined} value
         * @memberof Ydb.TypedValue
         * @instance
         */
        TypedValue.prototype.value = null;

        /**
         * Creates a new TypedValue instance using the specified properties.
         * @function create
         * @memberof Ydb.TypedValue
         * @static
         * @param {Ydb.ITypedValue=} [properties] Properties to set
         * @returns {Ydb.TypedValue} TypedValue instance
         */
        TypedValue.create = function create(properties) {
            return new TypedValue(properties);
        };

        /**
         * Encodes the specified TypedValue message. Does not implicitly {@link Ydb.TypedValue.verify|verify} messages.
         * @function encode
         * @memberof Ydb.TypedValue
         * @static
         * @param {Ydb.ITypedValue} message TypedValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypedValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                $root.Ydb.Type.encode(message.type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.value != null && message.hasOwnProperty("value"))
                $root.Ydb.Value.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TypedValue message, length delimited. Does not implicitly {@link Ydb.TypedValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.TypedValue
         * @static
         * @param {Ydb.ITypedValue} message TypedValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypedValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TypedValue message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.TypedValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.TypedValue} TypedValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypedValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TypedValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.value = $root.Ydb.Value.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TypedValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.TypedValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.TypedValue} TypedValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypedValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TypedValue message.
         * @function verify
         * @memberof Ydb.TypedValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TypedValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.Ydb.Type.verify(message.type);
                if (error)
                    return "type." + error;
            }
            if (message.value != null && message.hasOwnProperty("value")) {
                var error = $root.Ydb.Value.verify(message.value);
                if (error)
                    return "value." + error;
            }
            return null;
        };

        /**
         * Creates a TypedValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.TypedValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.TypedValue} TypedValue
         */
        TypedValue.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.TypedValue)
                return object;
            var message = new $root.Ydb.TypedValue();
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".Ydb.TypedValue.type: object expected");
                message.type = $root.Ydb.Type.fromObject(object.type);
            }
            if (object.value != null) {
                if (typeof object.value !== "object")
                    throw TypeError(".Ydb.TypedValue.value: object expected");
                message.value = $root.Ydb.Value.fromObject(object.value);
            }
            return message;
        };

        /**
         * Creates a plain object from a TypedValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.TypedValue
         * @static
         * @param {Ydb.TypedValue} message TypedValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TypedValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = null;
                object.value = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.Ydb.Type.toObject(message.type, options);
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = $root.Ydb.Value.toObject(message.value, options);
            return object;
        };

        /**
         * Converts this TypedValue to JSON.
         * @function toJSON
         * @memberof Ydb.TypedValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TypedValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TypedValue;
    })();

    Ydb.Column = (function() {

        /**
         * Properties of a Column.
         * @memberof Ydb
         * @interface IColumn
         * @property {string|null} [name] Column name
         * @property {Ydb.IType|null} [type] Column type
         */

        /**
         * Constructs a new Column.
         * @memberof Ydb
         * @classdesc Represents a Column.
         * @implements IColumn
         * @constructor
         * @param {Ydb.IColumn=} [properties] Properties to set
         */
        function Column(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Column name.
         * @member {string} name
         * @memberof Ydb.Column
         * @instance
         */
        Column.prototype.name = "";

        /**
         * Column type.
         * @member {Ydb.IType|null|undefined} type
         * @memberof Ydb.Column
         * @instance
         */
        Column.prototype.type = null;

        /**
         * Creates a new Column instance using the specified properties.
         * @function create
         * @memberof Ydb.Column
         * @static
         * @param {Ydb.IColumn=} [properties] Properties to set
         * @returns {Ydb.Column} Column instance
         */
        Column.create = function create(properties) {
            return new Column(properties);
        };

        /**
         * Encodes the specified Column message. Does not implicitly {@link Ydb.Column.verify|verify} messages.
         * @function encode
         * @memberof Ydb.Column
         * @static
         * @param {Ydb.IColumn} message Column message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Column.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && message.hasOwnProperty("type"))
                $root.Ydb.Type.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Column message, length delimited. Does not implicitly {@link Ydb.Column.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.Column
         * @static
         * @param {Ydb.IColumn} message Column message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Column.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Column message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.Column
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.Column} Column
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Column.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Column();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Column message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.Column
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.Column} Column
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Column.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Column message.
         * @function verify
         * @memberof Ydb.Column
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Column.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.Ydb.Type.verify(message.type);
                if (error)
                    return "type." + error;
            }
            return null;
        };

        /**
         * Creates a Column message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.Column
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.Column} Column
         */
        Column.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.Column)
                return object;
            var message = new $root.Ydb.Column();
            if (object.name != null)
                message.name = String(object.name);
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".Ydb.Column.type: object expected");
                message.type = $root.Ydb.Type.fromObject(object.type);
            }
            return message;
        };

        /**
         * Creates a plain object from a Column message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.Column
         * @static
         * @param {Ydb.Column} message Column
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Column.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.Ydb.Type.toObject(message.type, options);
            return object;
        };

        /**
         * Converts this Column to JSON.
         * @function toJSON
         * @memberof Ydb.Column
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Column.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Column;
    })();

    Ydb.ResultSet = (function() {

        /**
         * Properties of a ResultSet.
         * @memberof Ydb
         * @interface IResultSet
         * @property {Array.<Ydb.IColumn>|null} [columns] ResultSet columns
         * @property {Array.<Ydb.IValue>|null} [rows] ResultSet rows
         * @property {boolean|null} [truncated] ResultSet truncated
         */

        /**
         * Constructs a new ResultSet.
         * @memberof Ydb
         * @classdesc Represents a ResultSet.
         * @implements IResultSet
         * @constructor
         * @param {Ydb.IResultSet=} [properties] Properties to set
         */
        function ResultSet(properties) {
            this.columns = [];
            this.rows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResultSet columns.
         * @member {Array.<Ydb.IColumn>} columns
         * @memberof Ydb.ResultSet
         * @instance
         */
        ResultSet.prototype.columns = $util.emptyArray;

        /**
         * ResultSet rows.
         * @member {Array.<Ydb.IValue>} rows
         * @memberof Ydb.ResultSet
         * @instance
         */
        ResultSet.prototype.rows = $util.emptyArray;

        /**
         * ResultSet truncated.
         * @member {boolean} truncated
         * @memberof Ydb.ResultSet
         * @instance
         */
        ResultSet.prototype.truncated = false;

        /**
         * Creates a new ResultSet instance using the specified properties.
         * @function create
         * @memberof Ydb.ResultSet
         * @static
         * @param {Ydb.IResultSet=} [properties] Properties to set
         * @returns {Ydb.ResultSet} ResultSet instance
         */
        ResultSet.create = function create(properties) {
            return new ResultSet(properties);
        };

        /**
         * Encodes the specified ResultSet message. Does not implicitly {@link Ydb.ResultSet.verify|verify} messages.
         * @function encode
         * @memberof Ydb.ResultSet
         * @static
         * @param {Ydb.IResultSet} message ResultSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.columns != null && message.columns.length)
                for (var i = 0; i < message.columns.length; ++i)
                    $root.Ydb.Column.encode(message.columns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rows != null && message.rows.length)
                for (var i = 0; i < message.rows.length; ++i)
                    $root.Ydb.Value.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.truncated != null && message.hasOwnProperty("truncated"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.truncated);
            return writer;
        };

        /**
         * Encodes the specified ResultSet message, length delimited. Does not implicitly {@link Ydb.ResultSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.ResultSet
         * @static
         * @param {Ydb.IResultSet} message ResultSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultSet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResultSet message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.ResultSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.ResultSet} ResultSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.ResultSet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.columns && message.columns.length))
                        message.columns = [];
                    message.columns.push($root.Ydb.Column.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.rows && message.rows.length))
                        message.rows = [];
                    message.rows.push($root.Ydb.Value.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.truncated = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResultSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.ResultSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.ResultSet} ResultSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResultSet message.
         * @function verify
         * @memberof Ydb.ResultSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResultSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.columns != null && message.hasOwnProperty("columns")) {
                if (!Array.isArray(message.columns))
                    return "columns: array expected";
                for (var i = 0; i < message.columns.length; ++i) {
                    var error = $root.Ydb.Column.verify(message.columns[i]);
                    if (error)
                        return "columns." + error;
                }
            }
            if (message.rows != null && message.hasOwnProperty("rows")) {
                if (!Array.isArray(message.rows))
                    return "rows: array expected";
                for (var i = 0; i < message.rows.length; ++i) {
                    var error = $root.Ydb.Value.verify(message.rows[i]);
                    if (error)
                        return "rows." + error;
                }
            }
            if (message.truncated != null && message.hasOwnProperty("truncated"))
                if (typeof message.truncated !== "boolean")
                    return "truncated: boolean expected";
            return null;
        };

        /**
         * Creates a ResultSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.ResultSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.ResultSet} ResultSet
         */
        ResultSet.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.ResultSet)
                return object;
            var message = new $root.Ydb.ResultSet();
            if (object.columns) {
                if (!Array.isArray(object.columns))
                    throw TypeError(".Ydb.ResultSet.columns: array expected");
                message.columns = [];
                for (var i = 0; i < object.columns.length; ++i) {
                    if (typeof object.columns[i] !== "object")
                        throw TypeError(".Ydb.ResultSet.columns: object expected");
                    message.columns[i] = $root.Ydb.Column.fromObject(object.columns[i]);
                }
            }
            if (object.rows) {
                if (!Array.isArray(object.rows))
                    throw TypeError(".Ydb.ResultSet.rows: array expected");
                message.rows = [];
                for (var i = 0; i < object.rows.length; ++i) {
                    if (typeof object.rows[i] !== "object")
                        throw TypeError(".Ydb.ResultSet.rows: object expected");
                    message.rows[i] = $root.Ydb.Value.fromObject(object.rows[i]);
                }
            }
            if (object.truncated != null)
                message.truncated = Boolean(object.truncated);
            return message;
        };

        /**
         * Creates a plain object from a ResultSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.ResultSet
         * @static
         * @param {Ydb.ResultSet} message ResultSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResultSet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.columns = [];
                object.rows = [];
            }
            if (options.defaults)
                object.truncated = false;
            if (message.columns && message.columns.length) {
                object.columns = [];
                for (var j = 0; j < message.columns.length; ++j)
                    object.columns[j] = $root.Ydb.Column.toObject(message.columns[j], options);
            }
            if (message.rows && message.rows.length) {
                object.rows = [];
                for (var j = 0; j < message.rows.length; ++j)
                    object.rows[j] = $root.Ydb.Value.toObject(message.rows[j], options);
            }
            if (message.truncated != null && message.hasOwnProperty("truncated"))
                object.truncated = message.truncated;
            return object;
        };

        /**
         * Converts this ResultSet to JSON.
         * @function toJSON
         * @memberof Ydb.ResultSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResultSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResultSet;
    })();

    Ydb.Table = (function() {

        /**
         * Namespace Table.
         * @memberof Ydb
         * @namespace
         */
        var Table = {};

        Table.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Table
             * @namespace
             */
            var V1 = {};

            V1.TableService = (function() {

                /**
                 * Constructs a new TableService service.
                 * @memberof Ydb.Table.V1
                 * @classdesc Represents a TableService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function TableService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (TableService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TableService;

                /**
                 * Creates new TableService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Table.V1.TableService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {TableService} RPC service. Useful where requests and/or responses are streamed.
                 */
                TableService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#createSession}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CreateSessionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CreateSessionResponse} [response] CreateSessionResponse
                 */

                /**
                 * Calls CreateSession.
                 * @function createSession
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICreateSessionRequest} request CreateSessionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CreateSessionCallback} callback Node-style callback called with the error, if any, and CreateSessionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.createSession = function createSession(request, callback) {
                    return this.rpcCall(createSession, $root.Ydb.Table.CreateSessionRequest, $root.Ydb.Table.CreateSessionResponse, request, callback);
                }, "name", { value: "CreateSession" });

                /**
                 * Calls CreateSession.
                 * @function createSession
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICreateSessionRequest} request CreateSessionRequest message or plain object
                 * @returns {Promise<Ydb.Table.CreateSessionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#deleteSession}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef DeleteSessionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.DeleteSessionResponse} [response] DeleteSessionResponse
                 */

                /**
                 * Calls DeleteSession.
                 * @function deleteSession
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDeleteSessionRequest} request DeleteSessionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.DeleteSessionCallback} callback Node-style callback called with the error, if any, and DeleteSessionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.deleteSession = function deleteSession(request, callback) {
                    return this.rpcCall(deleteSession, $root.Ydb.Table.DeleteSessionRequest, $root.Ydb.Table.DeleteSessionResponse, request, callback);
                }, "name", { value: "DeleteSession" });

                /**
                 * Calls DeleteSession.
                 * @function deleteSession
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDeleteSessionRequest} request DeleteSessionRequest message or plain object
                 * @returns {Promise<Ydb.Table.DeleteSessionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#keepAlive}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef KeepAliveCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.KeepAliveResponse} [response] KeepAliveResponse
                 */

                /**
                 * Calls KeepAlive.
                 * @function keepAlive
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IKeepAliveRequest} request KeepAliveRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.KeepAliveCallback} callback Node-style callback called with the error, if any, and KeepAliveResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.keepAlive = function keepAlive(request, callback) {
                    return this.rpcCall(keepAlive, $root.Ydb.Table.KeepAliveRequest, $root.Ydb.Table.KeepAliveResponse, request, callback);
                }, "name", { value: "KeepAlive" });

                /**
                 * Calls KeepAlive.
                 * @function keepAlive
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IKeepAliveRequest} request KeepAliveRequest message or plain object
                 * @returns {Promise<Ydb.Table.KeepAliveResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#createTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CreateTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CreateTableResponse} [response] CreateTableResponse
                 */

                /**
                 * Calls CreateTable.
                 * @function createTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICreateTableRequest} request CreateTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CreateTableCallback} callback Node-style callback called with the error, if any, and CreateTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.createTable = function createTable(request, callback) {
                    return this.rpcCall(createTable, $root.Ydb.Table.CreateTableRequest, $root.Ydb.Table.CreateTableResponse, request, callback);
                }, "name", { value: "CreateTable" });

                /**
                 * Calls CreateTable.
                 * @function createTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICreateTableRequest} request CreateTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.CreateTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#dropTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef DropTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.DropTableResponse} [response] DropTableResponse
                 */

                /**
                 * Calls DropTable.
                 * @function dropTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDropTableRequest} request DropTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.DropTableCallback} callback Node-style callback called with the error, if any, and DropTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.dropTable = function dropTable(request, callback) {
                    return this.rpcCall(dropTable, $root.Ydb.Table.DropTableRequest, $root.Ydb.Table.DropTableResponse, request, callback);
                }, "name", { value: "DropTable" });

                /**
                 * Calls DropTable.
                 * @function dropTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDropTableRequest} request DropTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.DropTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#alterTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef AlterTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.AlterTableResponse} [response] AlterTableResponse
                 */

                /**
                 * Calls AlterTable.
                 * @function alterTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IAlterTableRequest} request AlterTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.AlterTableCallback} callback Node-style callback called with the error, if any, and AlterTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.alterTable = function alterTable(request, callback) {
                    return this.rpcCall(alterTable, $root.Ydb.Table.AlterTableRequest, $root.Ydb.Table.AlterTableResponse, request, callback);
                }, "name", { value: "AlterTable" });

                /**
                 * Calls AlterTable.
                 * @function alterTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IAlterTableRequest} request AlterTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.AlterTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#copyTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CopyTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CopyTableResponse} [response] CopyTableResponse
                 */

                /**
                 * Calls CopyTable.
                 * @function copyTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICopyTableRequest} request CopyTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CopyTableCallback} callback Node-style callback called with the error, if any, and CopyTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.copyTable = function copyTable(request, callback) {
                    return this.rpcCall(copyTable, $root.Ydb.Table.CopyTableRequest, $root.Ydb.Table.CopyTableResponse, request, callback);
                }, "name", { value: "CopyTable" });

                /**
                 * Calls CopyTable.
                 * @function copyTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICopyTableRequest} request CopyTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.CopyTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#copyTables}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CopyTablesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CopyTablesResponse} [response] CopyTablesResponse
                 */

                /**
                 * Calls CopyTables.
                 * @function copyTables
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICopyTablesRequest} request CopyTablesRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CopyTablesCallback} callback Node-style callback called with the error, if any, and CopyTablesResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.copyTables = function copyTables(request, callback) {
                    return this.rpcCall(copyTables, $root.Ydb.Table.CopyTablesRequest, $root.Ydb.Table.CopyTablesResponse, request, callback);
                }, "name", { value: "CopyTables" });

                /**
                 * Calls CopyTables.
                 * @function copyTables
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICopyTablesRequest} request CopyTablesRequest message or plain object
                 * @returns {Promise<Ydb.Table.CopyTablesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#describeTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef DescribeTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.DescribeTableResponse} [response] DescribeTableResponse
                 */

                /**
                 * Calls DescribeTable.
                 * @function describeTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDescribeTableRequest} request DescribeTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.DescribeTableCallback} callback Node-style callback called with the error, if any, and DescribeTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.describeTable = function describeTable(request, callback) {
                    return this.rpcCall(describeTable, $root.Ydb.Table.DescribeTableRequest, $root.Ydb.Table.DescribeTableResponse, request, callback);
                }, "name", { value: "DescribeTable" });

                /**
                 * Calls DescribeTable.
                 * @function describeTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDescribeTableRequest} request DescribeTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.DescribeTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#explainDataQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef ExplainDataQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ExplainDataQueryResponse} [response] ExplainDataQueryResponse
                 */

                /**
                 * Calls ExplainDataQuery.
                 * @function explainDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExplainDataQueryRequest} request ExplainDataQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.ExplainDataQueryCallback} callback Node-style callback called with the error, if any, and ExplainDataQueryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.explainDataQuery = function explainDataQuery(request, callback) {
                    return this.rpcCall(explainDataQuery, $root.Ydb.Table.ExplainDataQueryRequest, $root.Ydb.Table.ExplainDataQueryResponse, request, callback);
                }, "name", { value: "ExplainDataQuery" });

                /**
                 * Calls ExplainDataQuery.
                 * @function explainDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExplainDataQueryRequest} request ExplainDataQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.ExplainDataQueryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#prepareDataQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef PrepareDataQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.PrepareDataQueryResponse} [response] PrepareDataQueryResponse
                 */

                /**
                 * Calls PrepareDataQuery.
                 * @function prepareDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IPrepareDataQueryRequest} request PrepareDataQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.PrepareDataQueryCallback} callback Node-style callback called with the error, if any, and PrepareDataQueryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.prepareDataQuery = function prepareDataQuery(request, callback) {
                    return this.rpcCall(prepareDataQuery, $root.Ydb.Table.PrepareDataQueryRequest, $root.Ydb.Table.PrepareDataQueryResponse, request, callback);
                }, "name", { value: "PrepareDataQuery" });

                /**
                 * Calls PrepareDataQuery.
                 * @function prepareDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IPrepareDataQueryRequest} request PrepareDataQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.PrepareDataQueryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#executeDataQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef ExecuteDataQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ExecuteDataQueryResponse} [response] ExecuteDataQueryResponse
                 */

                /**
                 * Calls ExecuteDataQuery.
                 * @function executeDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteDataQueryRequest} request ExecuteDataQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.ExecuteDataQueryCallback} callback Node-style callback called with the error, if any, and ExecuteDataQueryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.executeDataQuery = function executeDataQuery(request, callback) {
                    return this.rpcCall(executeDataQuery, $root.Ydb.Table.ExecuteDataQueryRequest, $root.Ydb.Table.ExecuteDataQueryResponse, request, callback);
                }, "name", { value: "ExecuteDataQuery" });

                /**
                 * Calls ExecuteDataQuery.
                 * @function executeDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteDataQueryRequest} request ExecuteDataQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.ExecuteDataQueryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#executeSchemeQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef ExecuteSchemeQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ExecuteSchemeQueryResponse} [response] ExecuteSchemeQueryResponse
                 */

                /**
                 * Calls ExecuteSchemeQuery.
                 * @function executeSchemeQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteSchemeQueryRequest} request ExecuteSchemeQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.ExecuteSchemeQueryCallback} callback Node-style callback called with the error, if any, and ExecuteSchemeQueryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.executeSchemeQuery = function executeSchemeQuery(request, callback) {
                    return this.rpcCall(executeSchemeQuery, $root.Ydb.Table.ExecuteSchemeQueryRequest, $root.Ydb.Table.ExecuteSchemeQueryResponse, request, callback);
                }, "name", { value: "ExecuteSchemeQuery" });

                /**
                 * Calls ExecuteSchemeQuery.
                 * @function executeSchemeQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteSchemeQueryRequest} request ExecuteSchemeQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.ExecuteSchemeQueryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#beginTransaction}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef BeginTransactionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.BeginTransactionResponse} [response] BeginTransactionResponse
                 */

                /**
                 * Calls BeginTransaction.
                 * @function beginTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IBeginTransactionRequest} request BeginTransactionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.BeginTransactionCallback} callback Node-style callback called with the error, if any, and BeginTransactionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.beginTransaction = function beginTransaction(request, callback) {
                    return this.rpcCall(beginTransaction, $root.Ydb.Table.BeginTransactionRequest, $root.Ydb.Table.BeginTransactionResponse, request, callback);
                }, "name", { value: "BeginTransaction" });

                /**
                 * Calls BeginTransaction.
                 * @function beginTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IBeginTransactionRequest} request BeginTransactionRequest message or plain object
                 * @returns {Promise<Ydb.Table.BeginTransactionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#commitTransaction}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CommitTransactionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CommitTransactionResponse} [response] CommitTransactionResponse
                 */

                /**
                 * Calls CommitTransaction.
                 * @function commitTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICommitTransactionRequest} request CommitTransactionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CommitTransactionCallback} callback Node-style callback called with the error, if any, and CommitTransactionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.commitTransaction = function commitTransaction(request, callback) {
                    return this.rpcCall(commitTransaction, $root.Ydb.Table.CommitTransactionRequest, $root.Ydb.Table.CommitTransactionResponse, request, callback);
                }, "name", { value: "CommitTransaction" });

                /**
                 * Calls CommitTransaction.
                 * @function commitTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICommitTransactionRequest} request CommitTransactionRequest message or plain object
                 * @returns {Promise<Ydb.Table.CommitTransactionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#rollbackTransaction}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef RollbackTransactionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.RollbackTransactionResponse} [response] RollbackTransactionResponse
                 */

                /**
                 * Calls RollbackTransaction.
                 * @function rollbackTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IRollbackTransactionRequest} request RollbackTransactionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.RollbackTransactionCallback} callback Node-style callback called with the error, if any, and RollbackTransactionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.rollbackTransaction = function rollbackTransaction(request, callback) {
                    return this.rpcCall(rollbackTransaction, $root.Ydb.Table.RollbackTransactionRequest, $root.Ydb.Table.RollbackTransactionResponse, request, callback);
                }, "name", { value: "RollbackTransaction" });

                /**
                 * Calls RollbackTransaction.
                 * @function rollbackTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IRollbackTransactionRequest} request RollbackTransactionRequest message or plain object
                 * @returns {Promise<Ydb.Table.RollbackTransactionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#describeTableOptions}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef DescribeTableOptionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.DescribeTableOptionsResponse} [response] DescribeTableOptionsResponse
                 */

                /**
                 * Calls DescribeTableOptions.
                 * @function describeTableOptions
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDescribeTableOptionsRequest} request DescribeTableOptionsRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.DescribeTableOptionsCallback} callback Node-style callback called with the error, if any, and DescribeTableOptionsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.describeTableOptions = function describeTableOptions(request, callback) {
                    return this.rpcCall(describeTableOptions, $root.Ydb.Table.DescribeTableOptionsRequest, $root.Ydb.Table.DescribeTableOptionsResponse, request, callback);
                }, "name", { value: "DescribeTableOptions" });

                /**
                 * Calls DescribeTableOptions.
                 * @function describeTableOptions
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDescribeTableOptionsRequest} request DescribeTableOptionsRequest message or plain object
                 * @returns {Promise<Ydb.Table.DescribeTableOptionsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#streamReadTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef StreamReadTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ReadTableResponse} [response] ReadTableResponse
                 */

                /**
                 * Calls StreamReadTable.
                 * @function streamReadTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IReadTableRequest} request ReadTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.StreamReadTableCallback} callback Node-style callback called with the error, if any, and ReadTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.streamReadTable = function streamReadTable(request, callback) {
                    return this.rpcCall(streamReadTable, $root.Ydb.Table.ReadTableRequest, $root.Ydb.Table.ReadTableResponse, request, callback);
                }, "name", { value: "StreamReadTable" });

                /**
                 * Calls StreamReadTable.
                 * @function streamReadTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IReadTableRequest} request ReadTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.ReadTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#bulkUpsert}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef BulkUpsertCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.BulkUpsertResponse} [response] BulkUpsertResponse
                 */

                /**
                 * Calls BulkUpsert.
                 * @function bulkUpsert
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IBulkUpsertRequest} request BulkUpsertRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.BulkUpsertCallback} callback Node-style callback called with the error, if any, and BulkUpsertResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.bulkUpsert = function bulkUpsert(request, callback) {
                    return this.rpcCall(bulkUpsert, $root.Ydb.Table.BulkUpsertRequest, $root.Ydb.Table.BulkUpsertResponse, request, callback);
                }, "name", { value: "BulkUpsert" });

                /**
                 * Calls BulkUpsert.
                 * @function bulkUpsert
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IBulkUpsertRequest} request BulkUpsertRequest message or plain object
                 * @returns {Promise<Ydb.Table.BulkUpsertResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#executeStreamQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef ExecuteStreamQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ExecuteStreamQueryResponse} [response] ExecuteStreamQueryResponse
                 */

                /**
                 * Calls ExecuteStreamQuery.
                 * @function executeStreamQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteStreamQueryRequest} request ExecuteStreamQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.ExecuteStreamQueryCallback} callback Node-style callback called with the error, if any, and ExecuteStreamQueryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.executeStreamQuery = function executeStreamQuery(request, callback) {
                    return this.rpcCall(executeStreamQuery, $root.Ydb.Table.ExecuteStreamQueryRequest, $root.Ydb.Table.ExecuteStreamQueryResponse, request, callback);
                }, "name", { value: "ExecuteStreamQuery" });

                /**
                 * Calls ExecuteStreamQuery.
                 * @function executeStreamQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteStreamQueryRequest} request ExecuteStreamQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.ExecuteStreamQueryResponse>} Promise
                 * @variation 2
                 */

                return TableService;
            })();

            return V1;
        })();

        Table.CreateSessionRequest = (function() {

            /**
             * Properties of a CreateSessionRequest.
             * @memberof Ydb.Table
             * @interface ICreateSessionRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CreateSessionRequest operationParams
             */

            /**
             * Constructs a new CreateSessionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateSessionRequest.
             * @implements ICreateSessionRequest
             * @constructor
             * @param {Ydb.Table.ICreateSessionRequest=} [properties] Properties to set
             */
            function CreateSessionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateSessionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CreateSessionRequest
             * @instance
             */
            CreateSessionRequest.prototype.operationParams = null;

            /**
             * Creates a new CreateSessionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Ydb.Table.ICreateSessionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CreateSessionRequest} CreateSessionRequest instance
             */
            CreateSessionRequest.create = function create(properties) {
                return new CreateSessionRequest(properties);
            };

            /**
             * Encodes the specified CreateSessionRequest message. Does not implicitly {@link Ydb.Table.CreateSessionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Ydb.Table.ICreateSessionRequest} message CreateSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateSessionRequest message, length delimited. Does not implicitly {@link Ydb.Table.CreateSessionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Ydb.Table.ICreateSessionRequest} message CreateSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateSessionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateSessionRequest} CreateSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateSessionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateSessionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateSessionRequest} CreateSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateSessionRequest message.
             * @function verify
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateSessionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a CreateSessionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateSessionRequest} CreateSessionRequest
             */
            CreateSessionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateSessionRequest)
                    return object;
                var message = new $root.Ydb.Table.CreateSessionRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CreateSessionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateSessionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Ydb.Table.CreateSessionRequest} message CreateSessionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateSessionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operationParams = null;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this CreateSessionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateSessionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateSessionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateSessionRequest;
        })();

        Table.CreateSessionResponse = (function() {

            /**
             * Properties of a CreateSessionResponse.
             * @memberof Ydb.Table
             * @interface ICreateSessionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CreateSessionResponse operation
             */

            /**
             * Constructs a new CreateSessionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateSessionResponse.
             * @implements ICreateSessionResponse
             * @constructor
             * @param {Ydb.Table.ICreateSessionResponse=} [properties] Properties to set
             */
            function CreateSessionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateSessionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CreateSessionResponse
             * @instance
             */
            CreateSessionResponse.prototype.operation = null;

            /**
             * Creates a new CreateSessionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Ydb.Table.ICreateSessionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CreateSessionResponse} CreateSessionResponse instance
             */
            CreateSessionResponse.create = function create(properties) {
                return new CreateSessionResponse(properties);
            };

            /**
             * Encodes the specified CreateSessionResponse message. Does not implicitly {@link Ydb.Table.CreateSessionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Ydb.Table.ICreateSessionResponse} message CreateSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateSessionResponse message, length delimited. Does not implicitly {@link Ydb.Table.CreateSessionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Ydb.Table.ICreateSessionResponse} message CreateSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateSessionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateSessionResponse} CreateSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateSessionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateSessionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateSessionResponse} CreateSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateSessionResponse message.
             * @function verify
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateSessionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CreateSessionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateSessionResponse} CreateSessionResponse
             */
            CreateSessionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateSessionResponse)
                    return object;
                var message = new $root.Ydb.Table.CreateSessionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CreateSessionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateSessionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Ydb.Table.CreateSessionResponse} message CreateSessionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateSessionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CreateSessionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateSessionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateSessionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateSessionResponse;
        })();

        Table.CreateSessionResult = (function() {

            /**
             * Properties of a CreateSessionResult.
             * @memberof Ydb.Table
             * @interface ICreateSessionResult
             * @property {string|null} [sessionId] CreateSessionResult sessionId
             */

            /**
             * Constructs a new CreateSessionResult.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateSessionResult.
             * @implements ICreateSessionResult
             * @constructor
             * @param {Ydb.Table.ICreateSessionResult=} [properties] Properties to set
             */
            function CreateSessionResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateSessionResult sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CreateSessionResult
             * @instance
             */
            CreateSessionResult.prototype.sessionId = "";

            /**
             * Creates a new CreateSessionResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Ydb.Table.ICreateSessionResult=} [properties] Properties to set
             * @returns {Ydb.Table.CreateSessionResult} CreateSessionResult instance
             */
            CreateSessionResult.create = function create(properties) {
                return new CreateSessionResult(properties);
            };

            /**
             * Encodes the specified CreateSessionResult message. Does not implicitly {@link Ydb.Table.CreateSessionResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Ydb.Table.ICreateSessionResult} message CreateSessionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                return writer;
            };

            /**
             * Encodes the specified CreateSessionResult message, length delimited. Does not implicitly {@link Ydb.Table.CreateSessionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Ydb.Table.ICreateSessionResult} message CreateSessionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateSessionResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateSessionResult} CreateSessionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateSessionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateSessionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateSessionResult} CreateSessionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateSessionResult message.
             * @function verify
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateSessionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                return null;
            };

            /**
             * Creates a CreateSessionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateSessionResult} CreateSessionResult
             */
            CreateSessionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateSessionResult)
                    return object;
                var message = new $root.Ydb.Table.CreateSessionResult();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                return message;
            };

            /**
             * Creates a plain object from a CreateSessionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Ydb.Table.CreateSessionResult} message CreateSessionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateSessionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.sessionId = "";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                return object;
            };

            /**
             * Converts this CreateSessionResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateSessionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateSessionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateSessionResult;
        })();

        Table.DeleteSessionRequest = (function() {

            /**
             * Properties of a DeleteSessionRequest.
             * @memberof Ydb.Table
             * @interface IDeleteSessionRequest
             * @property {string|null} [sessionId] DeleteSessionRequest sessionId
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DeleteSessionRequest operationParams
             */

            /**
             * Constructs a new DeleteSessionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a DeleteSessionRequest.
             * @implements IDeleteSessionRequest
             * @constructor
             * @param {Ydb.Table.IDeleteSessionRequest=} [properties] Properties to set
             */
            function DeleteSessionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteSessionRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.DeleteSessionRequest
             * @instance
             */
            DeleteSessionRequest.prototype.sessionId = "";

            /**
             * DeleteSessionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.DeleteSessionRequest
             * @instance
             */
            DeleteSessionRequest.prototype.operationParams = null;

            /**
             * Creates a new DeleteSessionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Ydb.Table.IDeleteSessionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.DeleteSessionRequest} DeleteSessionRequest instance
             */
            DeleteSessionRequest.create = function create(properties) {
                return new DeleteSessionRequest(properties);
            };

            /**
             * Encodes the specified DeleteSessionRequest message. Does not implicitly {@link Ydb.Table.DeleteSessionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Ydb.Table.IDeleteSessionRequest} message DeleteSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSessionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeleteSessionRequest message, length delimited. Does not implicitly {@link Ydb.Table.DeleteSessionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Ydb.Table.IDeleteSessionRequest} message DeleteSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSessionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSessionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DeleteSessionRequest} DeleteSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSessionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DeleteSessionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSessionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DeleteSessionRequest} DeleteSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSessionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSessionRequest message.
             * @function verify
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSessionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a DeleteSessionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DeleteSessionRequest} DeleteSessionRequest
             */
            DeleteSessionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DeleteSessionRequest)
                    return object;
                var message = new $root.Ydb.Table.DeleteSessionRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.DeleteSessionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DeleteSessionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Ydb.Table.DeleteSessionRequest} message DeleteSessionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSessionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this DeleteSessionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DeleteSessionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSessionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteSessionRequest;
        })();

        Table.DeleteSessionResponse = (function() {

            /**
             * Properties of a DeleteSessionResponse.
             * @memberof Ydb.Table
             * @interface IDeleteSessionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DeleteSessionResponse operation
             */

            /**
             * Constructs a new DeleteSessionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a DeleteSessionResponse.
             * @implements IDeleteSessionResponse
             * @constructor
             * @param {Ydb.Table.IDeleteSessionResponse=} [properties] Properties to set
             */
            function DeleteSessionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteSessionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.DeleteSessionResponse
             * @instance
             */
            DeleteSessionResponse.prototype.operation = null;

            /**
             * Creates a new DeleteSessionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Ydb.Table.IDeleteSessionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.DeleteSessionResponse} DeleteSessionResponse instance
             */
            DeleteSessionResponse.create = function create(properties) {
                return new DeleteSessionResponse(properties);
            };

            /**
             * Encodes the specified DeleteSessionResponse message. Does not implicitly {@link Ydb.Table.DeleteSessionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Ydb.Table.IDeleteSessionResponse} message DeleteSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSessionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeleteSessionResponse message, length delimited. Does not implicitly {@link Ydb.Table.DeleteSessionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Ydb.Table.IDeleteSessionResponse} message DeleteSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSessionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSessionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DeleteSessionResponse} DeleteSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSessionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DeleteSessionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSessionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DeleteSessionResponse} DeleteSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSessionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSessionResponse message.
             * @function verify
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSessionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DeleteSessionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DeleteSessionResponse} DeleteSessionResponse
             */
            DeleteSessionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DeleteSessionResponse)
                    return object;
                var message = new $root.Ydb.Table.DeleteSessionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.DeleteSessionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DeleteSessionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Ydb.Table.DeleteSessionResponse} message DeleteSessionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSessionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DeleteSessionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DeleteSessionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSessionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteSessionResponse;
        })();

        Table.GlobalIndex = (function() {

            /**
             * Properties of a GlobalIndex.
             * @memberof Ydb.Table
             * @interface IGlobalIndex
             */

            /**
             * Constructs a new GlobalIndex.
             * @memberof Ydb.Table
             * @classdesc Represents a GlobalIndex.
             * @implements IGlobalIndex
             * @constructor
             * @param {Ydb.Table.IGlobalIndex=} [properties] Properties to set
             */
            function GlobalIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GlobalIndex instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Ydb.Table.IGlobalIndex=} [properties] Properties to set
             * @returns {Ydb.Table.GlobalIndex} GlobalIndex instance
             */
            GlobalIndex.create = function create(properties) {
                return new GlobalIndex(properties);
            };

            /**
             * Encodes the specified GlobalIndex message. Does not implicitly {@link Ydb.Table.GlobalIndex.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Ydb.Table.IGlobalIndex} message GlobalIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GlobalIndex message, length delimited. Does not implicitly {@link Ydb.Table.GlobalIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Ydb.Table.IGlobalIndex} message GlobalIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalIndex message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.GlobalIndex} GlobalIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.GlobalIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.GlobalIndex} GlobalIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalIndex message.
             * @function verify
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlobalIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GlobalIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.GlobalIndex} GlobalIndex
             */
            GlobalIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.GlobalIndex)
                    return object;
                return new $root.Ydb.Table.GlobalIndex();
            };

            /**
             * Creates a plain object from a GlobalIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Ydb.Table.GlobalIndex} message GlobalIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalIndex.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GlobalIndex to JSON.
             * @function toJSON
             * @memberof Ydb.Table.GlobalIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlobalIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalIndex;
        })();

        Table.TableIndex = (function() {

            /**
             * Properties of a TableIndex.
             * @memberof Ydb.Table
             * @interface ITableIndex
             * @property {string|null} [name] TableIndex name
             * @property {Array.<string>|null} [indexColumns] TableIndex indexColumns
             * @property {Ydb.Table.IGlobalIndex|null} [globalIndex] TableIndex globalIndex
             */

            /**
             * Constructs a new TableIndex.
             * @memberof Ydb.Table
             * @classdesc Represents a TableIndex.
             * @implements ITableIndex
             * @constructor
             * @param {Ydb.Table.ITableIndex=} [properties] Properties to set
             */
            function TableIndex(properties) {
                this.indexColumns = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableIndex name.
             * @member {string} name
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            TableIndex.prototype.name = "";

            /**
             * TableIndex indexColumns.
             * @member {Array.<string>} indexColumns
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            TableIndex.prototype.indexColumns = $util.emptyArray;

            /**
             * TableIndex globalIndex.
             * @member {Ydb.Table.IGlobalIndex|null|undefined} globalIndex
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            TableIndex.prototype.globalIndex = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TableIndex type.
             * @member {"globalIndex"|undefined} type
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            Object.defineProperty(TableIndex.prototype, "type", {
                get: $util.oneOfGetter($oneOfFields = ["globalIndex"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TableIndex instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Ydb.Table.ITableIndex=} [properties] Properties to set
             * @returns {Ydb.Table.TableIndex} TableIndex instance
             */
            TableIndex.create = function create(properties) {
                return new TableIndex(properties);
            };

            /**
             * Encodes the specified TableIndex message. Does not implicitly {@link Ydb.Table.TableIndex.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Ydb.Table.ITableIndex} message TableIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.indexColumns != null && message.indexColumns.length)
                    for (var i = 0; i < message.indexColumns.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexColumns[i]);
                if (message.globalIndex != null && message.hasOwnProperty("globalIndex"))
                    $root.Ydb.Table.GlobalIndex.encode(message.globalIndex, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableIndex message, length delimited. Does not implicitly {@link Ydb.Table.TableIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Ydb.Table.ITableIndex} message TableIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableIndex message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TableIndex} TableIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TableIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.indexColumns && message.indexColumns.length))
                            message.indexColumns = [];
                        message.indexColumns.push(reader.string());
                        break;
                    case 3:
                        message.globalIndex = $root.Ydb.Table.GlobalIndex.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TableIndex} TableIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableIndex message.
             * @function verify
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.indexColumns != null && message.hasOwnProperty("indexColumns")) {
                    if (!Array.isArray(message.indexColumns))
                        return "indexColumns: array expected";
                    for (var i = 0; i < message.indexColumns.length; ++i)
                        if (!$util.isString(message.indexColumns[i]))
                            return "indexColumns: string[] expected";
                }
                if (message.globalIndex != null && message.hasOwnProperty("globalIndex")) {
                    properties.type = 1;
                    {
                        var error = $root.Ydb.Table.GlobalIndex.verify(message.globalIndex);
                        if (error)
                            return "globalIndex." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TableIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TableIndex} TableIndex
             */
            TableIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TableIndex)
                    return object;
                var message = new $root.Ydb.Table.TableIndex();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.indexColumns) {
                    if (!Array.isArray(object.indexColumns))
                        throw TypeError(".Ydb.Table.TableIndex.indexColumns: array expected");
                    message.indexColumns = [];
                    for (var i = 0; i < object.indexColumns.length; ++i)
                        message.indexColumns[i] = String(object.indexColumns[i]);
                }
                if (object.globalIndex != null) {
                    if (typeof object.globalIndex !== "object")
                        throw TypeError(".Ydb.Table.TableIndex.globalIndex: object expected");
                    message.globalIndex = $root.Ydb.Table.GlobalIndex.fromObject(object.globalIndex);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Ydb.Table.TableIndex} message TableIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableIndex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.indexColumns = [];
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.indexColumns && message.indexColumns.length) {
                    object.indexColumns = [];
                    for (var j = 0; j < message.indexColumns.length; ++j)
                        object.indexColumns[j] = message.indexColumns[j];
                }
                if (message.globalIndex != null && message.hasOwnProperty("globalIndex")) {
                    object.globalIndex = $root.Ydb.Table.GlobalIndex.toObject(message.globalIndex, options);
                    if (options.oneofs)
                        object.type = "globalIndex";
                }
                return object;
            };

            /**
             * Converts this TableIndex to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TableIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableIndex;
        })();

        Table.StorageSettings = (function() {

            /**
             * Properties of a StorageSettings.
             * @memberof Ydb.Table
             * @interface IStorageSettings
             * @property {string|null} [storageKind] StorageSettings storageKind
             */

            /**
             * Constructs a new StorageSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a StorageSettings.
             * @implements IStorageSettings
             * @constructor
             * @param {Ydb.Table.IStorageSettings=} [properties] Properties to set
             */
            function StorageSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StorageSettings storageKind.
             * @member {string} storageKind
             * @memberof Ydb.Table.StorageSettings
             * @instance
             */
            StorageSettings.prototype.storageKind = "";

            /**
             * Creates a new StorageSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Ydb.Table.IStorageSettings=} [properties] Properties to set
             * @returns {Ydb.Table.StorageSettings} StorageSettings instance
             */
            StorageSettings.create = function create(properties) {
                return new StorageSettings(properties);
            };

            /**
             * Encodes the specified StorageSettings message. Does not implicitly {@link Ydb.Table.StorageSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Ydb.Table.IStorageSettings} message StorageSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.storageKind != null && message.hasOwnProperty("storageKind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.storageKind);
                return writer;
            };

            /**
             * Encodes the specified StorageSettings message, length delimited. Does not implicitly {@link Ydb.Table.StorageSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Ydb.Table.IStorageSettings} message StorageSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StorageSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.StorageSettings} StorageSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.StorageSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.storageKind = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StorageSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.StorageSettings} StorageSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StorageSettings message.
             * @function verify
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.storageKind != null && message.hasOwnProperty("storageKind"))
                    if (!$util.isString(message.storageKind))
                        return "storageKind: string expected";
                return null;
            };

            /**
             * Creates a StorageSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.StorageSettings} StorageSettings
             */
            StorageSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.StorageSettings)
                    return object;
                var message = new $root.Ydb.Table.StorageSettings();
                if (object.storageKind != null)
                    message.storageKind = String(object.storageKind);
                return message;
            };

            /**
             * Creates a plain object from a StorageSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Ydb.Table.StorageSettings} message StorageSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.storageKind = "";
                if (message.storageKind != null && message.hasOwnProperty("storageKind"))
                    object.storageKind = message.storageKind;
                return object;
            };

            /**
             * Converts this StorageSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.StorageSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StorageSettings;
        })();

        Table.StoragePolicy = (function() {

            /**
             * Properties of a StoragePolicy.
             * @memberof Ydb.Table
             * @interface IStoragePolicy
             * @property {string|null} [presetName] StoragePolicy presetName
             * @property {Ydb.Table.IStorageSettings|null} [syslog] StoragePolicy syslog
             * @property {Ydb.Table.IStorageSettings|null} [log] StoragePolicy log
             * @property {Ydb.Table.IStorageSettings|null} [data] StoragePolicy data
             * @property {Ydb.Table.IStorageSettings|null} [external] StoragePolicy external
             * @property {Ydb.FeatureFlag.Status|null} [keepInMemory] StoragePolicy keepInMemory
             * @property {Array.<Ydb.Table.IColumnFamilyPolicy>|null} [columnFamilies] StoragePolicy columnFamilies
             */

            /**
             * Constructs a new StoragePolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a StoragePolicy.
             * @implements IStoragePolicy
             * @constructor
             * @param {Ydb.Table.IStoragePolicy=} [properties] Properties to set
             */
            function StoragePolicy(properties) {
                this.columnFamilies = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoragePolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.presetName = "";

            /**
             * StoragePolicy syslog.
             * @member {Ydb.Table.IStorageSettings|null|undefined} syslog
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.syslog = null;

            /**
             * StoragePolicy log.
             * @member {Ydb.Table.IStorageSettings|null|undefined} log
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.log = null;

            /**
             * StoragePolicy data.
             * @member {Ydb.Table.IStorageSettings|null|undefined} data
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.data = null;

            /**
             * StoragePolicy external.
             * @member {Ydb.Table.IStorageSettings|null|undefined} external
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.external = null;

            /**
             * StoragePolicy keepInMemory.
             * @member {Ydb.FeatureFlag.Status} keepInMemory
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.keepInMemory = 0;

            /**
             * StoragePolicy columnFamilies.
             * @member {Array.<Ydb.Table.IColumnFamilyPolicy>} columnFamilies
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.columnFamilies = $util.emptyArray;

            /**
             * Creates a new StoragePolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Ydb.Table.IStoragePolicy=} [properties] Properties to set
             * @returns {Ydb.Table.StoragePolicy} StoragePolicy instance
             */
            StoragePolicy.create = function create(properties) {
                return new StoragePolicy(properties);
            };

            /**
             * Encodes the specified StoragePolicy message. Does not implicitly {@link Ydb.Table.StoragePolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Ydb.Table.IStoragePolicy} message StoragePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                if (message.syslog != null && message.hasOwnProperty("syslog"))
                    $root.Ydb.Table.StorageSettings.encode(message.syslog, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.log != null && message.hasOwnProperty("log"))
                    $root.Ydb.Table.StorageSettings.encode(message.log, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.data != null && message.hasOwnProperty("data"))
                    $root.Ydb.Table.StorageSettings.encode(message.data, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.external != null && message.hasOwnProperty("external"))
                    $root.Ydb.Table.StorageSettings.encode(message.external, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.keepInMemory);
                if (message.columnFamilies != null && message.columnFamilies.length)
                    for (var i = 0; i < message.columnFamilies.length; ++i)
                        $root.Ydb.Table.ColumnFamilyPolicy.encode(message.columnFamilies[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StoragePolicy message, length delimited. Does not implicitly {@link Ydb.Table.StoragePolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Ydb.Table.IStoragePolicy} message StoragePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoragePolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.StoragePolicy} StoragePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.StoragePolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    case 2:
                        message.syslog = $root.Ydb.Table.StorageSettings.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.log = $root.Ydb.Table.StorageSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.data = $root.Ydb.Table.StorageSettings.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.external = $root.Ydb.Table.StorageSettings.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.keepInMemory = reader.int32();
                        break;
                    case 7:
                        if (!(message.columnFamilies && message.columnFamilies.length))
                            message.columnFamilies = [];
                        message.columnFamilies.push($root.Ydb.Table.ColumnFamilyPolicy.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoragePolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.StoragePolicy} StoragePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoragePolicy message.
             * @function verify
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoragePolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                if (message.syslog != null && message.hasOwnProperty("syslog")) {
                    var error = $root.Ydb.Table.StorageSettings.verify(message.syslog);
                    if (error)
                        return "syslog." + error;
                }
                if (message.log != null && message.hasOwnProperty("log")) {
                    var error = $root.Ydb.Table.StorageSettings.verify(message.log);
                    if (error)
                        return "log." + error;
                }
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.Ydb.Table.StorageSettings.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.external != null && message.hasOwnProperty("external")) {
                    var error = $root.Ydb.Table.StorageSettings.verify(message.external);
                    if (error)
                        return "external." + error;
                }
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    switch (message.keepInMemory) {
                    default:
                        return "keepInMemory: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.columnFamilies != null && message.hasOwnProperty("columnFamilies")) {
                    if (!Array.isArray(message.columnFamilies))
                        return "columnFamilies: array expected";
                    for (var i = 0; i < message.columnFamilies.length; ++i) {
                        var error = $root.Ydb.Table.ColumnFamilyPolicy.verify(message.columnFamilies[i]);
                        if (error)
                            return "columnFamilies." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a StoragePolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.StoragePolicy} StoragePolicy
             */
            StoragePolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.StoragePolicy)
                    return object;
                var message = new $root.Ydb.Table.StoragePolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                if (object.syslog != null) {
                    if (typeof object.syslog !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicy.syslog: object expected");
                    message.syslog = $root.Ydb.Table.StorageSettings.fromObject(object.syslog);
                }
                if (object.log != null) {
                    if (typeof object.log !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicy.log: object expected");
                    message.log = $root.Ydb.Table.StorageSettings.fromObject(object.log);
                }
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicy.data: object expected");
                    message.data = $root.Ydb.Table.StorageSettings.fromObject(object.data);
                }
                if (object.external != null) {
                    if (typeof object.external !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicy.external: object expected");
                    message.external = $root.Ydb.Table.StorageSettings.fromObject(object.external);
                }
                switch (object.keepInMemory) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.keepInMemory = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.keepInMemory = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.keepInMemory = 2;
                    break;
                }
                if (object.columnFamilies) {
                    if (!Array.isArray(object.columnFamilies))
                        throw TypeError(".Ydb.Table.StoragePolicy.columnFamilies: array expected");
                    message.columnFamilies = [];
                    for (var i = 0; i < object.columnFamilies.length; ++i) {
                        if (typeof object.columnFamilies[i] !== "object")
                            throw TypeError(".Ydb.Table.StoragePolicy.columnFamilies: object expected");
                        message.columnFamilies[i] = $root.Ydb.Table.ColumnFamilyPolicy.fromObject(object.columnFamilies[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a StoragePolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Ydb.Table.StoragePolicy} message StoragePolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoragePolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.columnFamilies = [];
                if (options.defaults) {
                    object.presetName = "";
                    object.syslog = null;
                    object.log = null;
                    object.data = null;
                    object.external = null;
                    object.keepInMemory = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                if (message.syslog != null && message.hasOwnProperty("syslog"))
                    object.syslog = $root.Ydb.Table.StorageSettings.toObject(message.syslog, options);
                if (message.log != null && message.hasOwnProperty("log"))
                    object.log = $root.Ydb.Table.StorageSettings.toObject(message.log, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.Ydb.Table.StorageSettings.toObject(message.data, options);
                if (message.external != null && message.hasOwnProperty("external"))
                    object.external = $root.Ydb.Table.StorageSettings.toObject(message.external, options);
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    object.keepInMemory = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.keepInMemory] : message.keepInMemory;
                if (message.columnFamilies && message.columnFamilies.length) {
                    object.columnFamilies = [];
                    for (var j = 0; j < message.columnFamilies.length; ++j)
                        object.columnFamilies[j] = $root.Ydb.Table.ColumnFamilyPolicy.toObject(message.columnFamilies[j], options);
                }
                return object;
            };

            /**
             * Converts this StoragePolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoragePolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoragePolicy;
        })();

        Table.ColumnFamilyPolicy = (function() {

            /**
             * Properties of a ColumnFamilyPolicy.
             * @memberof Ydb.Table
             * @interface IColumnFamilyPolicy
             * @property {string|null} [name] ColumnFamilyPolicy name
             * @property {Ydb.Table.IStorageSettings|null} [data] ColumnFamilyPolicy data
             * @property {Ydb.Table.IStorageSettings|null} [external] ColumnFamilyPolicy external
             * @property {Ydb.FeatureFlag.Status|null} [keepInMemory] ColumnFamilyPolicy keepInMemory
             * @property {Ydb.Table.ColumnFamilyPolicy.Compression|null} [compression] ColumnFamilyPolicy compression
             */

            /**
             * Constructs a new ColumnFamilyPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a ColumnFamilyPolicy.
             * @implements IColumnFamilyPolicy
             * @constructor
             * @param {Ydb.Table.IColumnFamilyPolicy=} [properties] Properties to set
             */
            function ColumnFamilyPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ColumnFamilyPolicy name.
             * @member {string} name
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.name = "";

            /**
             * ColumnFamilyPolicy data.
             * @member {Ydb.Table.IStorageSettings|null|undefined} data
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.data = null;

            /**
             * ColumnFamilyPolicy external.
             * @member {Ydb.Table.IStorageSettings|null|undefined} external
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.external = null;

            /**
             * ColumnFamilyPolicy keepInMemory.
             * @member {Ydb.FeatureFlag.Status} keepInMemory
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.keepInMemory = 0;

            /**
             * ColumnFamilyPolicy compression.
             * @member {Ydb.Table.ColumnFamilyPolicy.Compression} compression
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.compression = 0;

            /**
             * Creates a new ColumnFamilyPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Ydb.Table.IColumnFamilyPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.ColumnFamilyPolicy} ColumnFamilyPolicy instance
             */
            ColumnFamilyPolicy.create = function create(properties) {
                return new ColumnFamilyPolicy(properties);
            };

            /**
             * Encodes the specified ColumnFamilyPolicy message. Does not implicitly {@link Ydb.Table.ColumnFamilyPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Ydb.Table.IColumnFamilyPolicy} message ColumnFamilyPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnFamilyPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && message.hasOwnProperty("data"))
                    $root.Ydb.Table.StorageSettings.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.external != null && message.hasOwnProperty("external"))
                    $root.Ydb.Table.StorageSettings.encode(message.external, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.keepInMemory);
                if (message.compression != null && message.hasOwnProperty("compression"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.compression);
                return writer;
            };

            /**
             * Encodes the specified ColumnFamilyPolicy message, length delimited. Does not implicitly {@link Ydb.Table.ColumnFamilyPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Ydb.Table.IColumnFamilyPolicy} message ColumnFamilyPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnFamilyPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ColumnFamilyPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ColumnFamilyPolicy} ColumnFamilyPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnFamilyPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ColumnFamilyPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.data = $root.Ydb.Table.StorageSettings.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.external = $root.Ydb.Table.StorageSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.keepInMemory = reader.int32();
                        break;
                    case 5:
                        message.compression = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ColumnFamilyPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ColumnFamilyPolicy} ColumnFamilyPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnFamilyPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ColumnFamilyPolicy message.
             * @function verify
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnFamilyPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.Ydb.Table.StorageSettings.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.external != null && message.hasOwnProperty("external")) {
                    var error = $root.Ydb.Table.StorageSettings.verify(message.external);
                    if (error)
                        return "external." + error;
                }
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    switch (message.keepInMemory) {
                    default:
                        return "keepInMemory: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.compression != null && message.hasOwnProperty("compression"))
                    switch (message.compression) {
                    default:
                        return "compression: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a ColumnFamilyPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ColumnFamilyPolicy} ColumnFamilyPolicy
             */
            ColumnFamilyPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ColumnFamilyPolicy)
                    return object;
                var message = new $root.Ydb.Table.ColumnFamilyPolicy();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".Ydb.Table.ColumnFamilyPolicy.data: object expected");
                    message.data = $root.Ydb.Table.StorageSettings.fromObject(object.data);
                }
                if (object.external != null) {
                    if (typeof object.external !== "object")
                        throw TypeError(".Ydb.Table.ColumnFamilyPolicy.external: object expected");
                    message.external = $root.Ydb.Table.StorageSettings.fromObject(object.external);
                }
                switch (object.keepInMemory) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.keepInMemory = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.keepInMemory = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.keepInMemory = 2;
                    break;
                }
                switch (object.compression) {
                case "COMPRESSION_UNSPECIFIED":
                case 0:
                    message.compression = 0;
                    break;
                case "UNCOMPRESSED":
                case 1:
                    message.compression = 1;
                    break;
                case "COMPRESSED":
                case 2:
                    message.compression = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ColumnFamilyPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Ydb.Table.ColumnFamilyPolicy} message ColumnFamilyPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnFamilyPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.external = null;
                    object.keepInMemory = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    object.compression = options.enums === String ? "COMPRESSION_UNSPECIFIED" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.Ydb.Table.StorageSettings.toObject(message.data, options);
                if (message.external != null && message.hasOwnProperty("external"))
                    object.external = $root.Ydb.Table.StorageSettings.toObject(message.external, options);
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    object.keepInMemory = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.keepInMemory] : message.keepInMemory;
                if (message.compression != null && message.hasOwnProperty("compression"))
                    object.compression = options.enums === String ? $root.Ydb.Table.ColumnFamilyPolicy.Compression[message.compression] : message.compression;
                return object;
            };

            /**
             * Converts this ColumnFamilyPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnFamilyPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Compression enum.
             * @name Ydb.Table.ColumnFamilyPolicy.Compression
             * @enum {string}
             * @property {number} COMPRESSION_UNSPECIFIED=0 COMPRESSION_UNSPECIFIED value
             * @property {number} UNCOMPRESSED=1 UNCOMPRESSED value
             * @property {number} COMPRESSED=2 COMPRESSED value
             */
            ColumnFamilyPolicy.Compression = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COMPRESSION_UNSPECIFIED"] = 0;
                values[valuesById[1] = "UNCOMPRESSED"] = 1;
                values[valuesById[2] = "COMPRESSED"] = 2;
                return values;
            })();

            return ColumnFamilyPolicy;
        })();

        Table.CompactionPolicy = (function() {

            /**
             * Properties of a CompactionPolicy.
             * @memberof Ydb.Table
             * @interface ICompactionPolicy
             * @property {string|null} [presetName] CompactionPolicy presetName
             */

            /**
             * Constructs a new CompactionPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a CompactionPolicy.
             * @implements ICompactionPolicy
             * @constructor
             * @param {Ydb.Table.ICompactionPolicy=} [properties] Properties to set
             */
            function CompactionPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompactionPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.CompactionPolicy
             * @instance
             */
            CompactionPolicy.prototype.presetName = "";

            /**
             * Creates a new CompactionPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Ydb.Table.ICompactionPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.CompactionPolicy} CompactionPolicy instance
             */
            CompactionPolicy.create = function create(properties) {
                return new CompactionPolicy(properties);
            };

            /**
             * Encodes the specified CompactionPolicy message. Does not implicitly {@link Ydb.Table.CompactionPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Ydb.Table.ICompactionPolicy} message CompactionPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactionPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                return writer;
            };

            /**
             * Encodes the specified CompactionPolicy message, length delimited. Does not implicitly {@link Ydb.Table.CompactionPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Ydb.Table.ICompactionPolicy} message CompactionPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactionPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompactionPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CompactionPolicy} CompactionPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactionPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CompactionPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CompactionPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CompactionPolicy} CompactionPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactionPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompactionPolicy message.
             * @function verify
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompactionPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                return null;
            };

            /**
             * Creates a CompactionPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CompactionPolicy} CompactionPolicy
             */
            CompactionPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CompactionPolicy)
                    return object;
                var message = new $root.Ydb.Table.CompactionPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                return message;
            };

            /**
             * Creates a plain object from a CompactionPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Ydb.Table.CompactionPolicy} message CompactionPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CompactionPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.presetName = "";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                return object;
            };

            /**
             * Converts this CompactionPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CompactionPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CompactionPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CompactionPolicy;
        })();

        Table.ExplicitPartitions = (function() {

            /**
             * Properties of an ExplicitPartitions.
             * @memberof Ydb.Table
             * @interface IExplicitPartitions
             * @property {Array.<Ydb.ITypedValue>|null} [splitPoints] ExplicitPartitions splitPoints
             */

            /**
             * Constructs a new ExplicitPartitions.
             * @memberof Ydb.Table
             * @classdesc Represents an ExplicitPartitions.
             * @implements IExplicitPartitions
             * @constructor
             * @param {Ydb.Table.IExplicitPartitions=} [properties] Properties to set
             */
            function ExplicitPartitions(properties) {
                this.splitPoints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplicitPartitions splitPoints.
             * @member {Array.<Ydb.ITypedValue>} splitPoints
             * @memberof Ydb.Table.ExplicitPartitions
             * @instance
             */
            ExplicitPartitions.prototype.splitPoints = $util.emptyArray;

            /**
             * Creates a new ExplicitPartitions instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Ydb.Table.IExplicitPartitions=} [properties] Properties to set
             * @returns {Ydb.Table.ExplicitPartitions} ExplicitPartitions instance
             */
            ExplicitPartitions.create = function create(properties) {
                return new ExplicitPartitions(properties);
            };

            /**
             * Encodes the specified ExplicitPartitions message. Does not implicitly {@link Ydb.Table.ExplicitPartitions.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Ydb.Table.IExplicitPartitions} message ExplicitPartitions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplicitPartitions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.splitPoints != null && message.splitPoints.length)
                    for (var i = 0; i < message.splitPoints.length; ++i)
                        $root.Ydb.TypedValue.encode(message.splitPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExplicitPartitions message, length delimited. Does not implicitly {@link Ydb.Table.ExplicitPartitions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Ydb.Table.IExplicitPartitions} message ExplicitPartitions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplicitPartitions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplicitPartitions message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExplicitPartitions} ExplicitPartitions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplicitPartitions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExplicitPartitions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.splitPoints && message.splitPoints.length))
                            message.splitPoints = [];
                        message.splitPoints.push($root.Ydb.TypedValue.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplicitPartitions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExplicitPartitions} ExplicitPartitions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplicitPartitions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplicitPartitions message.
             * @function verify
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplicitPartitions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.splitPoints != null && message.hasOwnProperty("splitPoints")) {
                    if (!Array.isArray(message.splitPoints))
                        return "splitPoints: array expected";
                    for (var i = 0; i < message.splitPoints.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.splitPoints[i]);
                        if (error)
                            return "splitPoints." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExplicitPartitions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExplicitPartitions} ExplicitPartitions
             */
            ExplicitPartitions.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExplicitPartitions)
                    return object;
                var message = new $root.Ydb.Table.ExplicitPartitions();
                if (object.splitPoints) {
                    if (!Array.isArray(object.splitPoints))
                        throw TypeError(".Ydb.Table.ExplicitPartitions.splitPoints: array expected");
                    message.splitPoints = [];
                    for (var i = 0; i < object.splitPoints.length; ++i) {
                        if (typeof object.splitPoints[i] !== "object")
                            throw TypeError(".Ydb.Table.ExplicitPartitions.splitPoints: object expected");
                        message.splitPoints[i] = $root.Ydb.TypedValue.fromObject(object.splitPoints[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExplicitPartitions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Ydb.Table.ExplicitPartitions} message ExplicitPartitions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplicitPartitions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.splitPoints = [];
                if (message.splitPoints && message.splitPoints.length) {
                    object.splitPoints = [];
                    for (var j = 0; j < message.splitPoints.length; ++j)
                        object.splitPoints[j] = $root.Ydb.TypedValue.toObject(message.splitPoints[j], options);
                }
                return object;
            };

            /**
             * Converts this ExplicitPartitions to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExplicitPartitions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplicitPartitions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplicitPartitions;
        })();

        Table.PartitionStats = (function() {

            /**
             * Properties of a PartitionStats.
             * @memberof Ydb.Table
             * @interface IPartitionStats
             * @property {number|Long|null} [rowsEstimate] PartitionStats rowsEstimate
             * @property {number|Long|null} [storeSize] PartitionStats storeSize
             */

            /**
             * Constructs a new PartitionStats.
             * @memberof Ydb.Table
             * @classdesc Represents a PartitionStats.
             * @implements IPartitionStats
             * @constructor
             * @param {Ydb.Table.IPartitionStats=} [properties] Properties to set
             */
            function PartitionStats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PartitionStats rowsEstimate.
             * @member {number|Long} rowsEstimate
             * @memberof Ydb.Table.PartitionStats
             * @instance
             */
            PartitionStats.prototype.rowsEstimate = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PartitionStats storeSize.
             * @member {number|Long} storeSize
             * @memberof Ydb.Table.PartitionStats
             * @instance
             */
            PartitionStats.prototype.storeSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new PartitionStats instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Ydb.Table.IPartitionStats=} [properties] Properties to set
             * @returns {Ydb.Table.PartitionStats} PartitionStats instance
             */
            PartitionStats.create = function create(properties) {
                return new PartitionStats(properties);
            };

            /**
             * Encodes the specified PartitionStats message. Does not implicitly {@link Ydb.Table.PartitionStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Ydb.Table.IPartitionStats} message PartitionStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitionStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.rowsEstimate);
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.storeSize);
                return writer;
            };

            /**
             * Encodes the specified PartitionStats message, length delimited. Does not implicitly {@link Ydb.Table.PartitionStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Ydb.Table.IPartitionStats} message PartitionStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitionStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PartitionStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PartitionStats} PartitionStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitionStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PartitionStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rowsEstimate = reader.uint64();
                        break;
                    case 2:
                        message.storeSize = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PartitionStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PartitionStats} PartitionStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitionStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PartitionStats message.
             * @function verify
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PartitionStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    if (!$util.isInteger(message.rowsEstimate) && !(message.rowsEstimate && $util.isInteger(message.rowsEstimate.low) && $util.isInteger(message.rowsEstimate.high)))
                        return "rowsEstimate: integer|Long expected";
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    if (!$util.isInteger(message.storeSize) && !(message.storeSize && $util.isInteger(message.storeSize.low) && $util.isInteger(message.storeSize.high)))
                        return "storeSize: integer|Long expected";
                return null;
            };

            /**
             * Creates a PartitionStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PartitionStats} PartitionStats
             */
            PartitionStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PartitionStats)
                    return object;
                var message = new $root.Ydb.Table.PartitionStats();
                if (object.rowsEstimate != null)
                    if ($util.Long)
                        (message.rowsEstimate = $util.Long.fromValue(object.rowsEstimate)).unsigned = true;
                    else if (typeof object.rowsEstimate === "string")
                        message.rowsEstimate = parseInt(object.rowsEstimate, 10);
                    else if (typeof object.rowsEstimate === "number")
                        message.rowsEstimate = object.rowsEstimate;
                    else if (typeof object.rowsEstimate === "object")
                        message.rowsEstimate = new $util.LongBits(object.rowsEstimate.low >>> 0, object.rowsEstimate.high >>> 0).toNumber(true);
                if (object.storeSize != null)
                    if ($util.Long)
                        (message.storeSize = $util.Long.fromValue(object.storeSize)).unsigned = true;
                    else if (typeof object.storeSize === "string")
                        message.storeSize = parseInt(object.storeSize, 10);
                    else if (typeof object.storeSize === "number")
                        message.storeSize = object.storeSize;
                    else if (typeof object.storeSize === "object")
                        message.storeSize = new $util.LongBits(object.storeSize.low >>> 0, object.storeSize.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a PartitionStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Ydb.Table.PartitionStats} message PartitionStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PartitionStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.rowsEstimate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowsEstimate = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.storeSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.storeSize = options.longs === String ? "0" : 0;
                }
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    if (typeof message.rowsEstimate === "number")
                        object.rowsEstimate = options.longs === String ? String(message.rowsEstimate) : message.rowsEstimate;
                    else
                        object.rowsEstimate = options.longs === String ? $util.Long.prototype.toString.call(message.rowsEstimate) : options.longs === Number ? new $util.LongBits(message.rowsEstimate.low >>> 0, message.rowsEstimate.high >>> 0).toNumber(true) : message.rowsEstimate;
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    if (typeof message.storeSize === "number")
                        object.storeSize = options.longs === String ? String(message.storeSize) : message.storeSize;
                    else
                        object.storeSize = options.longs === String ? $util.Long.prototype.toString.call(message.storeSize) : options.longs === Number ? new $util.LongBits(message.storeSize.low >>> 0, message.storeSize.high >>> 0).toNumber(true) : message.storeSize;
                return object;
            };

            /**
             * Converts this PartitionStats to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PartitionStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PartitionStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PartitionStats;
        })();

        Table.TableStats = (function() {

            /**
             * Properties of a TableStats.
             * @memberof Ydb.Table
             * @interface ITableStats
             * @property {Array.<Ydb.Table.IPartitionStats>|null} [partitionStats] TableStats partitionStats
             * @property {number|Long|null} [rowsEstimate] TableStats rowsEstimate
             * @property {number|Long|null} [storeSize] TableStats storeSize
             * @property {number|Long|null} [partitions] TableStats partitions
             * @property {google.protobuf.ITimestamp|null} [creationTime] TableStats creationTime
             * @property {google.protobuf.ITimestamp|null} [modificationTime] TableStats modificationTime
             */

            /**
             * Constructs a new TableStats.
             * @memberof Ydb.Table
             * @classdesc Represents a TableStats.
             * @implements ITableStats
             * @constructor
             * @param {Ydb.Table.ITableStats=} [properties] Properties to set
             */
            function TableStats(properties) {
                this.partitionStats = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableStats partitionStats.
             * @member {Array.<Ydb.Table.IPartitionStats>} partitionStats
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.partitionStats = $util.emptyArray;

            /**
             * TableStats rowsEstimate.
             * @member {number|Long} rowsEstimate
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.rowsEstimate = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TableStats storeSize.
             * @member {number|Long} storeSize
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.storeSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TableStats partitions.
             * @member {number|Long} partitions
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.partitions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TableStats creationTime.
             * @member {google.protobuf.ITimestamp|null|undefined} creationTime
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.creationTime = null;

            /**
             * TableStats modificationTime.
             * @member {google.protobuf.ITimestamp|null|undefined} modificationTime
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.modificationTime = null;

            /**
             * Creates a new TableStats instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Ydb.Table.ITableStats=} [properties] Properties to set
             * @returns {Ydb.Table.TableStats} TableStats instance
             */
            TableStats.create = function create(properties) {
                return new TableStats(properties);
            };

            /**
             * Encodes the specified TableStats message. Does not implicitly {@link Ydb.Table.TableStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Ydb.Table.ITableStats} message TableStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.partitionStats != null && message.partitionStats.length)
                    for (var i = 0; i < message.partitionStats.length; ++i)
                        $root.Ydb.Table.PartitionStats.encode(message.partitionStats[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.rowsEstimate);
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.storeSize);
                if (message.partitions != null && message.hasOwnProperty("partitions"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.partitions);
                if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                    $root.google.protobuf.Timestamp.encode(message.creationTime, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.modificationTime != null && message.hasOwnProperty("modificationTime"))
                    $root.google.protobuf.Timestamp.encode(message.modificationTime, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableStats message, length delimited. Does not implicitly {@link Ydb.Table.TableStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Ydb.Table.ITableStats} message TableStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TableStats} TableStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TableStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.partitionStats && message.partitionStats.length))
                            message.partitionStats = [];
                        message.partitionStats.push($root.Ydb.Table.PartitionStats.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.rowsEstimate = reader.uint64();
                        break;
                    case 3:
                        message.storeSize = reader.uint64();
                        break;
                    case 4:
                        message.partitions = reader.uint64();
                        break;
                    case 5:
                        message.creationTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.modificationTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TableStats} TableStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableStats message.
             * @function verify
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.partitionStats != null && message.hasOwnProperty("partitionStats")) {
                    if (!Array.isArray(message.partitionStats))
                        return "partitionStats: array expected";
                    for (var i = 0; i < message.partitionStats.length; ++i) {
                        var error = $root.Ydb.Table.PartitionStats.verify(message.partitionStats[i]);
                        if (error)
                            return "partitionStats." + error;
                    }
                }
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    if (!$util.isInteger(message.rowsEstimate) && !(message.rowsEstimate && $util.isInteger(message.rowsEstimate.low) && $util.isInteger(message.rowsEstimate.high)))
                        return "rowsEstimate: integer|Long expected";
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    if (!$util.isInteger(message.storeSize) && !(message.storeSize && $util.isInteger(message.storeSize.low) && $util.isInteger(message.storeSize.high)))
                        return "storeSize: integer|Long expected";
                if (message.partitions != null && message.hasOwnProperty("partitions"))
                    if (!$util.isInteger(message.partitions) && !(message.partitions && $util.isInteger(message.partitions.low) && $util.isInteger(message.partitions.high)))
                        return "partitions: integer|Long expected";
                if (message.creationTime != null && message.hasOwnProperty("creationTime")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.creationTime);
                    if (error)
                        return "creationTime." + error;
                }
                if (message.modificationTime != null && message.hasOwnProperty("modificationTime")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.modificationTime);
                    if (error)
                        return "modificationTime." + error;
                }
                return null;
            };

            /**
             * Creates a TableStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TableStats} TableStats
             */
            TableStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TableStats)
                    return object;
                var message = new $root.Ydb.Table.TableStats();
                if (object.partitionStats) {
                    if (!Array.isArray(object.partitionStats))
                        throw TypeError(".Ydb.Table.TableStats.partitionStats: array expected");
                    message.partitionStats = [];
                    for (var i = 0; i < object.partitionStats.length; ++i) {
                        if (typeof object.partitionStats[i] !== "object")
                            throw TypeError(".Ydb.Table.TableStats.partitionStats: object expected");
                        message.partitionStats[i] = $root.Ydb.Table.PartitionStats.fromObject(object.partitionStats[i]);
                    }
                }
                if (object.rowsEstimate != null)
                    if ($util.Long)
                        (message.rowsEstimate = $util.Long.fromValue(object.rowsEstimate)).unsigned = true;
                    else if (typeof object.rowsEstimate === "string")
                        message.rowsEstimate = parseInt(object.rowsEstimate, 10);
                    else if (typeof object.rowsEstimate === "number")
                        message.rowsEstimate = object.rowsEstimate;
                    else if (typeof object.rowsEstimate === "object")
                        message.rowsEstimate = new $util.LongBits(object.rowsEstimate.low >>> 0, object.rowsEstimate.high >>> 0).toNumber(true);
                if (object.storeSize != null)
                    if ($util.Long)
                        (message.storeSize = $util.Long.fromValue(object.storeSize)).unsigned = true;
                    else if (typeof object.storeSize === "string")
                        message.storeSize = parseInt(object.storeSize, 10);
                    else if (typeof object.storeSize === "number")
                        message.storeSize = object.storeSize;
                    else if (typeof object.storeSize === "object")
                        message.storeSize = new $util.LongBits(object.storeSize.low >>> 0, object.storeSize.high >>> 0).toNumber(true);
                if (object.partitions != null)
                    if ($util.Long)
                        (message.partitions = $util.Long.fromValue(object.partitions)).unsigned = true;
                    else if (typeof object.partitions === "string")
                        message.partitions = parseInt(object.partitions, 10);
                    else if (typeof object.partitions === "number")
                        message.partitions = object.partitions;
                    else if (typeof object.partitions === "object")
                        message.partitions = new $util.LongBits(object.partitions.low >>> 0, object.partitions.high >>> 0).toNumber(true);
                if (object.creationTime != null) {
                    if (typeof object.creationTime !== "object")
                        throw TypeError(".Ydb.Table.TableStats.creationTime: object expected");
                    message.creationTime = $root.google.protobuf.Timestamp.fromObject(object.creationTime);
                }
                if (object.modificationTime != null) {
                    if (typeof object.modificationTime !== "object")
                        throw TypeError(".Ydb.Table.TableStats.modificationTime: object expected");
                    message.modificationTime = $root.google.protobuf.Timestamp.fromObject(object.modificationTime);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Ydb.Table.TableStats} message TableStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.partitionStats = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.rowsEstimate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowsEstimate = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.storeSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.storeSize = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.partitions = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.partitions = options.longs === String ? "0" : 0;
                    object.creationTime = null;
                    object.modificationTime = null;
                }
                if (message.partitionStats && message.partitionStats.length) {
                    object.partitionStats = [];
                    for (var j = 0; j < message.partitionStats.length; ++j)
                        object.partitionStats[j] = $root.Ydb.Table.PartitionStats.toObject(message.partitionStats[j], options);
                }
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    if (typeof message.rowsEstimate === "number")
                        object.rowsEstimate = options.longs === String ? String(message.rowsEstimate) : message.rowsEstimate;
                    else
                        object.rowsEstimate = options.longs === String ? $util.Long.prototype.toString.call(message.rowsEstimate) : options.longs === Number ? new $util.LongBits(message.rowsEstimate.low >>> 0, message.rowsEstimate.high >>> 0).toNumber(true) : message.rowsEstimate;
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    if (typeof message.storeSize === "number")
                        object.storeSize = options.longs === String ? String(message.storeSize) : message.storeSize;
                    else
                        object.storeSize = options.longs === String ? $util.Long.prototype.toString.call(message.storeSize) : options.longs === Number ? new $util.LongBits(message.storeSize.low >>> 0, message.storeSize.high >>> 0).toNumber(true) : message.storeSize;
                if (message.partitions != null && message.hasOwnProperty("partitions"))
                    if (typeof message.partitions === "number")
                        object.partitions = options.longs === String ? String(message.partitions) : message.partitions;
                    else
                        object.partitions = options.longs === String ? $util.Long.prototype.toString.call(message.partitions) : options.longs === Number ? new $util.LongBits(message.partitions.low >>> 0, message.partitions.high >>> 0).toNumber(true) : message.partitions;
                if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                    object.creationTime = $root.google.protobuf.Timestamp.toObject(message.creationTime, options);
                if (message.modificationTime != null && message.hasOwnProperty("modificationTime"))
                    object.modificationTime = $root.google.protobuf.Timestamp.toObject(message.modificationTime, options);
                return object;
            };

            /**
             * Converts this TableStats to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TableStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableStats;
        })();

        Table.PartitioningPolicy = (function() {

            /**
             * Properties of a PartitioningPolicy.
             * @memberof Ydb.Table
             * @interface IPartitioningPolicy
             * @property {string|null} [presetName] PartitioningPolicy presetName
             * @property {Ydb.Table.PartitioningPolicy.AutoPartitioningPolicy|null} [autoPartitioning] PartitioningPolicy autoPartitioning
             * @property {number|Long|null} [uniformPartitions] PartitioningPolicy uniformPartitions
             * @property {Ydb.Table.IExplicitPartitions|null} [explicitPartitions] PartitioningPolicy explicitPartitions
             */

            /**
             * Constructs a new PartitioningPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a PartitioningPolicy.
             * @implements IPartitioningPolicy
             * @constructor
             * @param {Ydb.Table.IPartitioningPolicy=} [properties] Properties to set
             */
            function PartitioningPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PartitioningPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            PartitioningPolicy.prototype.presetName = "";

            /**
             * PartitioningPolicy autoPartitioning.
             * @member {Ydb.Table.PartitioningPolicy.AutoPartitioningPolicy} autoPartitioning
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            PartitioningPolicy.prototype.autoPartitioning = 0;

            /**
             * PartitioningPolicy uniformPartitions.
             * @member {number|Long} uniformPartitions
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            PartitioningPolicy.prototype.uniformPartitions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PartitioningPolicy explicitPartitions.
             * @member {Ydb.Table.IExplicitPartitions|null|undefined} explicitPartitions
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            PartitioningPolicy.prototype.explicitPartitions = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * PartitioningPolicy partitions.
             * @member {"uniformPartitions"|"explicitPartitions"|undefined} partitions
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            Object.defineProperty(PartitioningPolicy.prototype, "partitions", {
                get: $util.oneOfGetter($oneOfFields = ["uniformPartitions", "explicitPartitions"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PartitioningPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Ydb.Table.IPartitioningPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.PartitioningPolicy} PartitioningPolicy instance
             */
            PartitioningPolicy.create = function create(properties) {
                return new PartitioningPolicy(properties);
            };

            /**
             * Encodes the specified PartitioningPolicy message. Does not implicitly {@link Ydb.Table.PartitioningPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Ydb.Table.IPartitioningPolicy} message PartitioningPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                if (message.autoPartitioning != null && message.hasOwnProperty("autoPartitioning"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.autoPartitioning);
                if (message.uniformPartitions != null && message.hasOwnProperty("uniformPartitions"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.uniformPartitions);
                if (message.explicitPartitions != null && message.hasOwnProperty("explicitPartitions"))
                    $root.Ydb.Table.ExplicitPartitions.encode(message.explicitPartitions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PartitioningPolicy message, length delimited. Does not implicitly {@link Ydb.Table.PartitioningPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Ydb.Table.IPartitioningPolicy} message PartitioningPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PartitioningPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PartitioningPolicy} PartitioningPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PartitioningPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    case 2:
                        message.autoPartitioning = reader.int32();
                        break;
                    case 3:
                        message.uniformPartitions = reader.uint64();
                        break;
                    case 4:
                        message.explicitPartitions = $root.Ydb.Table.ExplicitPartitions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PartitioningPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PartitioningPolicy} PartitioningPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PartitioningPolicy message.
             * @function verify
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PartitioningPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                if (message.autoPartitioning != null && message.hasOwnProperty("autoPartitioning"))
                    switch (message.autoPartitioning) {
                    default:
                        return "autoPartitioning: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.uniformPartitions != null && message.hasOwnProperty("uniformPartitions")) {
                    properties.partitions = 1;
                    if (!$util.isInteger(message.uniformPartitions) && !(message.uniformPartitions && $util.isInteger(message.uniformPartitions.low) && $util.isInteger(message.uniformPartitions.high)))
                        return "uniformPartitions: integer|Long expected";
                }
                if (message.explicitPartitions != null && message.hasOwnProperty("explicitPartitions")) {
                    if (properties.partitions === 1)
                        return "partitions: multiple values";
                    properties.partitions = 1;
                    {
                        var error = $root.Ydb.Table.ExplicitPartitions.verify(message.explicitPartitions);
                        if (error)
                            return "explicitPartitions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PartitioningPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PartitioningPolicy} PartitioningPolicy
             */
            PartitioningPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PartitioningPolicy)
                    return object;
                var message = new $root.Ydb.Table.PartitioningPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                switch (object.autoPartitioning) {
                case "AUTO_PARTITIONING_POLICY_UNSPECIFIED":
                case 0:
                    message.autoPartitioning = 0;
                    break;
                case "DISABLED":
                case 1:
                    message.autoPartitioning = 1;
                    break;
                case "AUTO_SPLIT":
                case 2:
                    message.autoPartitioning = 2;
                    break;
                case "AUTO_SPLIT_MERGE":
                case 3:
                    message.autoPartitioning = 3;
                    break;
                }
                if (object.uniformPartitions != null)
                    if ($util.Long)
                        (message.uniformPartitions = $util.Long.fromValue(object.uniformPartitions)).unsigned = true;
                    else if (typeof object.uniformPartitions === "string")
                        message.uniformPartitions = parseInt(object.uniformPartitions, 10);
                    else if (typeof object.uniformPartitions === "number")
                        message.uniformPartitions = object.uniformPartitions;
                    else if (typeof object.uniformPartitions === "object")
                        message.uniformPartitions = new $util.LongBits(object.uniformPartitions.low >>> 0, object.uniformPartitions.high >>> 0).toNumber(true);
                if (object.explicitPartitions != null) {
                    if (typeof object.explicitPartitions !== "object")
                        throw TypeError(".Ydb.Table.PartitioningPolicy.explicitPartitions: object expected");
                    message.explicitPartitions = $root.Ydb.Table.ExplicitPartitions.fromObject(object.explicitPartitions);
                }
                return message;
            };

            /**
             * Creates a plain object from a PartitioningPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Ydb.Table.PartitioningPolicy} message PartitioningPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PartitioningPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.presetName = "";
                    object.autoPartitioning = options.enums === String ? "AUTO_PARTITIONING_POLICY_UNSPECIFIED" : 0;
                }
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                if (message.autoPartitioning != null && message.hasOwnProperty("autoPartitioning"))
                    object.autoPartitioning = options.enums === String ? $root.Ydb.Table.PartitioningPolicy.AutoPartitioningPolicy[message.autoPartitioning] : message.autoPartitioning;
                if (message.uniformPartitions != null && message.hasOwnProperty("uniformPartitions")) {
                    if (typeof message.uniformPartitions === "number")
                        object.uniformPartitions = options.longs === String ? String(message.uniformPartitions) : message.uniformPartitions;
                    else
                        object.uniformPartitions = options.longs === String ? $util.Long.prototype.toString.call(message.uniformPartitions) : options.longs === Number ? new $util.LongBits(message.uniformPartitions.low >>> 0, message.uniformPartitions.high >>> 0).toNumber(true) : message.uniformPartitions;
                    if (options.oneofs)
                        object.partitions = "uniformPartitions";
                }
                if (message.explicitPartitions != null && message.hasOwnProperty("explicitPartitions")) {
                    object.explicitPartitions = $root.Ydb.Table.ExplicitPartitions.toObject(message.explicitPartitions, options);
                    if (options.oneofs)
                        object.partitions = "explicitPartitions";
                }
                return object;
            };

            /**
             * Converts this PartitioningPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PartitioningPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * AutoPartitioningPolicy enum.
             * @name Ydb.Table.PartitioningPolicy.AutoPartitioningPolicy
             * @enum {string}
             * @property {number} AUTO_PARTITIONING_POLICY_UNSPECIFIED=0 AUTO_PARTITIONING_POLICY_UNSPECIFIED value
             * @property {number} DISABLED=1 DISABLED value
             * @property {number} AUTO_SPLIT=2 AUTO_SPLIT value
             * @property {number} AUTO_SPLIT_MERGE=3 AUTO_SPLIT_MERGE value
             */
            PartitioningPolicy.AutoPartitioningPolicy = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "AUTO_PARTITIONING_POLICY_UNSPECIFIED"] = 0;
                values[valuesById[1] = "DISABLED"] = 1;
                values[valuesById[2] = "AUTO_SPLIT"] = 2;
                values[valuesById[3] = "AUTO_SPLIT_MERGE"] = 3;
                return values;
            })();

            return PartitioningPolicy;
        })();

        Table.ExecutionPolicy = (function() {

            /**
             * Properties of an ExecutionPolicy.
             * @memberof Ydb.Table
             * @interface IExecutionPolicy
             * @property {string|null} [presetName] ExecutionPolicy presetName
             */

            /**
             * Constructs a new ExecutionPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecutionPolicy.
             * @implements IExecutionPolicy
             * @constructor
             * @param {Ydb.Table.IExecutionPolicy=} [properties] Properties to set
             */
            function ExecutionPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.ExecutionPolicy
             * @instance
             */
            ExecutionPolicy.prototype.presetName = "";

            /**
             * Creates a new ExecutionPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Ydb.Table.IExecutionPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.ExecutionPolicy} ExecutionPolicy instance
             */
            ExecutionPolicy.create = function create(properties) {
                return new ExecutionPolicy(properties);
            };

            /**
             * Encodes the specified ExecutionPolicy message. Does not implicitly {@link Ydb.Table.ExecutionPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Ydb.Table.IExecutionPolicy} message ExecutionPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                return writer;
            };

            /**
             * Encodes the specified ExecutionPolicy message, length delimited. Does not implicitly {@link Ydb.Table.ExecutionPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Ydb.Table.IExecutionPolicy} message ExecutionPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecutionPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecutionPolicy} ExecutionPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecutionPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecutionPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecutionPolicy} ExecutionPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecutionPolicy message.
             * @function verify
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                return null;
            };

            /**
             * Creates an ExecutionPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecutionPolicy} ExecutionPolicy
             */
            ExecutionPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecutionPolicy)
                    return object;
                var message = new $root.Ydb.Table.ExecutionPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                return message;
            };

            /**
             * Creates a plain object from an ExecutionPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Ydb.Table.ExecutionPolicy} message ExecutionPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecutionPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.presetName = "";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                return object;
            };

            /**
             * Converts this ExecutionPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecutionPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecutionPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecutionPolicy;
        })();

        Table.ReplicationPolicy = (function() {

            /**
             * Properties of a ReplicationPolicy.
             * @memberof Ydb.Table
             * @interface IReplicationPolicy
             * @property {string|null} [presetName] ReplicationPolicy presetName
             * @property {number|null} [replicasCount] ReplicationPolicy replicasCount
             * @property {Ydb.FeatureFlag.Status|null} [createPerAvailabilityZone] ReplicationPolicy createPerAvailabilityZone
             * @property {Ydb.FeatureFlag.Status|null} [allowPromotion] ReplicationPolicy allowPromotion
             */

            /**
             * Constructs a new ReplicationPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a ReplicationPolicy.
             * @implements IReplicationPolicy
             * @constructor
             * @param {Ydb.Table.IReplicationPolicy=} [properties] Properties to set
             */
            function ReplicationPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplicationPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             */
            ReplicationPolicy.prototype.presetName = "";

            /**
             * ReplicationPolicy replicasCount.
             * @member {number} replicasCount
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             */
            ReplicationPolicy.prototype.replicasCount = 0;

            /**
             * ReplicationPolicy createPerAvailabilityZone.
             * @member {Ydb.FeatureFlag.Status} createPerAvailabilityZone
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             */
            ReplicationPolicy.prototype.createPerAvailabilityZone = 0;

            /**
             * ReplicationPolicy allowPromotion.
             * @member {Ydb.FeatureFlag.Status} allowPromotion
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             */
            ReplicationPolicy.prototype.allowPromotion = 0;

            /**
             * Creates a new ReplicationPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Ydb.Table.IReplicationPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.ReplicationPolicy} ReplicationPolicy instance
             */
            ReplicationPolicy.create = function create(properties) {
                return new ReplicationPolicy(properties);
            };

            /**
             * Encodes the specified ReplicationPolicy message. Does not implicitly {@link Ydb.Table.ReplicationPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Ydb.Table.IReplicationPolicy} message ReplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                if (message.replicasCount != null && message.hasOwnProperty("replicasCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.replicasCount);
                if (message.createPerAvailabilityZone != null && message.hasOwnProperty("createPerAvailabilityZone"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.createPerAvailabilityZone);
                if (message.allowPromotion != null && message.hasOwnProperty("allowPromotion"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.allowPromotion);
                return writer;
            };

            /**
             * Encodes the specified ReplicationPolicy message, length delimited. Does not implicitly {@link Ydb.Table.ReplicationPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Ydb.Table.IReplicationPolicy} message ReplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplicationPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReplicationPolicy} ReplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReplicationPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    case 2:
                        message.replicasCount = reader.uint32();
                        break;
                    case 3:
                        message.createPerAvailabilityZone = reader.int32();
                        break;
                    case 4:
                        message.allowPromotion = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplicationPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReplicationPolicy} ReplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplicationPolicy message.
             * @function verify
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplicationPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                if (message.replicasCount != null && message.hasOwnProperty("replicasCount"))
                    if (!$util.isInteger(message.replicasCount))
                        return "replicasCount: integer expected";
                if (message.createPerAvailabilityZone != null && message.hasOwnProperty("createPerAvailabilityZone"))
                    switch (message.createPerAvailabilityZone) {
                    default:
                        return "createPerAvailabilityZone: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.allowPromotion != null && message.hasOwnProperty("allowPromotion"))
                    switch (message.allowPromotion) {
                    default:
                        return "allowPromotion: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a ReplicationPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReplicationPolicy} ReplicationPolicy
             */
            ReplicationPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReplicationPolicy)
                    return object;
                var message = new $root.Ydb.Table.ReplicationPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                if (object.replicasCount != null)
                    message.replicasCount = object.replicasCount >>> 0;
                switch (object.createPerAvailabilityZone) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.createPerAvailabilityZone = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.createPerAvailabilityZone = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.createPerAvailabilityZone = 2;
                    break;
                }
                switch (object.allowPromotion) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.allowPromotion = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.allowPromotion = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.allowPromotion = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ReplicationPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Ydb.Table.ReplicationPolicy} message ReplicationPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicationPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.presetName = "";
                    object.replicasCount = 0;
                    object.createPerAvailabilityZone = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    object.allowPromotion = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                if (message.replicasCount != null && message.hasOwnProperty("replicasCount"))
                    object.replicasCount = message.replicasCount;
                if (message.createPerAvailabilityZone != null && message.hasOwnProperty("createPerAvailabilityZone"))
                    object.createPerAvailabilityZone = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.createPerAvailabilityZone] : message.createPerAvailabilityZone;
                if (message.allowPromotion != null && message.hasOwnProperty("allowPromotion"))
                    object.allowPromotion = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.allowPromotion] : message.allowPromotion;
                return object;
            };

            /**
             * Converts this ReplicationPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplicationPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplicationPolicy;
        })();

        Table.CachingPolicy = (function() {

            /**
             * Properties of a CachingPolicy.
             * @memberof Ydb.Table
             * @interface ICachingPolicy
             * @property {string|null} [presetName] CachingPolicy presetName
             */

            /**
             * Constructs a new CachingPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a CachingPolicy.
             * @implements ICachingPolicy
             * @constructor
             * @param {Ydb.Table.ICachingPolicy=} [properties] Properties to set
             */
            function CachingPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CachingPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.CachingPolicy
             * @instance
             */
            CachingPolicy.prototype.presetName = "";

            /**
             * Creates a new CachingPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Ydb.Table.ICachingPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.CachingPolicy} CachingPolicy instance
             */
            CachingPolicy.create = function create(properties) {
                return new CachingPolicy(properties);
            };

            /**
             * Encodes the specified CachingPolicy message. Does not implicitly {@link Ydb.Table.CachingPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Ydb.Table.ICachingPolicy} message CachingPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CachingPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                return writer;
            };

            /**
             * Encodes the specified CachingPolicy message, length delimited. Does not implicitly {@link Ydb.Table.CachingPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Ydb.Table.ICachingPolicy} message CachingPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CachingPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CachingPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CachingPolicy} CachingPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CachingPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CachingPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CachingPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CachingPolicy} CachingPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CachingPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CachingPolicy message.
             * @function verify
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CachingPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                return null;
            };

            /**
             * Creates a CachingPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CachingPolicy} CachingPolicy
             */
            CachingPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CachingPolicy)
                    return object;
                var message = new $root.Ydb.Table.CachingPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                return message;
            };

            /**
             * Creates a plain object from a CachingPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Ydb.Table.CachingPolicy} message CachingPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CachingPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.presetName = "";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                return object;
            };

            /**
             * Converts this CachingPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CachingPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CachingPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CachingPolicy;
        })();

        Table.TableProfile = (function() {

            /**
             * Properties of a TableProfile.
             * @memberof Ydb.Table
             * @interface ITableProfile
             * @property {string|null} [presetName] TableProfile presetName
             * @property {Ydb.Table.IStoragePolicy|null} [storagePolicy] TableProfile storagePolicy
             * @property {Ydb.Table.ICompactionPolicy|null} [compactionPolicy] TableProfile compactionPolicy
             * @property {Ydb.Table.IPartitioningPolicy|null} [partitioningPolicy] TableProfile partitioningPolicy
             * @property {Ydb.Table.IExecutionPolicy|null} [executionPolicy] TableProfile executionPolicy
             * @property {Ydb.Table.IReplicationPolicy|null} [replicationPolicy] TableProfile replicationPolicy
             * @property {Ydb.Table.ICachingPolicy|null} [cachingPolicy] TableProfile cachingPolicy
             */

            /**
             * Constructs a new TableProfile.
             * @memberof Ydb.Table
             * @classdesc Represents a TableProfile.
             * @implements ITableProfile
             * @constructor
             * @param {Ydb.Table.ITableProfile=} [properties] Properties to set
             */
            function TableProfile(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableProfile presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.presetName = "";

            /**
             * TableProfile storagePolicy.
             * @member {Ydb.Table.IStoragePolicy|null|undefined} storagePolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.storagePolicy = null;

            /**
             * TableProfile compactionPolicy.
             * @member {Ydb.Table.ICompactionPolicy|null|undefined} compactionPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.compactionPolicy = null;

            /**
             * TableProfile partitioningPolicy.
             * @member {Ydb.Table.IPartitioningPolicy|null|undefined} partitioningPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.partitioningPolicy = null;

            /**
             * TableProfile executionPolicy.
             * @member {Ydb.Table.IExecutionPolicy|null|undefined} executionPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.executionPolicy = null;

            /**
             * TableProfile replicationPolicy.
             * @member {Ydb.Table.IReplicationPolicy|null|undefined} replicationPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.replicationPolicy = null;

            /**
             * TableProfile cachingPolicy.
             * @member {Ydb.Table.ICachingPolicy|null|undefined} cachingPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.cachingPolicy = null;

            /**
             * Creates a new TableProfile instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Ydb.Table.ITableProfile=} [properties] Properties to set
             * @returns {Ydb.Table.TableProfile} TableProfile instance
             */
            TableProfile.create = function create(properties) {
                return new TableProfile(properties);
            };

            /**
             * Encodes the specified TableProfile message. Does not implicitly {@link Ydb.Table.TableProfile.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Ydb.Table.ITableProfile} message TableProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableProfile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                if (message.storagePolicy != null && message.hasOwnProperty("storagePolicy"))
                    $root.Ydb.Table.StoragePolicy.encode(message.storagePolicy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.compactionPolicy != null && message.hasOwnProperty("compactionPolicy"))
                    $root.Ydb.Table.CompactionPolicy.encode(message.compactionPolicy, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.partitioningPolicy != null && message.hasOwnProperty("partitioningPolicy"))
                    $root.Ydb.Table.PartitioningPolicy.encode(message.partitioningPolicy, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.executionPolicy != null && message.hasOwnProperty("executionPolicy"))
                    $root.Ydb.Table.ExecutionPolicy.encode(message.executionPolicy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.replicationPolicy != null && message.hasOwnProperty("replicationPolicy"))
                    $root.Ydb.Table.ReplicationPolicy.encode(message.replicationPolicy, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.cachingPolicy != null && message.hasOwnProperty("cachingPolicy"))
                    $root.Ydb.Table.CachingPolicy.encode(message.cachingPolicy, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableProfile message, length delimited. Does not implicitly {@link Ydb.Table.TableProfile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Ydb.Table.ITableProfile} message TableProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableProfile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableProfile message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TableProfile} TableProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableProfile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TableProfile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    case 2:
                        message.storagePolicy = $root.Ydb.Table.StoragePolicy.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.compactionPolicy = $root.Ydb.Table.CompactionPolicy.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.partitioningPolicy = $root.Ydb.Table.PartitioningPolicy.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.executionPolicy = $root.Ydb.Table.ExecutionPolicy.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.replicationPolicy = $root.Ydb.Table.ReplicationPolicy.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.cachingPolicy = $root.Ydb.Table.CachingPolicy.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableProfile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TableProfile} TableProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableProfile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableProfile message.
             * @function verify
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableProfile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                if (message.storagePolicy != null && message.hasOwnProperty("storagePolicy")) {
                    var error = $root.Ydb.Table.StoragePolicy.verify(message.storagePolicy);
                    if (error)
                        return "storagePolicy." + error;
                }
                if (message.compactionPolicy != null && message.hasOwnProperty("compactionPolicy")) {
                    var error = $root.Ydb.Table.CompactionPolicy.verify(message.compactionPolicy);
                    if (error)
                        return "compactionPolicy." + error;
                }
                if (message.partitioningPolicy != null && message.hasOwnProperty("partitioningPolicy")) {
                    var error = $root.Ydb.Table.PartitioningPolicy.verify(message.partitioningPolicy);
                    if (error)
                        return "partitioningPolicy." + error;
                }
                if (message.executionPolicy != null && message.hasOwnProperty("executionPolicy")) {
                    var error = $root.Ydb.Table.ExecutionPolicy.verify(message.executionPolicy);
                    if (error)
                        return "executionPolicy." + error;
                }
                if (message.replicationPolicy != null && message.hasOwnProperty("replicationPolicy")) {
                    var error = $root.Ydb.Table.ReplicationPolicy.verify(message.replicationPolicy);
                    if (error)
                        return "replicationPolicy." + error;
                }
                if (message.cachingPolicy != null && message.hasOwnProperty("cachingPolicy")) {
                    var error = $root.Ydb.Table.CachingPolicy.verify(message.cachingPolicy);
                    if (error)
                        return "cachingPolicy." + error;
                }
                return null;
            };

            /**
             * Creates a TableProfile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TableProfile} TableProfile
             */
            TableProfile.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TableProfile)
                    return object;
                var message = new $root.Ydb.Table.TableProfile();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                if (object.storagePolicy != null) {
                    if (typeof object.storagePolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.storagePolicy: object expected");
                    message.storagePolicy = $root.Ydb.Table.StoragePolicy.fromObject(object.storagePolicy);
                }
                if (object.compactionPolicy != null) {
                    if (typeof object.compactionPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.compactionPolicy: object expected");
                    message.compactionPolicy = $root.Ydb.Table.CompactionPolicy.fromObject(object.compactionPolicy);
                }
                if (object.partitioningPolicy != null) {
                    if (typeof object.partitioningPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.partitioningPolicy: object expected");
                    message.partitioningPolicy = $root.Ydb.Table.PartitioningPolicy.fromObject(object.partitioningPolicy);
                }
                if (object.executionPolicy != null) {
                    if (typeof object.executionPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.executionPolicy: object expected");
                    message.executionPolicy = $root.Ydb.Table.ExecutionPolicy.fromObject(object.executionPolicy);
                }
                if (object.replicationPolicy != null) {
                    if (typeof object.replicationPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.replicationPolicy: object expected");
                    message.replicationPolicy = $root.Ydb.Table.ReplicationPolicy.fromObject(object.replicationPolicy);
                }
                if (object.cachingPolicy != null) {
                    if (typeof object.cachingPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.cachingPolicy: object expected");
                    message.cachingPolicy = $root.Ydb.Table.CachingPolicy.fromObject(object.cachingPolicy);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableProfile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Ydb.Table.TableProfile} message TableProfile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableProfile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.presetName = "";
                    object.storagePolicy = null;
                    object.compactionPolicy = null;
                    object.partitioningPolicy = null;
                    object.executionPolicy = null;
                    object.replicationPolicy = null;
                    object.cachingPolicy = null;
                }
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                if (message.storagePolicy != null && message.hasOwnProperty("storagePolicy"))
                    object.storagePolicy = $root.Ydb.Table.StoragePolicy.toObject(message.storagePolicy, options);
                if (message.compactionPolicy != null && message.hasOwnProperty("compactionPolicy"))
                    object.compactionPolicy = $root.Ydb.Table.CompactionPolicy.toObject(message.compactionPolicy, options);
                if (message.partitioningPolicy != null && message.hasOwnProperty("partitioningPolicy"))
                    object.partitioningPolicy = $root.Ydb.Table.PartitioningPolicy.toObject(message.partitioningPolicy, options);
                if (message.executionPolicy != null && message.hasOwnProperty("executionPolicy"))
                    object.executionPolicy = $root.Ydb.Table.ExecutionPolicy.toObject(message.executionPolicy, options);
                if (message.replicationPolicy != null && message.hasOwnProperty("replicationPolicy"))
                    object.replicationPolicy = $root.Ydb.Table.ReplicationPolicy.toObject(message.replicationPolicy, options);
                if (message.cachingPolicy != null && message.hasOwnProperty("cachingPolicy"))
                    object.cachingPolicy = $root.Ydb.Table.CachingPolicy.toObject(message.cachingPolicy, options);
                return object;
            };

            /**
             * Converts this TableProfile to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TableProfile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableProfile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableProfile;
        })();

        Table.ColumnMeta = (function() {

            /**
             * Properties of a ColumnMeta.
             * @memberof Ydb.Table
             * @interface IColumnMeta
             * @property {string|null} [name] ColumnMeta name
             * @property {Ydb.IType|null} [type] ColumnMeta type
             * @property {string|null} [family] ColumnMeta family
             */

            /**
             * Constructs a new ColumnMeta.
             * @memberof Ydb.Table
             * @classdesc Represents a ColumnMeta.
             * @implements IColumnMeta
             * @constructor
             * @param {Ydb.Table.IColumnMeta=} [properties] Properties to set
             */
            function ColumnMeta(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ColumnMeta name.
             * @member {string} name
             * @memberof Ydb.Table.ColumnMeta
             * @instance
             */
            ColumnMeta.prototype.name = "";

            /**
             * ColumnMeta type.
             * @member {Ydb.IType|null|undefined} type
             * @memberof Ydb.Table.ColumnMeta
             * @instance
             */
            ColumnMeta.prototype.type = null;

            /**
             * ColumnMeta family.
             * @member {string} family
             * @memberof Ydb.Table.ColumnMeta
             * @instance
             */
            ColumnMeta.prototype.family = "";

            /**
             * Creates a new ColumnMeta instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Ydb.Table.IColumnMeta=} [properties] Properties to set
             * @returns {Ydb.Table.ColumnMeta} ColumnMeta instance
             */
            ColumnMeta.create = function create(properties) {
                return new ColumnMeta(properties);
            };

            /**
             * Encodes the specified ColumnMeta message. Does not implicitly {@link Ydb.Table.ColumnMeta.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Ydb.Table.IColumnMeta} message ColumnMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && message.hasOwnProperty("type"))
                    $root.Ydb.Type.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.family != null && message.hasOwnProperty("family"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.family);
                return writer;
            };

            /**
             * Encodes the specified ColumnMeta message, length delimited. Does not implicitly {@link Ydb.Table.ColumnMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Ydb.Table.IColumnMeta} message ColumnMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ColumnMeta message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ColumnMeta} ColumnMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ColumnMeta();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = $root.Ydb.Type.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.family = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ColumnMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ColumnMeta} ColumnMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ColumnMeta message.
             * @function verify
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type")) {
                    var error = $root.Ydb.Type.verify(message.type);
                    if (error)
                        return "type." + error;
                }
                if (message.family != null && message.hasOwnProperty("family"))
                    if (!$util.isString(message.family))
                        return "family: string expected";
                return null;
            };

            /**
             * Creates a ColumnMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ColumnMeta} ColumnMeta
             */
            ColumnMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ColumnMeta)
                    return object;
                var message = new $root.Ydb.Table.ColumnMeta();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.type != null) {
                    if (typeof object.type !== "object")
                        throw TypeError(".Ydb.Table.ColumnMeta.type: object expected");
                    message.type = $root.Ydb.Type.fromObject(object.type);
                }
                if (object.family != null)
                    message.family = String(object.family);
                return message;
            };

            /**
             * Creates a plain object from a ColumnMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Ydb.Table.ColumnMeta} message ColumnMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = null;
                    object.family = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = $root.Ydb.Type.toObject(message.type, options);
                if (message.family != null && message.hasOwnProperty("family"))
                    object.family = message.family;
                return object;
            };

            /**
             * Converts this ColumnMeta to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ColumnMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ColumnMeta;
        })();

        Table.DateTypeColumnModeSettings = (function() {

            /**
             * Properties of a DateTypeColumnModeSettings.
             * @memberof Ydb.Table
             * @interface IDateTypeColumnModeSettings
             * @property {string|null} [columnName] DateTypeColumnModeSettings columnName
             * @property {number|null} [expireAfterSeconds] DateTypeColumnModeSettings expireAfterSeconds
             */

            /**
             * Constructs a new DateTypeColumnModeSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a DateTypeColumnModeSettings.
             * @implements IDateTypeColumnModeSettings
             * @constructor
             * @param {Ydb.Table.IDateTypeColumnModeSettings=} [properties] Properties to set
             */
            function DateTypeColumnModeSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DateTypeColumnModeSettings columnName.
             * @member {string} columnName
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @instance
             */
            DateTypeColumnModeSettings.prototype.columnName = "";

            /**
             * DateTypeColumnModeSettings expireAfterSeconds.
             * @member {number} expireAfterSeconds
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @instance
             */
            DateTypeColumnModeSettings.prototype.expireAfterSeconds = 0;

            /**
             * Creates a new DateTypeColumnModeSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Ydb.Table.IDateTypeColumnModeSettings=} [properties] Properties to set
             * @returns {Ydb.Table.DateTypeColumnModeSettings} DateTypeColumnModeSettings instance
             */
            DateTypeColumnModeSettings.create = function create(properties) {
                return new DateTypeColumnModeSettings(properties);
            };

            /**
             * Encodes the specified DateTypeColumnModeSettings message. Does not implicitly {@link Ydb.Table.DateTypeColumnModeSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Ydb.Table.IDateTypeColumnModeSettings} message DateTypeColumnModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DateTypeColumnModeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.columnName != null && message.hasOwnProperty("columnName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.columnName);
                if (message.expireAfterSeconds != null && message.hasOwnProperty("expireAfterSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.expireAfterSeconds);
                return writer;
            };

            /**
             * Encodes the specified DateTypeColumnModeSettings message, length delimited. Does not implicitly {@link Ydb.Table.DateTypeColumnModeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Ydb.Table.IDateTypeColumnModeSettings} message DateTypeColumnModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DateTypeColumnModeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DateTypeColumnModeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DateTypeColumnModeSettings} DateTypeColumnModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DateTypeColumnModeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DateTypeColumnModeSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.columnName = reader.string();
                        break;
                    case 2:
                        message.expireAfterSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DateTypeColumnModeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DateTypeColumnModeSettings} DateTypeColumnModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DateTypeColumnModeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DateTypeColumnModeSettings message.
             * @function verify
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DateTypeColumnModeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.columnName != null && message.hasOwnProperty("columnName"))
                    if (!$util.isString(message.columnName))
                        return "columnName: string expected";
                if (message.expireAfterSeconds != null && message.hasOwnProperty("expireAfterSeconds"))
                    if (!$util.isInteger(message.expireAfterSeconds))
                        return "expireAfterSeconds: integer expected";
                return null;
            };

            /**
             * Creates a DateTypeColumnModeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DateTypeColumnModeSettings} DateTypeColumnModeSettings
             */
            DateTypeColumnModeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DateTypeColumnModeSettings)
                    return object;
                var message = new $root.Ydb.Table.DateTypeColumnModeSettings();
                if (object.columnName != null)
                    message.columnName = String(object.columnName);
                if (object.expireAfterSeconds != null)
                    message.expireAfterSeconds = object.expireAfterSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DateTypeColumnModeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Ydb.Table.DateTypeColumnModeSettings} message DateTypeColumnModeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DateTypeColumnModeSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.columnName = "";
                    object.expireAfterSeconds = 0;
                }
                if (message.columnName != null && message.hasOwnProperty("columnName"))
                    object.columnName = message.columnName;
                if (message.expireAfterSeconds != null && message.hasOwnProperty("expireAfterSeconds"))
                    object.expireAfterSeconds = message.expireAfterSeconds;
                return object;
            };

            /**
             * Converts this DateTypeColumnModeSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DateTypeColumnModeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DateTypeColumnModeSettings;
        })();

        Table.TtlSettings = (function() {

            /**
             * Properties of a TtlSettings.
             * @memberof Ydb.Table
             * @interface ITtlSettings
             * @property {Ydb.Table.IDateTypeColumnModeSettings|null} [dateTypeColumn] TtlSettings dateTypeColumn
             */

            /**
             * Constructs a new TtlSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a TtlSettings.
             * @implements ITtlSettings
             * @constructor
             * @param {Ydb.Table.ITtlSettings=} [properties] Properties to set
             */
            function TtlSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TtlSettings dateTypeColumn.
             * @member {Ydb.Table.IDateTypeColumnModeSettings|null|undefined} dateTypeColumn
             * @memberof Ydb.Table.TtlSettings
             * @instance
             */
            TtlSettings.prototype.dateTypeColumn = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TtlSettings mode.
             * @member {"dateTypeColumn"|undefined} mode
             * @memberof Ydb.Table.TtlSettings
             * @instance
             */
            Object.defineProperty(TtlSettings.prototype, "mode", {
                get: $util.oneOfGetter($oneOfFields = ["dateTypeColumn"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TtlSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Ydb.Table.ITtlSettings=} [properties] Properties to set
             * @returns {Ydb.Table.TtlSettings} TtlSettings instance
             */
            TtlSettings.create = function create(properties) {
                return new TtlSettings(properties);
            };

            /**
             * Encodes the specified TtlSettings message. Does not implicitly {@link Ydb.Table.TtlSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Ydb.Table.ITtlSettings} message TtlSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TtlSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dateTypeColumn != null && message.hasOwnProperty("dateTypeColumn"))
                    $root.Ydb.Table.DateTypeColumnModeSettings.encode(message.dateTypeColumn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TtlSettings message, length delimited. Does not implicitly {@link Ydb.Table.TtlSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Ydb.Table.ITtlSettings} message TtlSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TtlSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TtlSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TtlSettings} TtlSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TtlSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TtlSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dateTypeColumn = $root.Ydb.Table.DateTypeColumnModeSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TtlSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TtlSettings} TtlSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TtlSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TtlSettings message.
             * @function verify
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TtlSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.dateTypeColumn != null && message.hasOwnProperty("dateTypeColumn")) {
                    properties.mode = 1;
                    {
                        var error = $root.Ydb.Table.DateTypeColumnModeSettings.verify(message.dateTypeColumn);
                        if (error)
                            return "dateTypeColumn." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TtlSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TtlSettings} TtlSettings
             */
            TtlSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TtlSettings)
                    return object;
                var message = new $root.Ydb.Table.TtlSettings();
                if (object.dateTypeColumn != null) {
                    if (typeof object.dateTypeColumn !== "object")
                        throw TypeError(".Ydb.Table.TtlSettings.dateTypeColumn: object expected");
                    message.dateTypeColumn = $root.Ydb.Table.DateTypeColumnModeSettings.fromObject(object.dateTypeColumn);
                }
                return message;
            };

            /**
             * Creates a plain object from a TtlSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Ydb.Table.TtlSettings} message TtlSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TtlSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.dateTypeColumn != null && message.hasOwnProperty("dateTypeColumn")) {
                    object.dateTypeColumn = $root.Ydb.Table.DateTypeColumnModeSettings.toObject(message.dateTypeColumn, options);
                    if (options.oneofs)
                        object.mode = "dateTypeColumn";
                }
                return object;
            };

            /**
             * Converts this TtlSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TtlSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TtlSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TtlSettings;
        })();

        Table.CreateTableRequest = (function() {

            /**
             * Properties of a CreateTableRequest.
             * @memberof Ydb.Table
             * @interface ICreateTableRequest
             * @property {string|null} [sessionId] CreateTableRequest sessionId
             * @property {string|null} [path] CreateTableRequest path
             * @property {Array.<Ydb.Table.IColumnMeta>|null} [columns] CreateTableRequest columns
             * @property {Array.<string>|null} [primaryKey] CreateTableRequest primaryKey
             * @property {Ydb.Table.ITableProfile|null} [profile] CreateTableRequest profile
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CreateTableRequest operationParams
             * @property {Array.<Ydb.Table.ITableIndex>|null} [indexes] CreateTableRequest indexes
             * @property {Ydb.Table.ITtlSettings|null} [ttlSettings] CreateTableRequest ttlSettings
             */

            /**
             * Constructs a new CreateTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateTableRequest.
             * @implements ICreateTableRequest
             * @constructor
             * @param {Ydb.Table.ICreateTableRequest=} [properties] Properties to set
             */
            function CreateTableRequest(properties) {
                this.columns = [];
                this.primaryKey = [];
                this.indexes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.sessionId = "";

            /**
             * CreateTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.path = "";

            /**
             * CreateTableRequest columns.
             * @member {Array.<Ydb.Table.IColumnMeta>} columns
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.columns = $util.emptyArray;

            /**
             * CreateTableRequest primaryKey.
             * @member {Array.<string>} primaryKey
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.primaryKey = $util.emptyArray;

            /**
             * CreateTableRequest profile.
             * @member {Ydb.Table.ITableProfile|null|undefined} profile
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.profile = null;

            /**
             * CreateTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.operationParams = null;

            /**
             * CreateTableRequest indexes.
             * @member {Array.<Ydb.Table.ITableIndex>} indexes
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.indexes = $util.emptyArray;

            /**
             * CreateTableRequest ttlSettings.
             * @member {Ydb.Table.ITtlSettings|null|undefined} ttlSettings
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.ttlSettings = null;

            /**
             * Creates a new CreateTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Ydb.Table.ICreateTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CreateTableRequest} CreateTableRequest instance
             */
            CreateTableRequest.create = function create(properties) {
                return new CreateTableRequest(properties);
            };

            /**
             * Encodes the specified CreateTableRequest message. Does not implicitly {@link Ydb.Table.CreateTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Ydb.Table.ICreateTableRequest} message CreateTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.columns != null && message.columns.length)
                    for (var i = 0; i < message.columns.length; ++i)
                        $root.Ydb.Table.ColumnMeta.encode(message.columns[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.primaryKey != null && message.primaryKey.length)
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.primaryKey[i]);
                if (message.profile != null && message.hasOwnProperty("profile"))
                    $root.Ydb.Table.TableProfile.encode(message.profile, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.indexes != null && message.indexes.length)
                    for (var i = 0; i < message.indexes.length; ++i)
                        $root.Ydb.Table.TableIndex.encode(message.indexes[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings"))
                    $root.Ydb.Table.TtlSettings.encode(message.ttlSettings, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.CreateTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Ydb.Table.ICreateTableRequest} message CreateTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateTableRequest} CreateTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 3:
                        if (!(message.columns && message.columns.length))
                            message.columns = [];
                        message.columns.push($root.Ydb.Table.ColumnMeta.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.primaryKey && message.primaryKey.length))
                            message.primaryKey = [];
                        message.primaryKey.push(reader.string());
                        break;
                    case 5:
                        message.profile = $root.Ydb.Table.TableProfile.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 7:
                        if (!(message.indexes && message.indexes.length))
                            message.indexes = [];
                        message.indexes.push($root.Ydb.Table.TableIndex.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.ttlSettings = $root.Ydb.Table.TtlSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateTableRequest} CreateTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateTableRequest message.
             * @function verify
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (var i = 0; i < message.columns.length; ++i) {
                        var error = $root.Ydb.Table.ColumnMeta.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                if (message.primaryKey != null && message.hasOwnProperty("primaryKey")) {
                    if (!Array.isArray(message.primaryKey))
                        return "primaryKey: array expected";
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        if (!$util.isString(message.primaryKey[i]))
                            return "primaryKey: string[] expected";
                }
                if (message.profile != null && message.hasOwnProperty("profile")) {
                    var error = $root.Ydb.Table.TableProfile.verify(message.profile);
                    if (error)
                        return "profile." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.indexes != null && message.hasOwnProperty("indexes")) {
                    if (!Array.isArray(message.indexes))
                        return "indexes: array expected";
                    for (var i = 0; i < message.indexes.length; ++i) {
                        var error = $root.Ydb.Table.TableIndex.verify(message.indexes[i]);
                        if (error)
                            return "indexes." + error;
                    }
                }
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings")) {
                    var error = $root.Ydb.Table.TtlSettings.verify(message.ttlSettings);
                    if (error)
                        return "ttlSettings." + error;
                }
                return null;
            };

            /**
             * Creates a CreateTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateTableRequest} CreateTableRequest
             */
            CreateTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateTableRequest)
                    return object;
                var message = new $root.Ydb.Table.CreateTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".Ydb.Table.CreateTableRequest.columns: array expected");
                    message.columns = [];
                    for (var i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".Ydb.Table.CreateTableRequest.columns: object expected");
                        message.columns[i] = $root.Ydb.Table.ColumnMeta.fromObject(object.columns[i]);
                    }
                }
                if (object.primaryKey) {
                    if (!Array.isArray(object.primaryKey))
                        throw TypeError(".Ydb.Table.CreateTableRequest.primaryKey: array expected");
                    message.primaryKey = [];
                    for (var i = 0; i < object.primaryKey.length; ++i)
                        message.primaryKey[i] = String(object.primaryKey[i]);
                }
                if (object.profile != null) {
                    if (typeof object.profile !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.profile: object expected");
                    message.profile = $root.Ydb.Table.TableProfile.fromObject(object.profile);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.indexes) {
                    if (!Array.isArray(object.indexes))
                        throw TypeError(".Ydb.Table.CreateTableRequest.indexes: array expected");
                    message.indexes = [];
                    for (var i = 0; i < object.indexes.length; ++i) {
                        if (typeof object.indexes[i] !== "object")
                            throw TypeError(".Ydb.Table.CreateTableRequest.indexes: object expected");
                        message.indexes[i] = $root.Ydb.Table.TableIndex.fromObject(object.indexes[i]);
                    }
                }
                if (object.ttlSettings != null) {
                    if (typeof object.ttlSettings !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.ttlSettings: object expected");
                    message.ttlSettings = $root.Ydb.Table.TtlSettings.fromObject(object.ttlSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Ydb.Table.CreateTableRequest} message CreateTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.columns = [];
                    object.primaryKey = [];
                    object.indexes = [];
                }
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.profile = null;
                    object.operationParams = null;
                    object.ttlSettings = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (var j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.Ydb.Table.ColumnMeta.toObject(message.columns[j], options);
                }
                if (message.primaryKey && message.primaryKey.length) {
                    object.primaryKey = [];
                    for (var j = 0; j < message.primaryKey.length; ++j)
                        object.primaryKey[j] = message.primaryKey[j];
                }
                if (message.profile != null && message.hasOwnProperty("profile"))
                    object.profile = $root.Ydb.Table.TableProfile.toObject(message.profile, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.indexes && message.indexes.length) {
                    object.indexes = [];
                    for (var j = 0; j < message.indexes.length; ++j)
                        object.indexes[j] = $root.Ydb.Table.TableIndex.toObject(message.indexes[j], options);
                }
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings"))
                    object.ttlSettings = $root.Ydb.Table.TtlSettings.toObject(message.ttlSettings, options);
                return object;
            };

            /**
             * Converts this CreateTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateTableRequest;
        })();

        Table.CreateTableResponse = (function() {

            /**
             * Properties of a CreateTableResponse.
             * @memberof Ydb.Table
             * @interface ICreateTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CreateTableResponse operation
             */

            /**
             * Constructs a new CreateTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateTableResponse.
             * @implements ICreateTableResponse
             * @constructor
             * @param {Ydb.Table.ICreateTableResponse=} [properties] Properties to set
             */
            function CreateTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CreateTableResponse
             * @instance
             */
            CreateTableResponse.prototype.operation = null;

            /**
             * Creates a new CreateTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Ydb.Table.ICreateTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CreateTableResponse} CreateTableResponse instance
             */
            CreateTableResponse.create = function create(properties) {
                return new CreateTableResponse(properties);
            };

            /**
             * Encodes the specified CreateTableResponse message. Does not implicitly {@link Ydb.Table.CreateTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Ydb.Table.ICreateTableResponse} message CreateTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.CreateTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Ydb.Table.ICreateTableResponse} message CreateTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateTableResponse} CreateTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateTableResponse} CreateTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateTableResponse message.
             * @function verify
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CreateTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateTableResponse} CreateTableResponse
             */
            CreateTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateTableResponse)
                    return object;
                var message = new $root.Ydb.Table.CreateTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CreateTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Ydb.Table.CreateTableResponse} message CreateTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CreateTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateTableResponse;
        })();

        Table.DropTableRequest = (function() {

            /**
             * Properties of a DropTableRequest.
             * @memberof Ydb.Table
             * @interface IDropTableRequest
             * @property {string|null} [sessionId] DropTableRequest sessionId
             * @property {string|null} [path] DropTableRequest path
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DropTableRequest operationParams
             */

            /**
             * Constructs a new DropTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a DropTableRequest.
             * @implements IDropTableRequest
             * @constructor
             * @param {Ydb.Table.IDropTableRequest=} [properties] Properties to set
             */
            function DropTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DropTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.DropTableRequest
             * @instance
             */
            DropTableRequest.prototype.sessionId = "";

            /**
             * DropTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.DropTableRequest
             * @instance
             */
            DropTableRequest.prototype.path = "";

            /**
             * DropTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.DropTableRequest
             * @instance
             */
            DropTableRequest.prototype.operationParams = null;

            /**
             * Creates a new DropTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Ydb.Table.IDropTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.DropTableRequest} DropTableRequest instance
             */
            DropTableRequest.create = function create(properties) {
                return new DropTableRequest(properties);
            };

            /**
             * Encodes the specified DropTableRequest message. Does not implicitly {@link Ydb.Table.DropTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Ydb.Table.IDropTableRequest} message DropTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DropTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.DropTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Ydb.Table.IDropTableRequest} message DropTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DropTableRequest} DropTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DropTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 4:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DropTableRequest} DropTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropTableRequest message.
             * @function verify
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a DropTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DropTableRequest} DropTableRequest
             */
            DropTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DropTableRequest)
                    return object;
                var message = new $root.Ydb.Table.DropTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.DropTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DropTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Ydb.Table.DropTableRequest} message DropTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this DropTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DropTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropTableRequest;
        })();

        Table.DropTableResponse = (function() {

            /**
             * Properties of a DropTableResponse.
             * @memberof Ydb.Table
             * @interface IDropTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DropTableResponse operation
             */

            /**
             * Constructs a new DropTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a DropTableResponse.
             * @implements IDropTableResponse
             * @constructor
             * @param {Ydb.Table.IDropTableResponse=} [properties] Properties to set
             */
            function DropTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DropTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.DropTableResponse
             * @instance
             */
            DropTableResponse.prototype.operation = null;

            /**
             * Creates a new DropTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Ydb.Table.IDropTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.DropTableResponse} DropTableResponse instance
             */
            DropTableResponse.create = function create(properties) {
                return new DropTableResponse(properties);
            };

            /**
             * Encodes the specified DropTableResponse message. Does not implicitly {@link Ydb.Table.DropTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Ydb.Table.IDropTableResponse} message DropTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DropTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.DropTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Ydb.Table.IDropTableResponse} message DropTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DropTableResponse} DropTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DropTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DropTableResponse} DropTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropTableResponse message.
             * @function verify
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DropTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DropTableResponse} DropTableResponse
             */
            DropTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DropTableResponse)
                    return object;
                var message = new $root.Ydb.Table.DropTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.DropTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DropTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Ydb.Table.DropTableResponse} message DropTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DropTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DropTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropTableResponse;
        })();

        Table.AlterTableRequest = (function() {

            /**
             * Properties of an AlterTableRequest.
             * @memberof Ydb.Table
             * @interface IAlterTableRequest
             * @property {string|null} [sessionId] AlterTableRequest sessionId
             * @property {string|null} [path] AlterTableRequest path
             * @property {Array.<Ydb.Table.IColumnMeta>|null} [addColumns] AlterTableRequest addColumns
             * @property {Array.<string>|null} [dropColumns] AlterTableRequest dropColumns
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] AlterTableRequest operationParams
             * @property {Array.<Ydb.Table.IColumnMeta>|null} [alterColumns] AlterTableRequest alterColumns
             * @property {Ydb.Table.ITtlSettings|null} [setTtlSettings] AlterTableRequest setTtlSettings
             * @property {google.protobuf.IEmpty|null} [dropTtlSettings] AlterTableRequest dropTtlSettings
             */

            /**
             * Constructs a new AlterTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an AlterTableRequest.
             * @implements IAlterTableRequest
             * @constructor
             * @param {Ydb.Table.IAlterTableRequest=} [properties] Properties to set
             */
            function AlterTableRequest(properties) {
                this.addColumns = [];
                this.dropColumns = [];
                this.alterColumns = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.sessionId = "";

            /**
             * AlterTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.path = "";

            /**
             * AlterTableRequest addColumns.
             * @member {Array.<Ydb.Table.IColumnMeta>} addColumns
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.addColumns = $util.emptyArray;

            /**
             * AlterTableRequest dropColumns.
             * @member {Array.<string>} dropColumns
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.dropColumns = $util.emptyArray;

            /**
             * AlterTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.operationParams = null;

            /**
             * AlterTableRequest alterColumns.
             * @member {Array.<Ydb.Table.IColumnMeta>} alterColumns
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.alterColumns = $util.emptyArray;

            /**
             * AlterTableRequest setTtlSettings.
             * @member {Ydb.Table.ITtlSettings|null|undefined} setTtlSettings
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.setTtlSettings = null;

            /**
             * AlterTableRequest dropTtlSettings.
             * @member {google.protobuf.IEmpty|null|undefined} dropTtlSettings
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.dropTtlSettings = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * AlterTableRequest ttlAction.
             * @member {"setTtlSettings"|"dropTtlSettings"|undefined} ttlAction
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            Object.defineProperty(AlterTableRequest.prototype, "ttlAction", {
                get: $util.oneOfGetter($oneOfFields = ["setTtlSettings", "dropTtlSettings"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AlterTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Ydb.Table.IAlterTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.AlterTableRequest} AlterTableRequest instance
             */
            AlterTableRequest.create = function create(properties) {
                return new AlterTableRequest(properties);
            };

            /**
             * Encodes the specified AlterTableRequest message. Does not implicitly {@link Ydb.Table.AlterTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Ydb.Table.IAlterTableRequest} message AlterTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.addColumns != null && message.addColumns.length)
                    for (var i = 0; i < message.addColumns.length; ++i)
                        $root.Ydb.Table.ColumnMeta.encode(message.addColumns[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.dropColumns != null && message.dropColumns.length)
                    for (var i = 0; i < message.dropColumns.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.dropColumns[i]);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.alterColumns != null && message.alterColumns.length)
                    for (var i = 0; i < message.alterColumns.length; ++i)
                        $root.Ydb.Table.ColumnMeta.encode(message.alterColumns[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.setTtlSettings != null && message.hasOwnProperty("setTtlSettings"))
                    $root.Ydb.Table.TtlSettings.encode(message.setTtlSettings, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.dropTtlSettings != null && message.hasOwnProperty("dropTtlSettings"))
                    $root.google.protobuf.Empty.encode(message.dropTtlSettings, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlterTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.AlterTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Ydb.Table.IAlterTableRequest} message AlterTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.AlterTableRequest} AlterTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.AlterTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 3:
                        if (!(message.addColumns && message.addColumns.length))
                            message.addColumns = [];
                        message.addColumns.push($root.Ydb.Table.ColumnMeta.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.dropColumns && message.dropColumns.length))
                            message.dropColumns = [];
                        message.dropColumns.push(reader.string());
                        break;
                    case 5:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.alterColumns && message.alterColumns.length))
                            message.alterColumns = [];
                        message.alterColumns.push($root.Ydb.Table.ColumnMeta.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.setTtlSettings = $root.Ydb.Table.TtlSettings.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.dropTtlSettings = $root.google.protobuf.Empty.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.AlterTableRequest} AlterTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterTableRequest message.
             * @function verify
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.addColumns != null && message.hasOwnProperty("addColumns")) {
                    if (!Array.isArray(message.addColumns))
                        return "addColumns: array expected";
                    for (var i = 0; i < message.addColumns.length; ++i) {
                        var error = $root.Ydb.Table.ColumnMeta.verify(message.addColumns[i]);
                        if (error)
                            return "addColumns." + error;
                    }
                }
                if (message.dropColumns != null && message.hasOwnProperty("dropColumns")) {
                    if (!Array.isArray(message.dropColumns))
                        return "dropColumns: array expected";
                    for (var i = 0; i < message.dropColumns.length; ++i)
                        if (!$util.isString(message.dropColumns[i]))
                            return "dropColumns: string[] expected";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.alterColumns != null && message.hasOwnProperty("alterColumns")) {
                    if (!Array.isArray(message.alterColumns))
                        return "alterColumns: array expected";
                    for (var i = 0; i < message.alterColumns.length; ++i) {
                        var error = $root.Ydb.Table.ColumnMeta.verify(message.alterColumns[i]);
                        if (error)
                            return "alterColumns." + error;
                    }
                }
                if (message.setTtlSettings != null && message.hasOwnProperty("setTtlSettings")) {
                    properties.ttlAction = 1;
                    {
                        var error = $root.Ydb.Table.TtlSettings.verify(message.setTtlSettings);
                        if (error)
                            return "setTtlSettings." + error;
                    }
                }
                if (message.dropTtlSettings != null && message.hasOwnProperty("dropTtlSettings")) {
                    if (properties.ttlAction === 1)
                        return "ttlAction: multiple values";
                    properties.ttlAction = 1;
                    {
                        var error = $root.google.protobuf.Empty.verify(message.dropTtlSettings);
                        if (error)
                            return "dropTtlSettings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an AlterTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.AlterTableRequest} AlterTableRequest
             */
            AlterTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.AlterTableRequest)
                    return object;
                var message = new $root.Ydb.Table.AlterTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.addColumns) {
                    if (!Array.isArray(object.addColumns))
                        throw TypeError(".Ydb.Table.AlterTableRequest.addColumns: array expected");
                    message.addColumns = [];
                    for (var i = 0; i < object.addColumns.length; ++i) {
                        if (typeof object.addColumns[i] !== "object")
                            throw TypeError(".Ydb.Table.AlterTableRequest.addColumns: object expected");
                        message.addColumns[i] = $root.Ydb.Table.ColumnMeta.fromObject(object.addColumns[i]);
                    }
                }
                if (object.dropColumns) {
                    if (!Array.isArray(object.dropColumns))
                        throw TypeError(".Ydb.Table.AlterTableRequest.dropColumns: array expected");
                    message.dropColumns = [];
                    for (var i = 0; i < object.dropColumns.length; ++i)
                        message.dropColumns[i] = String(object.dropColumns[i]);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.alterColumns) {
                    if (!Array.isArray(object.alterColumns))
                        throw TypeError(".Ydb.Table.AlterTableRequest.alterColumns: array expected");
                    message.alterColumns = [];
                    for (var i = 0; i < object.alterColumns.length; ++i) {
                        if (typeof object.alterColumns[i] !== "object")
                            throw TypeError(".Ydb.Table.AlterTableRequest.alterColumns: object expected");
                        message.alterColumns[i] = $root.Ydb.Table.ColumnMeta.fromObject(object.alterColumns[i]);
                    }
                }
                if (object.setTtlSettings != null) {
                    if (typeof object.setTtlSettings !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.setTtlSettings: object expected");
                    message.setTtlSettings = $root.Ydb.Table.TtlSettings.fromObject(object.setTtlSettings);
                }
                if (object.dropTtlSettings != null) {
                    if (typeof object.dropTtlSettings !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.dropTtlSettings: object expected");
                    message.dropTtlSettings = $root.google.protobuf.Empty.fromObject(object.dropTtlSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlterTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Ydb.Table.AlterTableRequest} message AlterTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.addColumns = [];
                    object.dropColumns = [];
                    object.alterColumns = [];
                }
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.addColumns && message.addColumns.length) {
                    object.addColumns = [];
                    for (var j = 0; j < message.addColumns.length; ++j)
                        object.addColumns[j] = $root.Ydb.Table.ColumnMeta.toObject(message.addColumns[j], options);
                }
                if (message.dropColumns && message.dropColumns.length) {
                    object.dropColumns = [];
                    for (var j = 0; j < message.dropColumns.length; ++j)
                        object.dropColumns[j] = message.dropColumns[j];
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.alterColumns && message.alterColumns.length) {
                    object.alterColumns = [];
                    for (var j = 0; j < message.alterColumns.length; ++j)
                        object.alterColumns[j] = $root.Ydb.Table.ColumnMeta.toObject(message.alterColumns[j], options);
                }
                if (message.setTtlSettings != null && message.hasOwnProperty("setTtlSettings")) {
                    object.setTtlSettings = $root.Ydb.Table.TtlSettings.toObject(message.setTtlSettings, options);
                    if (options.oneofs)
                        object.ttlAction = "setTtlSettings";
                }
                if (message.dropTtlSettings != null && message.hasOwnProperty("dropTtlSettings")) {
                    object.dropTtlSettings = $root.google.protobuf.Empty.toObject(message.dropTtlSettings, options);
                    if (options.oneofs)
                        object.ttlAction = "dropTtlSettings";
                }
                return object;
            };

            /**
             * Converts this AlterTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterTableRequest;
        })();

        Table.AlterTableResponse = (function() {

            /**
             * Properties of an AlterTableResponse.
             * @memberof Ydb.Table
             * @interface IAlterTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] AlterTableResponse operation
             */

            /**
             * Constructs a new AlterTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an AlterTableResponse.
             * @implements IAlterTableResponse
             * @constructor
             * @param {Ydb.Table.IAlterTableResponse=} [properties] Properties to set
             */
            function AlterTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.AlterTableResponse
             * @instance
             */
            AlterTableResponse.prototype.operation = null;

            /**
             * Creates a new AlterTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Ydb.Table.IAlterTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.AlterTableResponse} AlterTableResponse instance
             */
            AlterTableResponse.create = function create(properties) {
                return new AlterTableResponse(properties);
            };

            /**
             * Encodes the specified AlterTableResponse message. Does not implicitly {@link Ydb.Table.AlterTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Ydb.Table.IAlterTableResponse} message AlterTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlterTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.AlterTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Ydb.Table.IAlterTableResponse} message AlterTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.AlterTableResponse} AlterTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.AlterTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.AlterTableResponse} AlterTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterTableResponse message.
             * @function verify
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an AlterTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.AlterTableResponse} AlterTableResponse
             */
            AlterTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.AlterTableResponse)
                    return object;
                var message = new $root.Ydb.Table.AlterTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.AlterTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlterTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Ydb.Table.AlterTableResponse} message AlterTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this AlterTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.AlterTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterTableResponse;
        })();

        Table.CopyTableRequest = (function() {

            /**
             * Properties of a CopyTableRequest.
             * @memberof Ydb.Table
             * @interface ICopyTableRequest
             * @property {string|null} [sessionId] CopyTableRequest sessionId
             * @property {string|null} [sourcePath] CopyTableRequest sourcePath
             * @property {string|null} [destinationPath] CopyTableRequest destinationPath
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CopyTableRequest operationParams
             */

            /**
             * Constructs a new CopyTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTableRequest.
             * @implements ICopyTableRequest
             * @constructor
             * @param {Ydb.Table.ICopyTableRequest=} [properties] Properties to set
             */
            function CopyTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             */
            CopyTableRequest.prototype.sessionId = "";

            /**
             * CopyTableRequest sourcePath.
             * @member {string} sourcePath
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             */
            CopyTableRequest.prototype.sourcePath = "";

            /**
             * CopyTableRequest destinationPath.
             * @member {string} destinationPath
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             */
            CopyTableRequest.prototype.destinationPath = "";

            /**
             * CopyTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             */
            CopyTableRequest.prototype.operationParams = null;

            /**
             * Creates a new CopyTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Ydb.Table.ICopyTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTableRequest} CopyTableRequest instance
             */
            CopyTableRequest.create = function create(properties) {
                return new CopyTableRequest(properties);
            };

            /**
             * Encodes the specified CopyTableRequest message. Does not implicitly {@link Ydb.Table.CopyTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Ydb.Table.ICopyTableRequest} message CopyTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourcePath);
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.destinationPath);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CopyTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.CopyTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Ydb.Table.ICopyTableRequest} message CopyTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTableRequest} CopyTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.sourcePath = reader.string();
                        break;
                    case 3:
                        message.destinationPath = reader.string();
                        break;
                    case 4:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTableRequest} CopyTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTableRequest message.
             * @function verify
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    if (!$util.isString(message.sourcePath))
                        return "sourcePath: string expected";
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    if (!$util.isString(message.destinationPath))
                        return "destinationPath: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a CopyTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTableRequest} CopyTableRequest
             */
            CopyTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTableRequest)
                    return object;
                var message = new $root.Ydb.Table.CopyTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.sourcePath != null)
                    message.sourcePath = String(object.sourcePath);
                if (object.destinationPath != null)
                    message.destinationPath = String(object.destinationPath);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CopyTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a CopyTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Ydb.Table.CopyTableRequest} message CopyTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.sourcePath = "";
                    object.destinationPath = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    object.sourcePath = message.sourcePath;
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    object.destinationPath = message.destinationPath;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this CopyTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTableRequest;
        })();

        Table.CopyTableResponse = (function() {

            /**
             * Properties of a CopyTableResponse.
             * @memberof Ydb.Table
             * @interface ICopyTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CopyTableResponse operation
             */

            /**
             * Constructs a new CopyTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTableResponse.
             * @implements ICopyTableResponse
             * @constructor
             * @param {Ydb.Table.ICopyTableResponse=} [properties] Properties to set
             */
            function CopyTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CopyTableResponse
             * @instance
             */
            CopyTableResponse.prototype.operation = null;

            /**
             * Creates a new CopyTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Ydb.Table.ICopyTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTableResponse} CopyTableResponse instance
             */
            CopyTableResponse.create = function create(properties) {
                return new CopyTableResponse(properties);
            };

            /**
             * Encodes the specified CopyTableResponse message. Does not implicitly {@link Ydb.Table.CopyTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Ydb.Table.ICopyTableResponse} message CopyTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CopyTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.CopyTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Ydb.Table.ICopyTableResponse} message CopyTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTableResponse} CopyTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTableResponse} CopyTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTableResponse message.
             * @function verify
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CopyTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTableResponse} CopyTableResponse
             */
            CopyTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTableResponse)
                    return object;
                var message = new $root.Ydb.Table.CopyTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CopyTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CopyTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Ydb.Table.CopyTableResponse} message CopyTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CopyTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTableResponse;
        })();

        Table.CopyTableItem = (function() {

            /**
             * Properties of a CopyTableItem.
             * @memberof Ydb.Table
             * @interface ICopyTableItem
             * @property {string|null} [sourcePath] CopyTableItem sourcePath
             * @property {string|null} [destinationPath] CopyTableItem destinationPath
             * @property {boolean|null} [omitIndexes] CopyTableItem omitIndexes
             */

            /**
             * Constructs a new CopyTableItem.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTableItem.
             * @implements ICopyTableItem
             * @constructor
             * @param {Ydb.Table.ICopyTableItem=} [properties] Properties to set
             */
            function CopyTableItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTableItem sourcePath.
             * @member {string} sourcePath
             * @memberof Ydb.Table.CopyTableItem
             * @instance
             */
            CopyTableItem.prototype.sourcePath = "";

            /**
             * CopyTableItem destinationPath.
             * @member {string} destinationPath
             * @memberof Ydb.Table.CopyTableItem
             * @instance
             */
            CopyTableItem.prototype.destinationPath = "";

            /**
             * CopyTableItem omitIndexes.
             * @member {boolean} omitIndexes
             * @memberof Ydb.Table.CopyTableItem
             * @instance
             */
            CopyTableItem.prototype.omitIndexes = false;

            /**
             * Creates a new CopyTableItem instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Ydb.Table.ICopyTableItem=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTableItem} CopyTableItem instance
             */
            CopyTableItem.create = function create(properties) {
                return new CopyTableItem(properties);
            };

            /**
             * Encodes the specified CopyTableItem message. Does not implicitly {@link Ydb.Table.CopyTableItem.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Ydb.Table.ICopyTableItem} message CopyTableItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sourcePath);
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.destinationPath);
                if (message.omitIndexes != null && message.hasOwnProperty("omitIndexes"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.omitIndexes);
                return writer;
            };

            /**
             * Encodes the specified CopyTableItem message, length delimited. Does not implicitly {@link Ydb.Table.CopyTableItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Ydb.Table.ICopyTableItem} message CopyTableItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTableItem message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTableItem} CopyTableItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTableItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sourcePath = reader.string();
                        break;
                    case 2:
                        message.destinationPath = reader.string();
                        break;
                    case 3:
                        message.omitIndexes = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTableItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTableItem} CopyTableItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTableItem message.
             * @function verify
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTableItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    if (!$util.isString(message.sourcePath))
                        return "sourcePath: string expected";
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    if (!$util.isString(message.destinationPath))
                        return "destinationPath: string expected";
                if (message.omitIndexes != null && message.hasOwnProperty("omitIndexes"))
                    if (typeof message.omitIndexes !== "boolean")
                        return "omitIndexes: boolean expected";
                return null;
            };

            /**
             * Creates a CopyTableItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTableItem} CopyTableItem
             */
            CopyTableItem.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTableItem)
                    return object;
                var message = new $root.Ydb.Table.CopyTableItem();
                if (object.sourcePath != null)
                    message.sourcePath = String(object.sourcePath);
                if (object.destinationPath != null)
                    message.destinationPath = String(object.destinationPath);
                if (object.omitIndexes != null)
                    message.omitIndexes = Boolean(object.omitIndexes);
                return message;
            };

            /**
             * Creates a plain object from a CopyTableItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Ydb.Table.CopyTableItem} message CopyTableItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTableItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sourcePath = "";
                    object.destinationPath = "";
                    object.omitIndexes = false;
                }
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    object.sourcePath = message.sourcePath;
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    object.destinationPath = message.destinationPath;
                if (message.omitIndexes != null && message.hasOwnProperty("omitIndexes"))
                    object.omitIndexes = message.omitIndexes;
                return object;
            };

            /**
             * Converts this CopyTableItem to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTableItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTableItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTableItem;
        })();

        Table.CopyTablesRequest = (function() {

            /**
             * Properties of a CopyTablesRequest.
             * @memberof Ydb.Table
             * @interface ICopyTablesRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CopyTablesRequest operationParams
             * @property {string|null} [sessionId] CopyTablesRequest sessionId
             * @property {Array.<Ydb.Table.ICopyTableItem>|null} [tables] CopyTablesRequest tables
             */

            /**
             * Constructs a new CopyTablesRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTablesRequest.
             * @implements ICopyTablesRequest
             * @constructor
             * @param {Ydb.Table.ICopyTablesRequest=} [properties] Properties to set
             */
            function CopyTablesRequest(properties) {
                this.tables = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTablesRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CopyTablesRequest
             * @instance
             */
            CopyTablesRequest.prototype.operationParams = null;

            /**
             * CopyTablesRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CopyTablesRequest
             * @instance
             */
            CopyTablesRequest.prototype.sessionId = "";

            /**
             * CopyTablesRequest tables.
             * @member {Array.<Ydb.Table.ICopyTableItem>} tables
             * @memberof Ydb.Table.CopyTablesRequest
             * @instance
             */
            CopyTablesRequest.prototype.tables = $util.emptyArray;

            /**
             * Creates a new CopyTablesRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Ydb.Table.ICopyTablesRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTablesRequest} CopyTablesRequest instance
             */
            CopyTablesRequest.create = function create(properties) {
                return new CopyTablesRequest(properties);
            };

            /**
             * Encodes the specified CopyTablesRequest message. Does not implicitly {@link Ydb.Table.CopyTablesRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Ydb.Table.ICopyTablesRequest} message CopyTablesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTablesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sessionId);
                if (message.tables != null && message.tables.length)
                    for (var i = 0; i < message.tables.length; ++i)
                        $root.Ydb.Table.CopyTableItem.encode(message.tables[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CopyTablesRequest message, length delimited. Does not implicitly {@link Ydb.Table.CopyTablesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Ydb.Table.ICopyTablesRequest} message CopyTablesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTablesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTablesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTablesRequest} CopyTablesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTablesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTablesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.sessionId = reader.string();
                        break;
                    case 3:
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.Ydb.Table.CopyTableItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTablesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTablesRequest} CopyTablesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTablesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTablesRequest message.
             * @function verify
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTablesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.tables != null && message.hasOwnProperty("tables")) {
                    if (!Array.isArray(message.tables))
                        return "tables: array expected";
                    for (var i = 0; i < message.tables.length; ++i) {
                        var error = $root.Ydb.Table.CopyTableItem.verify(message.tables[i]);
                        if (error)
                            return "tables." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CopyTablesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTablesRequest} CopyTablesRequest
             */
            CopyTablesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTablesRequest)
                    return object;
                var message = new $root.Ydb.Table.CopyTablesRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CopyTablesRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.tables) {
                    if (!Array.isArray(object.tables))
                        throw TypeError(".Ydb.Table.CopyTablesRequest.tables: array expected");
                    message.tables = [];
                    for (var i = 0; i < object.tables.length; ++i) {
                        if (typeof object.tables[i] !== "object")
                            throw TypeError(".Ydb.Table.CopyTablesRequest.tables: object expected");
                        message.tables[i] = $root.Ydb.Table.CopyTableItem.fromObject(object.tables[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CopyTablesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Ydb.Table.CopyTablesRequest} message CopyTablesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTablesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tables = [];
                if (options.defaults) {
                    object.operationParams = null;
                    object.sessionId = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.tables && message.tables.length) {
                    object.tables = [];
                    for (var j = 0; j < message.tables.length; ++j)
                        object.tables[j] = $root.Ydb.Table.CopyTableItem.toObject(message.tables[j], options);
                }
                return object;
            };

            /**
             * Converts this CopyTablesRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTablesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTablesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTablesRequest;
        })();

        Table.CopyTablesResponse = (function() {

            /**
             * Properties of a CopyTablesResponse.
             * @memberof Ydb.Table
             * @interface ICopyTablesResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CopyTablesResponse operation
             */

            /**
             * Constructs a new CopyTablesResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTablesResponse.
             * @implements ICopyTablesResponse
             * @constructor
             * @param {Ydb.Table.ICopyTablesResponse=} [properties] Properties to set
             */
            function CopyTablesResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTablesResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CopyTablesResponse
             * @instance
             */
            CopyTablesResponse.prototype.operation = null;

            /**
             * Creates a new CopyTablesResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Ydb.Table.ICopyTablesResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTablesResponse} CopyTablesResponse instance
             */
            CopyTablesResponse.create = function create(properties) {
                return new CopyTablesResponse(properties);
            };

            /**
             * Encodes the specified CopyTablesResponse message. Does not implicitly {@link Ydb.Table.CopyTablesResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Ydb.Table.ICopyTablesResponse} message CopyTablesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTablesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CopyTablesResponse message, length delimited. Does not implicitly {@link Ydb.Table.CopyTablesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Ydb.Table.ICopyTablesResponse} message CopyTablesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTablesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTablesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTablesResponse} CopyTablesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTablesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTablesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTablesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTablesResponse} CopyTablesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTablesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTablesResponse message.
             * @function verify
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTablesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CopyTablesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTablesResponse} CopyTablesResponse
             */
            CopyTablesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTablesResponse)
                    return object;
                var message = new $root.Ydb.Table.CopyTablesResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CopyTablesResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CopyTablesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Ydb.Table.CopyTablesResponse} message CopyTablesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTablesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CopyTablesResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTablesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTablesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTablesResponse;
        })();

        Table.DescribeTableRequest = (function() {

            /**
             * Properties of a DescribeTableRequest.
             * @memberof Ydb.Table
             * @interface IDescribeTableRequest
             * @property {string|null} [sessionId] DescribeTableRequest sessionId
             * @property {string|null} [path] DescribeTableRequest path
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DescribeTableRequest operationParams
             * @property {boolean|null} [includeShardKeyBounds] DescribeTableRequest includeShardKeyBounds
             * @property {boolean|null} [includeTableStats] DescribeTableRequest includeTableStats
             * @property {boolean|null} [includePartitionStats] DescribeTableRequest includePartitionStats
             */

            /**
             * Constructs a new DescribeTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableRequest.
             * @implements IDescribeTableRequest
             * @constructor
             * @param {Ydb.Table.IDescribeTableRequest=} [properties] Properties to set
             */
            function DescribeTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.sessionId = "";

            /**
             * DescribeTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.path = "";

            /**
             * DescribeTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.operationParams = null;

            /**
             * DescribeTableRequest includeShardKeyBounds.
             * @member {boolean} includeShardKeyBounds
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.includeShardKeyBounds = false;

            /**
             * DescribeTableRequest includeTableStats.
             * @member {boolean} includeTableStats
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.includeTableStats = false;

            /**
             * DescribeTableRequest includePartitionStats.
             * @member {boolean} includePartitionStats
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.includePartitionStats = false;

            /**
             * Creates a new DescribeTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Ydb.Table.IDescribeTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableRequest} DescribeTableRequest instance
             */
            DescribeTableRequest.create = function create(properties) {
                return new DescribeTableRequest(properties);
            };

            /**
             * Encodes the specified DescribeTableRequest message. Does not implicitly {@link Ydb.Table.DescribeTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Ydb.Table.IDescribeTableRequest} message DescribeTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.includeShardKeyBounds != null && message.hasOwnProperty("includeShardKeyBounds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.includeShardKeyBounds);
                if (message.includeTableStats != null && message.hasOwnProperty("includeTableStats"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.includeTableStats);
                if (message.includePartitionStats != null && message.hasOwnProperty("includePartitionStats"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.includePartitionStats);
                return writer;
            };

            /**
             * Encodes the specified DescribeTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Ydb.Table.IDescribeTableRequest} message DescribeTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableRequest} DescribeTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 4:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.includeShardKeyBounds = reader.bool();
                        break;
                    case 6:
                        message.includeTableStats = reader.bool();
                        break;
                    case 7:
                        message.includePartitionStats = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableRequest} DescribeTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableRequest message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.includeShardKeyBounds != null && message.hasOwnProperty("includeShardKeyBounds"))
                    if (typeof message.includeShardKeyBounds !== "boolean")
                        return "includeShardKeyBounds: boolean expected";
                if (message.includeTableStats != null && message.hasOwnProperty("includeTableStats"))
                    if (typeof message.includeTableStats !== "boolean")
                        return "includeTableStats: boolean expected";
                if (message.includePartitionStats != null && message.hasOwnProperty("includePartitionStats"))
                    if (typeof message.includePartitionStats !== "boolean")
                        return "includePartitionStats: boolean expected";
                return null;
            };

            /**
             * Creates a DescribeTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableRequest} DescribeTableRequest
             */
            DescribeTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableRequest)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.includeShardKeyBounds != null)
                    message.includeShardKeyBounds = Boolean(object.includeShardKeyBounds);
                if (object.includeTableStats != null)
                    message.includeTableStats = Boolean(object.includeTableStats);
                if (object.includePartitionStats != null)
                    message.includePartitionStats = Boolean(object.includePartitionStats);
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Ydb.Table.DescribeTableRequest} message DescribeTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.operationParams = null;
                    object.includeShardKeyBounds = false;
                    object.includeTableStats = false;
                    object.includePartitionStats = false;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.includeShardKeyBounds != null && message.hasOwnProperty("includeShardKeyBounds"))
                    object.includeShardKeyBounds = message.includeShardKeyBounds;
                if (message.includeTableStats != null && message.hasOwnProperty("includeTableStats"))
                    object.includeTableStats = message.includeTableStats;
                if (message.includePartitionStats != null && message.hasOwnProperty("includePartitionStats"))
                    object.includePartitionStats = message.includePartitionStats;
                return object;
            };

            /**
             * Converts this DescribeTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableRequest;
        })();

        Table.DescribeTableResponse = (function() {

            /**
             * Properties of a DescribeTableResponse.
             * @memberof Ydb.Table
             * @interface IDescribeTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DescribeTableResponse operation
             */

            /**
             * Constructs a new DescribeTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableResponse.
             * @implements IDescribeTableResponse
             * @constructor
             * @param {Ydb.Table.IDescribeTableResponse=} [properties] Properties to set
             */
            function DescribeTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.DescribeTableResponse
             * @instance
             */
            DescribeTableResponse.prototype.operation = null;

            /**
             * Creates a new DescribeTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Ydb.Table.IDescribeTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableResponse} DescribeTableResponse instance
             */
            DescribeTableResponse.create = function create(properties) {
                return new DescribeTableResponse(properties);
            };

            /**
             * Encodes the specified DescribeTableResponse message. Does not implicitly {@link Ydb.Table.DescribeTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Ydb.Table.IDescribeTableResponse} message DescribeTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Ydb.Table.IDescribeTableResponse} message DescribeTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableResponse} DescribeTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableResponse} DescribeTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableResponse message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableResponse} DescribeTableResponse
             */
            DescribeTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableResponse)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Ydb.Table.DescribeTableResponse} message DescribeTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DescribeTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableResponse;
        })();

        Table.DescribeTableResult = (function() {

            /**
             * Properties of a DescribeTableResult.
             * @memberof Ydb.Table
             * @interface IDescribeTableResult
             * @property {Ydb.Scheme.IEntry|null} [self] DescribeTableResult self
             * @property {Array.<Ydb.Table.IColumnMeta>|null} [columns] DescribeTableResult columns
             * @property {Array.<string>|null} [primaryKey] DescribeTableResult primaryKey
             * @property {Array.<Ydb.ITypedValue>|null} [shardKeyBounds] DescribeTableResult shardKeyBounds
             * @property {Array.<Ydb.Table.ITableIndex>|null} [indexes] DescribeTableResult indexes
             * @property {Ydb.Table.ITableStats|null} [tableStats] DescribeTableResult tableStats
             * @property {Ydb.Table.ITtlSettings|null} [ttlSettings] DescribeTableResult ttlSettings
             */

            /**
             * Constructs a new DescribeTableResult.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableResult.
             * @implements IDescribeTableResult
             * @constructor
             * @param {Ydb.Table.IDescribeTableResult=} [properties] Properties to set
             */
            function DescribeTableResult(properties) {
                this.columns = [];
                this.primaryKey = [];
                this.shardKeyBounds = [];
                this.indexes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableResult self.
             * @member {Ydb.Scheme.IEntry|null|undefined} self
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.self = null;

            /**
             * DescribeTableResult columns.
             * @member {Array.<Ydb.Table.IColumnMeta>} columns
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.columns = $util.emptyArray;

            /**
             * DescribeTableResult primaryKey.
             * @member {Array.<string>} primaryKey
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.primaryKey = $util.emptyArray;

            /**
             * DescribeTableResult shardKeyBounds.
             * @member {Array.<Ydb.ITypedValue>} shardKeyBounds
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.shardKeyBounds = $util.emptyArray;

            /**
             * DescribeTableResult indexes.
             * @member {Array.<Ydb.Table.ITableIndex>} indexes
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.indexes = $util.emptyArray;

            /**
             * DescribeTableResult tableStats.
             * @member {Ydb.Table.ITableStats|null|undefined} tableStats
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.tableStats = null;

            /**
             * DescribeTableResult ttlSettings.
             * @member {Ydb.Table.ITtlSettings|null|undefined} ttlSettings
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.ttlSettings = null;

            /**
             * Creates a new DescribeTableResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Ydb.Table.IDescribeTableResult=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableResult} DescribeTableResult instance
             */
            DescribeTableResult.create = function create(properties) {
                return new DescribeTableResult(properties);
            };

            /**
             * Encodes the specified DescribeTableResult message. Does not implicitly {@link Ydb.Table.DescribeTableResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Ydb.Table.IDescribeTableResult} message DescribeTableResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.self != null && message.hasOwnProperty("self"))
                    $root.Ydb.Scheme.Entry.encode(message.self, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.columns != null && message.columns.length)
                    for (var i = 0; i < message.columns.length; ++i)
                        $root.Ydb.Table.ColumnMeta.encode(message.columns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.primaryKey != null && message.primaryKey.length)
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.primaryKey[i]);
                if (message.shardKeyBounds != null && message.shardKeyBounds.length)
                    for (var i = 0; i < message.shardKeyBounds.length; ++i)
                        $root.Ydb.TypedValue.encode(message.shardKeyBounds[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.indexes != null && message.indexes.length)
                    for (var i = 0; i < message.indexes.length; ++i)
                        $root.Ydb.Table.TableIndex.encode(message.indexes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.tableStats != null && message.hasOwnProperty("tableStats"))
                    $root.Ydb.Table.TableStats.encode(message.tableStats, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings"))
                    $root.Ydb.Table.TtlSettings.encode(message.ttlSettings, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableResult message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Ydb.Table.IDescribeTableResult} message DescribeTableResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableResult} DescribeTableResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.self = $root.Ydb.Scheme.Entry.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.columns && message.columns.length))
                            message.columns = [];
                        message.columns.push($root.Ydb.Table.ColumnMeta.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.primaryKey && message.primaryKey.length))
                            message.primaryKey = [];
                        message.primaryKey.push(reader.string());
                        break;
                    case 4:
                        if (!(message.shardKeyBounds && message.shardKeyBounds.length))
                            message.shardKeyBounds = [];
                        message.shardKeyBounds.push($root.Ydb.TypedValue.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.indexes && message.indexes.length))
                            message.indexes = [];
                        message.indexes.push($root.Ydb.Table.TableIndex.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.tableStats = $root.Ydb.Table.TableStats.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.ttlSettings = $root.Ydb.Table.TtlSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableResult} DescribeTableResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableResult message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.self != null && message.hasOwnProperty("self")) {
                    var error = $root.Ydb.Scheme.Entry.verify(message.self);
                    if (error)
                        return "self." + error;
                }
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (var i = 0; i < message.columns.length; ++i) {
                        var error = $root.Ydb.Table.ColumnMeta.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                if (message.primaryKey != null && message.hasOwnProperty("primaryKey")) {
                    if (!Array.isArray(message.primaryKey))
                        return "primaryKey: array expected";
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        if (!$util.isString(message.primaryKey[i]))
                            return "primaryKey: string[] expected";
                }
                if (message.shardKeyBounds != null && message.hasOwnProperty("shardKeyBounds")) {
                    if (!Array.isArray(message.shardKeyBounds))
                        return "shardKeyBounds: array expected";
                    for (var i = 0; i < message.shardKeyBounds.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.shardKeyBounds[i]);
                        if (error)
                            return "shardKeyBounds." + error;
                    }
                }
                if (message.indexes != null && message.hasOwnProperty("indexes")) {
                    if (!Array.isArray(message.indexes))
                        return "indexes: array expected";
                    for (var i = 0; i < message.indexes.length; ++i) {
                        var error = $root.Ydb.Table.TableIndex.verify(message.indexes[i]);
                        if (error)
                            return "indexes." + error;
                    }
                }
                if (message.tableStats != null && message.hasOwnProperty("tableStats")) {
                    var error = $root.Ydb.Table.TableStats.verify(message.tableStats);
                    if (error)
                        return "tableStats." + error;
                }
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings")) {
                    var error = $root.Ydb.Table.TtlSettings.verify(message.ttlSettings);
                    if (error)
                        return "ttlSettings." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeTableResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableResult} DescribeTableResult
             */
            DescribeTableResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableResult)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableResult();
                if (object.self != null) {
                    if (typeof object.self !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.self: object expected");
                    message.self = $root.Ydb.Scheme.Entry.fromObject(object.self);
                }
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".Ydb.Table.DescribeTableResult.columns: array expected");
                    message.columns = [];
                    for (var i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableResult.columns: object expected");
                        message.columns[i] = $root.Ydb.Table.ColumnMeta.fromObject(object.columns[i]);
                    }
                }
                if (object.primaryKey) {
                    if (!Array.isArray(object.primaryKey))
                        throw TypeError(".Ydb.Table.DescribeTableResult.primaryKey: array expected");
                    message.primaryKey = [];
                    for (var i = 0; i < object.primaryKey.length; ++i)
                        message.primaryKey[i] = String(object.primaryKey[i]);
                }
                if (object.shardKeyBounds) {
                    if (!Array.isArray(object.shardKeyBounds))
                        throw TypeError(".Ydb.Table.DescribeTableResult.shardKeyBounds: array expected");
                    message.shardKeyBounds = [];
                    for (var i = 0; i < object.shardKeyBounds.length; ++i) {
                        if (typeof object.shardKeyBounds[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableResult.shardKeyBounds: object expected");
                        message.shardKeyBounds[i] = $root.Ydb.TypedValue.fromObject(object.shardKeyBounds[i]);
                    }
                }
                if (object.indexes) {
                    if (!Array.isArray(object.indexes))
                        throw TypeError(".Ydb.Table.DescribeTableResult.indexes: array expected");
                    message.indexes = [];
                    for (var i = 0; i < object.indexes.length; ++i) {
                        if (typeof object.indexes[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableResult.indexes: object expected");
                        message.indexes[i] = $root.Ydb.Table.TableIndex.fromObject(object.indexes[i]);
                    }
                }
                if (object.tableStats != null) {
                    if (typeof object.tableStats !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.tableStats: object expected");
                    message.tableStats = $root.Ydb.Table.TableStats.fromObject(object.tableStats);
                }
                if (object.ttlSettings != null) {
                    if (typeof object.ttlSettings !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.ttlSettings: object expected");
                    message.ttlSettings = $root.Ydb.Table.TtlSettings.fromObject(object.ttlSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Ydb.Table.DescribeTableResult} message DescribeTableResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.columns = [];
                    object.primaryKey = [];
                    object.shardKeyBounds = [];
                    object.indexes = [];
                }
                if (options.defaults) {
                    object.self = null;
                    object.tableStats = null;
                    object.ttlSettings = null;
                }
                if (message.self != null && message.hasOwnProperty("self"))
                    object.self = $root.Ydb.Scheme.Entry.toObject(message.self, options);
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (var j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.Ydb.Table.ColumnMeta.toObject(message.columns[j], options);
                }
                if (message.primaryKey && message.primaryKey.length) {
                    object.primaryKey = [];
                    for (var j = 0; j < message.primaryKey.length; ++j)
                        object.primaryKey[j] = message.primaryKey[j];
                }
                if (message.shardKeyBounds && message.shardKeyBounds.length) {
                    object.shardKeyBounds = [];
                    for (var j = 0; j < message.shardKeyBounds.length; ++j)
                        object.shardKeyBounds[j] = $root.Ydb.TypedValue.toObject(message.shardKeyBounds[j], options);
                }
                if (message.indexes && message.indexes.length) {
                    object.indexes = [];
                    for (var j = 0; j < message.indexes.length; ++j)
                        object.indexes[j] = $root.Ydb.Table.TableIndex.toObject(message.indexes[j], options);
                }
                if (message.tableStats != null && message.hasOwnProperty("tableStats"))
                    object.tableStats = $root.Ydb.Table.TableStats.toObject(message.tableStats, options);
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings"))
                    object.ttlSettings = $root.Ydb.Table.TtlSettings.toObject(message.ttlSettings, options);
                return object;
            };

            /**
             * Converts this DescribeTableResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableResult;
        })();

        Table.Query = (function() {

            /**
             * Properties of a Query.
             * @memberof Ydb.Table
             * @interface IQuery
             * @property {string|null} [yqlText] Query yqlText
             * @property {string|null} [id] Query id
             */

            /**
             * Constructs a new Query.
             * @memberof Ydb.Table
             * @classdesc Represents a Query.
             * @implements IQuery
             * @constructor
             * @param {Ydb.Table.IQuery=} [properties] Properties to set
             */
            function Query(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Query yqlText.
             * @member {string} yqlText
             * @memberof Ydb.Table.Query
             * @instance
             */
            Query.prototype.yqlText = "";

            /**
             * Query id.
             * @member {string} id
             * @memberof Ydb.Table.Query
             * @instance
             */
            Query.prototype.id = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Query query.
             * @member {"yqlText"|"id"|undefined} query
             * @memberof Ydb.Table.Query
             * @instance
             */
            Object.defineProperty(Query.prototype, "query", {
                get: $util.oneOfGetter($oneOfFields = ["yqlText", "id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Query instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.Query
             * @static
             * @param {Ydb.Table.IQuery=} [properties] Properties to set
             * @returns {Ydb.Table.Query} Query instance
             */
            Query.create = function create(properties) {
                return new Query(properties);
            };

            /**
             * Encodes the specified Query message. Does not implicitly {@link Ydb.Table.Query.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.Query
             * @static
             * @param {Ydb.Table.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.yqlText);
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified Query message, length delimited. Does not implicitly {@link Ydb.Table.Query.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.Query
             * @static
             * @param {Ydb.Table.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Query message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.Query();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.yqlText = reader.string();
                        break;
                    case 2:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Query message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Query message.
             * @function verify
             * @memberof Ydb.Table.Query
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Query.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.yqlText != null && message.hasOwnProperty("yqlText")) {
                    properties.query = 1;
                    if (!$util.isString(message.yqlText))
                        return "yqlText: string expected";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    if (properties.query === 1)
                        return "query: multiple values";
                    properties.query = 1;
                    if (!$util.isString(message.id))
                        return "id: string expected";
                }
                return null;
            };

            /**
             * Creates a Query message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.Query
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.Query} Query
             */
            Query.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.Query)
                    return object;
                var message = new $root.Ydb.Table.Query();
                if (object.yqlText != null)
                    message.yqlText = String(object.yqlText);
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a Query message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.Query
             * @static
             * @param {Ydb.Table.Query} message Query
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Query.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.yqlText != null && message.hasOwnProperty("yqlText")) {
                    object.yqlText = message.yqlText;
                    if (options.oneofs)
                        object.query = "yqlText";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = message.id;
                    if (options.oneofs)
                        object.query = "id";
                }
                return object;
            };

            /**
             * Converts this Query to JSON.
             * @function toJSON
             * @memberof Ydb.Table.Query
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Query.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Query;
        })();

        Table.SerializableModeSettings = (function() {

            /**
             * Properties of a SerializableModeSettings.
             * @memberof Ydb.Table
             * @interface ISerializableModeSettings
             */

            /**
             * Constructs a new SerializableModeSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a SerializableModeSettings.
             * @implements ISerializableModeSettings
             * @constructor
             * @param {Ydb.Table.ISerializableModeSettings=} [properties] Properties to set
             */
            function SerializableModeSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SerializableModeSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Ydb.Table.ISerializableModeSettings=} [properties] Properties to set
             * @returns {Ydb.Table.SerializableModeSettings} SerializableModeSettings instance
             */
            SerializableModeSettings.create = function create(properties) {
                return new SerializableModeSettings(properties);
            };

            /**
             * Encodes the specified SerializableModeSettings message. Does not implicitly {@link Ydb.Table.SerializableModeSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Ydb.Table.ISerializableModeSettings} message SerializableModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializableModeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SerializableModeSettings message, length delimited. Does not implicitly {@link Ydb.Table.SerializableModeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Ydb.Table.ISerializableModeSettings} message SerializableModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializableModeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SerializableModeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.SerializableModeSettings} SerializableModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializableModeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.SerializableModeSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SerializableModeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.SerializableModeSettings} SerializableModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializableModeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SerializableModeSettings message.
             * @function verify
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SerializableModeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SerializableModeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.SerializableModeSettings} SerializableModeSettings
             */
            SerializableModeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.SerializableModeSettings)
                    return object;
                return new $root.Ydb.Table.SerializableModeSettings();
            };

            /**
             * Creates a plain object from a SerializableModeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Ydb.Table.SerializableModeSettings} message SerializableModeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SerializableModeSettings.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SerializableModeSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.SerializableModeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SerializableModeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SerializableModeSettings;
        })();

        Table.OnlineModeSettings = (function() {

            /**
             * Properties of an OnlineModeSettings.
             * @memberof Ydb.Table
             * @interface IOnlineModeSettings
             * @property {boolean|null} [allowInconsistentReads] OnlineModeSettings allowInconsistentReads
             */

            /**
             * Constructs a new OnlineModeSettings.
             * @memberof Ydb.Table
             * @classdesc Represents an OnlineModeSettings.
             * @implements IOnlineModeSettings
             * @constructor
             * @param {Ydb.Table.IOnlineModeSettings=} [properties] Properties to set
             */
            function OnlineModeSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OnlineModeSettings allowInconsistentReads.
             * @member {boolean} allowInconsistentReads
             * @memberof Ydb.Table.OnlineModeSettings
             * @instance
             */
            OnlineModeSettings.prototype.allowInconsistentReads = false;

            /**
             * Creates a new OnlineModeSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Ydb.Table.IOnlineModeSettings=} [properties] Properties to set
             * @returns {Ydb.Table.OnlineModeSettings} OnlineModeSettings instance
             */
            OnlineModeSettings.create = function create(properties) {
                return new OnlineModeSettings(properties);
            };

            /**
             * Encodes the specified OnlineModeSettings message. Does not implicitly {@link Ydb.Table.OnlineModeSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Ydb.Table.IOnlineModeSettings} message OnlineModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OnlineModeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowInconsistentReads != null && message.hasOwnProperty("allowInconsistentReads"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.allowInconsistentReads);
                return writer;
            };

            /**
             * Encodes the specified OnlineModeSettings message, length delimited. Does not implicitly {@link Ydb.Table.OnlineModeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Ydb.Table.IOnlineModeSettings} message OnlineModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OnlineModeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OnlineModeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.OnlineModeSettings} OnlineModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OnlineModeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.OnlineModeSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.allowInconsistentReads = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OnlineModeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.OnlineModeSettings} OnlineModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OnlineModeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OnlineModeSettings message.
             * @function verify
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OnlineModeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowInconsistentReads != null && message.hasOwnProperty("allowInconsistentReads"))
                    if (typeof message.allowInconsistentReads !== "boolean")
                        return "allowInconsistentReads: boolean expected";
                return null;
            };

            /**
             * Creates an OnlineModeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.OnlineModeSettings} OnlineModeSettings
             */
            OnlineModeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.OnlineModeSettings)
                    return object;
                var message = new $root.Ydb.Table.OnlineModeSettings();
                if (object.allowInconsistentReads != null)
                    message.allowInconsistentReads = Boolean(object.allowInconsistentReads);
                return message;
            };

            /**
             * Creates a plain object from an OnlineModeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Ydb.Table.OnlineModeSettings} message OnlineModeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OnlineModeSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.allowInconsistentReads = false;
                if (message.allowInconsistentReads != null && message.hasOwnProperty("allowInconsistentReads"))
                    object.allowInconsistentReads = message.allowInconsistentReads;
                return object;
            };

            /**
             * Converts this OnlineModeSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.OnlineModeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OnlineModeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OnlineModeSettings;
        })();

        Table.StaleModeSettings = (function() {

            /**
             * Properties of a StaleModeSettings.
             * @memberof Ydb.Table
             * @interface IStaleModeSettings
             */

            /**
             * Constructs a new StaleModeSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a StaleModeSettings.
             * @implements IStaleModeSettings
             * @constructor
             * @param {Ydb.Table.IStaleModeSettings=} [properties] Properties to set
             */
            function StaleModeSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StaleModeSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Ydb.Table.IStaleModeSettings=} [properties] Properties to set
             * @returns {Ydb.Table.StaleModeSettings} StaleModeSettings instance
             */
            StaleModeSettings.create = function create(properties) {
                return new StaleModeSettings(properties);
            };

            /**
             * Encodes the specified StaleModeSettings message. Does not implicitly {@link Ydb.Table.StaleModeSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Ydb.Table.IStaleModeSettings} message StaleModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaleModeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StaleModeSettings message, length delimited. Does not implicitly {@link Ydb.Table.StaleModeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Ydb.Table.IStaleModeSettings} message StaleModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaleModeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StaleModeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.StaleModeSettings} StaleModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaleModeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.StaleModeSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StaleModeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.StaleModeSettings} StaleModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaleModeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StaleModeSettings message.
             * @function verify
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StaleModeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StaleModeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.StaleModeSettings} StaleModeSettings
             */
            StaleModeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.StaleModeSettings)
                    return object;
                return new $root.Ydb.Table.StaleModeSettings();
            };

            /**
             * Creates a plain object from a StaleModeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Ydb.Table.StaleModeSettings} message StaleModeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StaleModeSettings.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StaleModeSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.StaleModeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StaleModeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StaleModeSettings;
        })();

        Table.TransactionSettings = (function() {

            /**
             * Properties of a TransactionSettings.
             * @memberof Ydb.Table
             * @interface ITransactionSettings
             * @property {Ydb.Table.ISerializableModeSettings|null} [serializableReadWrite] TransactionSettings serializableReadWrite
             * @property {Ydb.Table.IOnlineModeSettings|null} [onlineReadOnly] TransactionSettings onlineReadOnly
             * @property {Ydb.Table.IStaleModeSettings|null} [staleReadOnly] TransactionSettings staleReadOnly
             */

            /**
             * Constructs a new TransactionSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a TransactionSettings.
             * @implements ITransactionSettings
             * @constructor
             * @param {Ydb.Table.ITransactionSettings=} [properties] Properties to set
             */
            function TransactionSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransactionSettings serializableReadWrite.
             * @member {Ydb.Table.ISerializableModeSettings|null|undefined} serializableReadWrite
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             */
            TransactionSettings.prototype.serializableReadWrite = null;

            /**
             * TransactionSettings onlineReadOnly.
             * @member {Ydb.Table.IOnlineModeSettings|null|undefined} onlineReadOnly
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             */
            TransactionSettings.prototype.onlineReadOnly = null;

            /**
             * TransactionSettings staleReadOnly.
             * @member {Ydb.Table.IStaleModeSettings|null|undefined} staleReadOnly
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             */
            TransactionSettings.prototype.staleReadOnly = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TransactionSettings txMode.
             * @member {"serializableReadWrite"|"onlineReadOnly"|"staleReadOnly"|undefined} txMode
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             */
            Object.defineProperty(TransactionSettings.prototype, "txMode", {
                get: $util.oneOfGetter($oneOfFields = ["serializableReadWrite", "onlineReadOnly", "staleReadOnly"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TransactionSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Ydb.Table.ITransactionSettings=} [properties] Properties to set
             * @returns {Ydb.Table.TransactionSettings} TransactionSettings instance
             */
            TransactionSettings.create = function create(properties) {
                return new TransactionSettings(properties);
            };

            /**
             * Encodes the specified TransactionSettings message. Does not implicitly {@link Ydb.Table.TransactionSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Ydb.Table.ITransactionSettings} message TransactionSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serializableReadWrite != null && message.hasOwnProperty("serializableReadWrite"))
                    $root.Ydb.Table.SerializableModeSettings.encode(message.serializableReadWrite, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.onlineReadOnly != null && message.hasOwnProperty("onlineReadOnly"))
                    $root.Ydb.Table.OnlineModeSettings.encode(message.onlineReadOnly, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.staleReadOnly != null && message.hasOwnProperty("staleReadOnly"))
                    $root.Ydb.Table.StaleModeSettings.encode(message.staleReadOnly, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TransactionSettings message, length delimited. Does not implicitly {@link Ydb.Table.TransactionSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Ydb.Table.ITransactionSettings} message TransactionSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransactionSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TransactionSettings} TransactionSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TransactionSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serializableReadWrite = $root.Ydb.Table.SerializableModeSettings.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.onlineReadOnly = $root.Ydb.Table.OnlineModeSettings.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.staleReadOnly = $root.Ydb.Table.StaleModeSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransactionSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TransactionSettings} TransactionSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransactionSettings message.
             * @function verify
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransactionSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.serializableReadWrite != null && message.hasOwnProperty("serializableReadWrite")) {
                    properties.txMode = 1;
                    {
                        var error = $root.Ydb.Table.SerializableModeSettings.verify(message.serializableReadWrite);
                        if (error)
                            return "serializableReadWrite." + error;
                    }
                }
                if (message.onlineReadOnly != null && message.hasOwnProperty("onlineReadOnly")) {
                    if (properties.txMode === 1)
                        return "txMode: multiple values";
                    properties.txMode = 1;
                    {
                        var error = $root.Ydb.Table.OnlineModeSettings.verify(message.onlineReadOnly);
                        if (error)
                            return "onlineReadOnly." + error;
                    }
                }
                if (message.staleReadOnly != null && message.hasOwnProperty("staleReadOnly")) {
                    if (properties.txMode === 1)
                        return "txMode: multiple values";
                    properties.txMode = 1;
                    {
                        var error = $root.Ydb.Table.StaleModeSettings.verify(message.staleReadOnly);
                        if (error)
                            return "staleReadOnly." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TransactionSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TransactionSettings} TransactionSettings
             */
            TransactionSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TransactionSettings)
                    return object;
                var message = new $root.Ydb.Table.TransactionSettings();
                if (object.serializableReadWrite != null) {
                    if (typeof object.serializableReadWrite !== "object")
                        throw TypeError(".Ydb.Table.TransactionSettings.serializableReadWrite: object expected");
                    message.serializableReadWrite = $root.Ydb.Table.SerializableModeSettings.fromObject(object.serializableReadWrite);
                }
                if (object.onlineReadOnly != null) {
                    if (typeof object.onlineReadOnly !== "object")
                        throw TypeError(".Ydb.Table.TransactionSettings.onlineReadOnly: object expected");
                    message.onlineReadOnly = $root.Ydb.Table.OnlineModeSettings.fromObject(object.onlineReadOnly);
                }
                if (object.staleReadOnly != null) {
                    if (typeof object.staleReadOnly !== "object")
                        throw TypeError(".Ydb.Table.TransactionSettings.staleReadOnly: object expected");
                    message.staleReadOnly = $root.Ydb.Table.StaleModeSettings.fromObject(object.staleReadOnly);
                }
                return message;
            };

            /**
             * Creates a plain object from a TransactionSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Ydb.Table.TransactionSettings} message TransactionSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransactionSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.serializableReadWrite != null && message.hasOwnProperty("serializableReadWrite")) {
                    object.serializableReadWrite = $root.Ydb.Table.SerializableModeSettings.toObject(message.serializableReadWrite, options);
                    if (options.oneofs)
                        object.txMode = "serializableReadWrite";
                }
                if (message.onlineReadOnly != null && message.hasOwnProperty("onlineReadOnly")) {
                    object.onlineReadOnly = $root.Ydb.Table.OnlineModeSettings.toObject(message.onlineReadOnly, options);
                    if (options.oneofs)
                        object.txMode = "onlineReadOnly";
                }
                if (message.staleReadOnly != null && message.hasOwnProperty("staleReadOnly")) {
                    object.staleReadOnly = $root.Ydb.Table.StaleModeSettings.toObject(message.staleReadOnly, options);
                    if (options.oneofs)
                        object.txMode = "staleReadOnly";
                }
                return object;
            };

            /**
             * Converts this TransactionSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransactionSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransactionSettings;
        })();

        Table.TransactionControl = (function() {

            /**
             * Properties of a TransactionControl.
             * @memberof Ydb.Table
             * @interface ITransactionControl
             * @property {string|null} [txId] TransactionControl txId
             * @property {Ydb.Table.ITransactionSettings|null} [beginTx] TransactionControl beginTx
             * @property {boolean|null} [commitTx] TransactionControl commitTx
             */

            /**
             * Constructs a new TransactionControl.
             * @memberof Ydb.Table
             * @classdesc Represents a TransactionControl.
             * @implements ITransactionControl
             * @constructor
             * @param {Ydb.Table.ITransactionControl=} [properties] Properties to set
             */
            function TransactionControl(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransactionControl txId.
             * @member {string} txId
             * @memberof Ydb.Table.TransactionControl
             * @instance
             */
            TransactionControl.prototype.txId = "";

            /**
             * TransactionControl beginTx.
             * @member {Ydb.Table.ITransactionSettings|null|undefined} beginTx
             * @memberof Ydb.Table.TransactionControl
             * @instance
             */
            TransactionControl.prototype.beginTx = null;

            /**
             * TransactionControl commitTx.
             * @member {boolean} commitTx
             * @memberof Ydb.Table.TransactionControl
             * @instance
             */
            TransactionControl.prototype.commitTx = false;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TransactionControl txSelector.
             * @member {"txId"|"beginTx"|undefined} txSelector
             * @memberof Ydb.Table.TransactionControl
             * @instance
             */
            Object.defineProperty(TransactionControl.prototype, "txSelector", {
                get: $util.oneOfGetter($oneOfFields = ["txId", "beginTx"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TransactionControl instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Ydb.Table.ITransactionControl=} [properties] Properties to set
             * @returns {Ydb.Table.TransactionControl} TransactionControl instance
             */
            TransactionControl.create = function create(properties) {
                return new TransactionControl(properties);
            };

            /**
             * Encodes the specified TransactionControl message. Does not implicitly {@link Ydb.Table.TransactionControl.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Ydb.Table.ITransactionControl} message TransactionControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionControl.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txId != null && message.hasOwnProperty("txId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.txId);
                if (message.beginTx != null && message.hasOwnProperty("beginTx"))
                    $root.Ydb.Table.TransactionSettings.encode(message.beginTx, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.commitTx != null && message.hasOwnProperty("commitTx"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.commitTx);
                return writer;
            };

            /**
             * Encodes the specified TransactionControl message, length delimited. Does not implicitly {@link Ydb.Table.TransactionControl.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Ydb.Table.ITransactionControl} message TransactionControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionControl.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransactionControl message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TransactionControl} TransactionControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionControl.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TransactionControl();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txId = reader.string();
                        break;
                    case 2:
                        message.beginTx = $root.Ydb.Table.TransactionSettings.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.commitTx = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransactionControl message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TransactionControl} TransactionControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionControl.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransactionControl message.
             * @function verify
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransactionControl.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.txId != null && message.hasOwnProperty("txId")) {
                    properties.txSelector = 1;
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                }
                if (message.beginTx != null && message.hasOwnProperty("beginTx")) {
                    if (properties.txSelector === 1)
                        return "txSelector: multiple values";
                    properties.txSelector = 1;
                    {
                        var error = $root.Ydb.Table.TransactionSettings.verify(message.beginTx);
                        if (error)
                            return "beginTx." + error;
                    }
                }
                if (message.commitTx != null && message.hasOwnProperty("commitTx"))
                    if (typeof message.commitTx !== "boolean")
                        return "commitTx: boolean expected";
                return null;
            };

            /**
             * Creates a TransactionControl message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TransactionControl} TransactionControl
             */
            TransactionControl.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TransactionControl)
                    return object;
                var message = new $root.Ydb.Table.TransactionControl();
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.beginTx != null) {
                    if (typeof object.beginTx !== "object")
                        throw TypeError(".Ydb.Table.TransactionControl.beginTx: object expected");
                    message.beginTx = $root.Ydb.Table.TransactionSettings.fromObject(object.beginTx);
                }
                if (object.commitTx != null)
                    message.commitTx = Boolean(object.commitTx);
                return message;
            };

            /**
             * Creates a plain object from a TransactionControl message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Ydb.Table.TransactionControl} message TransactionControl
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransactionControl.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.commitTx = false;
                if (message.txId != null && message.hasOwnProperty("txId")) {
                    object.txId = message.txId;
                    if (options.oneofs)
                        object.txSelector = "txId";
                }
                if (message.beginTx != null && message.hasOwnProperty("beginTx")) {
                    object.beginTx = $root.Ydb.Table.TransactionSettings.toObject(message.beginTx, options);
                    if (options.oneofs)
                        object.txSelector = "beginTx";
                }
                if (message.commitTx != null && message.hasOwnProperty("commitTx"))
                    object.commitTx = message.commitTx;
                return object;
            };

            /**
             * Converts this TransactionControl to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TransactionControl
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransactionControl.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransactionControl;
        })();

        Table.QueryCachePolicy = (function() {

            /**
             * Properties of a QueryCachePolicy.
             * @memberof Ydb.Table
             * @interface IQueryCachePolicy
             * @property {boolean|null} [keepInCache] QueryCachePolicy keepInCache
             */

            /**
             * Constructs a new QueryCachePolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a QueryCachePolicy.
             * @implements IQueryCachePolicy
             * @constructor
             * @param {Ydb.Table.IQueryCachePolicy=} [properties] Properties to set
             */
            function QueryCachePolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryCachePolicy keepInCache.
             * @member {boolean} keepInCache
             * @memberof Ydb.Table.QueryCachePolicy
             * @instance
             */
            QueryCachePolicy.prototype.keepInCache = false;

            /**
             * Creates a new QueryCachePolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Ydb.Table.IQueryCachePolicy=} [properties] Properties to set
             * @returns {Ydb.Table.QueryCachePolicy} QueryCachePolicy instance
             */
            QueryCachePolicy.create = function create(properties) {
                return new QueryCachePolicy(properties);
            };

            /**
             * Encodes the specified QueryCachePolicy message. Does not implicitly {@link Ydb.Table.QueryCachePolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Ydb.Table.IQueryCachePolicy} message QueryCachePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryCachePolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keepInCache != null && message.hasOwnProperty("keepInCache"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.keepInCache);
                return writer;
            };

            /**
             * Encodes the specified QueryCachePolicy message, length delimited. Does not implicitly {@link Ydb.Table.QueryCachePolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Ydb.Table.IQueryCachePolicy} message QueryCachePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryCachePolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryCachePolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.QueryCachePolicy} QueryCachePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryCachePolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.QueryCachePolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keepInCache = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryCachePolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.QueryCachePolicy} QueryCachePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryCachePolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryCachePolicy message.
             * @function verify
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryCachePolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keepInCache != null && message.hasOwnProperty("keepInCache"))
                    if (typeof message.keepInCache !== "boolean")
                        return "keepInCache: boolean expected";
                return null;
            };

            /**
             * Creates a QueryCachePolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.QueryCachePolicy} QueryCachePolicy
             */
            QueryCachePolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.QueryCachePolicy)
                    return object;
                var message = new $root.Ydb.Table.QueryCachePolicy();
                if (object.keepInCache != null)
                    message.keepInCache = Boolean(object.keepInCache);
                return message;
            };

            /**
             * Creates a plain object from a QueryCachePolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Ydb.Table.QueryCachePolicy} message QueryCachePolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryCachePolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.keepInCache = false;
                if (message.keepInCache != null && message.hasOwnProperty("keepInCache"))
                    object.keepInCache = message.keepInCache;
                return object;
            };

            /**
             * Converts this QueryCachePolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.QueryCachePolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryCachePolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryCachePolicy;
        })();

        Table.ExecuteDataQueryRequest = (function() {

            /**
             * Properties of an ExecuteDataQueryRequest.
             * @memberof Ydb.Table
             * @interface IExecuteDataQueryRequest
             * @property {string|null} [sessionId] ExecuteDataQueryRequest sessionId
             * @property {Ydb.Table.ITransactionControl|null} [txControl] ExecuteDataQueryRequest txControl
             * @property {Ydb.Table.IQuery|null} [query] ExecuteDataQueryRequest query
             * @property {Object.<string,Ydb.ITypedValue>|null} [parameters] ExecuteDataQueryRequest parameters
             * @property {Ydb.Table.IQueryCachePolicy|null} [queryCachePolicy] ExecuteDataQueryRequest queryCachePolicy
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExecuteDataQueryRequest operationParams
             * @property {Ydb.Table.ExecuteDataQueryRequest.StatsCollectionMode|null} [collectStats] ExecuteDataQueryRequest collectStats
             */

            /**
             * Constructs a new ExecuteDataQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteDataQueryRequest.
             * @implements IExecuteDataQueryRequest
             * @constructor
             * @param {Ydb.Table.IExecuteDataQueryRequest=} [properties] Properties to set
             */
            function ExecuteDataQueryRequest(properties) {
                this.parameters = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteDataQueryRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.sessionId = "";

            /**
             * ExecuteDataQueryRequest txControl.
             * @member {Ydb.Table.ITransactionControl|null|undefined} txControl
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.txControl = null;

            /**
             * ExecuteDataQueryRequest query.
             * @member {Ydb.Table.IQuery|null|undefined} query
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.query = null;

            /**
             * ExecuteDataQueryRequest parameters.
             * @member {Object.<string,Ydb.ITypedValue>} parameters
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.parameters = $util.emptyObject;

            /**
             * ExecuteDataQueryRequest queryCachePolicy.
             * @member {Ydb.Table.IQueryCachePolicy|null|undefined} queryCachePolicy
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.queryCachePolicy = null;

            /**
             * ExecuteDataQueryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.operationParams = null;

            /**
             * ExecuteDataQueryRequest collectStats.
             * @member {Ydb.Table.ExecuteDataQueryRequest.StatsCollectionMode} collectStats
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.collectStats = 0;

            /**
             * Creates a new ExecuteDataQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteDataQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteDataQueryRequest} ExecuteDataQueryRequest instance
             */
            ExecuteDataQueryRequest.create = function create(properties) {
                return new ExecuteDataQueryRequest(properties);
            };

            /**
             * Encodes the specified ExecuteDataQueryRequest message. Does not implicitly {@link Ydb.Table.ExecuteDataQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteDataQueryRequest} message ExecuteDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteDataQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.txControl != null && message.hasOwnProperty("txControl"))
                    $root.Ydb.Table.TransactionControl.encode(message.txControl, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.query != null && message.hasOwnProperty("query"))
                    $root.Ydb.Table.Query.encode(message.query, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.TypedValue.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.queryCachePolicy != null && message.hasOwnProperty("queryCachePolicy"))
                    $root.Ydb.Table.QueryCachePolicy.encode(message.queryCachePolicy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.collectStats);
                return writer;
            };

            /**
             * Encodes the specified ExecuteDataQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteDataQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteDataQueryRequest} message ExecuteDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteDataQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteDataQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteDataQueryRequest} ExecuteDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteDataQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteDataQueryRequest(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.txControl = $root.Ydb.Table.TransactionControl.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.query = $root.Ydb.Table.Query.decode(reader, reader.uint32());
                        break;
                    case 4:
                        reader.skip().pos++;
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        key = reader.string();
                        reader.pos++;
                        message.parameters[key] = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.queryCachePolicy = $root.Ydb.Table.QueryCachePolicy.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.collectStats = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteDataQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteDataQueryRequest} ExecuteDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteDataQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteDataQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteDataQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.txControl != null && message.hasOwnProperty("txControl")) {
                    var error = $root.Ydb.Table.TransactionControl.verify(message.txControl);
                    if (error)
                        return "txControl." + error;
                }
                if (message.query != null && message.hasOwnProperty("query")) {
                    var error = $root.Ydb.Table.Query.verify(message.query);
                    if (error)
                        return "query." + error;
                }
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!$util.isObject(message.parameters))
                        return "parameters: object expected";
                    var key = Object.keys(message.parameters);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.parameters[key[i]]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                if (message.queryCachePolicy != null && message.hasOwnProperty("queryCachePolicy")) {
                    var error = $root.Ydb.Table.QueryCachePolicy.verify(message.queryCachePolicy);
                    if (error)
                        return "queryCachePolicy." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    switch (message.collectStats) {
                    default:
                        return "collectStats: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates an ExecuteDataQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteDataQueryRequest} ExecuteDataQueryRequest
             */
            ExecuteDataQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteDataQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.ExecuteDataQueryRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.txControl != null) {
                    if (typeof object.txControl !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.txControl: object expected");
                    message.txControl = $root.Ydb.Table.TransactionControl.fromObject(object.txControl);
                }
                if (object.query != null) {
                    if (typeof object.query !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.query: object expected");
                    message.query = $root.Ydb.Table.Query.fromObject(object.query);
                }
                if (object.parameters) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.parameters: object expected");
                    message.parameters = {};
                    for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                        if (typeof object.parameters[keys[i]] !== "object")
                            throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.parameters: object expected");
                        message.parameters[keys[i]] = $root.Ydb.TypedValue.fromObject(object.parameters[keys[i]]);
                    }
                }
                if (object.queryCachePolicy != null) {
                    if (typeof object.queryCachePolicy !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.queryCachePolicy: object expected");
                    message.queryCachePolicy = $root.Ydb.Table.QueryCachePolicy.fromObject(object.queryCachePolicy);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                switch (object.collectStats) {
                case "STATS_COLLECTION_UNSPECIFIED":
                case 0:
                    message.collectStats = 0;
                    break;
                case "STATS_COLLECTION_NONE":
                case 1:
                    message.collectStats = 1;
                    break;
                case "STATS_COLLECTION_BASIC":
                case 2:
                    message.collectStats = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteDataQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Ydb.Table.ExecuteDataQueryRequest} message ExecuteDataQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteDataQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parameters = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.txControl = null;
                    object.query = null;
                    object.queryCachePolicy = null;
                    object.operationParams = null;
                    object.collectStats = options.enums === String ? "STATS_COLLECTION_UNSPECIFIED" : 0;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.txControl != null && message.hasOwnProperty("txControl"))
                    object.txControl = $root.Ydb.Table.TransactionControl.toObject(message.txControl, options);
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = $root.Ydb.Table.Query.toObject(message.query, options);
                var keys2;
                if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                    object.parameters = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parameters[keys2[j]] = $root.Ydb.TypedValue.toObject(message.parameters[keys2[j]], options);
                }
                if (message.queryCachePolicy != null && message.hasOwnProperty("queryCachePolicy"))
                    object.queryCachePolicy = $root.Ydb.Table.QueryCachePolicy.toObject(message.queryCachePolicy, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    object.collectStats = options.enums === String ? $root.Ydb.Table.ExecuteDataQueryRequest.StatsCollectionMode[message.collectStats] : message.collectStats;
                return object;
            };

            /**
             * Converts this ExecuteDataQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteDataQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * StatsCollectionMode enum.
             * @name Ydb.Table.ExecuteDataQueryRequest.StatsCollectionMode
             * @enum {string}
             * @property {number} STATS_COLLECTION_UNSPECIFIED=0 STATS_COLLECTION_UNSPECIFIED value
             * @property {number} STATS_COLLECTION_NONE=1 STATS_COLLECTION_NONE value
             * @property {number} STATS_COLLECTION_BASIC=2 STATS_COLLECTION_BASIC value
             */
            ExecuteDataQueryRequest.StatsCollectionMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STATS_COLLECTION_UNSPECIFIED"] = 0;
                values[valuesById[1] = "STATS_COLLECTION_NONE"] = 1;
                values[valuesById[2] = "STATS_COLLECTION_BASIC"] = 2;
                return values;
            })();

            return ExecuteDataQueryRequest;
        })();

        Table.ExecuteDataQueryResponse = (function() {

            /**
             * Properties of an ExecuteDataQueryResponse.
             * @memberof Ydb.Table
             * @interface IExecuteDataQueryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExecuteDataQueryResponse operation
             */

            /**
             * Constructs a new ExecuteDataQueryResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteDataQueryResponse.
             * @implements IExecuteDataQueryResponse
             * @constructor
             * @param {Ydb.Table.IExecuteDataQueryResponse=} [properties] Properties to set
             */
            function ExecuteDataQueryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteDataQueryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @instance
             */
            ExecuteDataQueryResponse.prototype.operation = null;

            /**
             * Creates a new ExecuteDataQueryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteDataQueryResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteDataQueryResponse} ExecuteDataQueryResponse instance
             */
            ExecuteDataQueryResponse.create = function create(properties) {
                return new ExecuteDataQueryResponse(properties);
            };

            /**
             * Encodes the specified ExecuteDataQueryResponse message. Does not implicitly {@link Ydb.Table.ExecuteDataQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteDataQueryResponse} message ExecuteDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteDataQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteDataQueryResponse message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteDataQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteDataQueryResponse} message ExecuteDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteDataQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteDataQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteDataQueryResponse} ExecuteDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteDataQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteDataQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteDataQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteDataQueryResponse} ExecuteDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteDataQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteDataQueryResponse message.
             * @function verify
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteDataQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteDataQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteDataQueryResponse} ExecuteDataQueryResponse
             */
            ExecuteDataQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteDataQueryResponse)
                    return object;
                var message = new $root.Ydb.Table.ExecuteDataQueryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteDataQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Ydb.Table.ExecuteDataQueryResponse} message ExecuteDataQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteDataQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExecuteDataQueryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteDataQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteDataQueryResponse;
        })();

        Table.ExecuteSchemeQueryRequest = (function() {

            /**
             * Properties of an ExecuteSchemeQueryRequest.
             * @memberof Ydb.Table
             * @interface IExecuteSchemeQueryRequest
             * @property {string|null} [sessionId] ExecuteSchemeQueryRequest sessionId
             * @property {string|null} [yqlText] ExecuteSchemeQueryRequest yqlText
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExecuteSchemeQueryRequest operationParams
             */

            /**
             * Constructs a new ExecuteSchemeQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteSchemeQueryRequest.
             * @implements IExecuteSchemeQueryRequest
             * @constructor
             * @param {Ydb.Table.IExecuteSchemeQueryRequest=} [properties] Properties to set
             */
            function ExecuteSchemeQueryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteSchemeQueryRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @instance
             */
            ExecuteSchemeQueryRequest.prototype.sessionId = "";

            /**
             * ExecuteSchemeQueryRequest yqlText.
             * @member {string} yqlText
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @instance
             */
            ExecuteSchemeQueryRequest.prototype.yqlText = "";

            /**
             * ExecuteSchemeQueryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @instance
             */
            ExecuteSchemeQueryRequest.prototype.operationParams = null;

            /**
             * Creates a new ExecuteSchemeQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteSchemeQueryRequest} ExecuteSchemeQueryRequest instance
             */
            ExecuteSchemeQueryRequest.create = function create(properties) {
                return new ExecuteSchemeQueryRequest(properties);
            };

            /**
             * Encodes the specified ExecuteSchemeQueryRequest message. Does not implicitly {@link Ydb.Table.ExecuteSchemeQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryRequest} message ExecuteSchemeQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteSchemeQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.yqlText);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteSchemeQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteSchemeQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryRequest} message ExecuteSchemeQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteSchemeQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteSchemeQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteSchemeQueryRequest} ExecuteSchemeQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteSchemeQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteSchemeQueryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.yqlText = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteSchemeQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteSchemeQueryRequest} ExecuteSchemeQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteSchemeQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteSchemeQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteSchemeQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    if (!$util.isString(message.yqlText))
                        return "yqlText: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteSchemeQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteSchemeQueryRequest} ExecuteSchemeQueryRequest
             */
            ExecuteSchemeQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteSchemeQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.ExecuteSchemeQueryRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.yqlText != null)
                    message.yqlText = String(object.yqlText);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.ExecuteSchemeQueryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteSchemeQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Ydb.Table.ExecuteSchemeQueryRequest} message ExecuteSchemeQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteSchemeQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.yqlText = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    object.yqlText = message.yqlText;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this ExecuteSchemeQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteSchemeQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteSchemeQueryRequest;
        })();

        Table.ExecuteSchemeQueryResponse = (function() {

            /**
             * Properties of an ExecuteSchemeQueryResponse.
             * @memberof Ydb.Table
             * @interface IExecuteSchemeQueryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExecuteSchemeQueryResponse operation
             */

            /**
             * Constructs a new ExecuteSchemeQueryResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteSchemeQueryResponse.
             * @implements IExecuteSchemeQueryResponse
             * @constructor
             * @param {Ydb.Table.IExecuteSchemeQueryResponse=} [properties] Properties to set
             */
            function ExecuteSchemeQueryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteSchemeQueryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @instance
             */
            ExecuteSchemeQueryResponse.prototype.operation = null;

            /**
             * Creates a new ExecuteSchemeQueryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteSchemeQueryResponse} ExecuteSchemeQueryResponse instance
             */
            ExecuteSchemeQueryResponse.create = function create(properties) {
                return new ExecuteSchemeQueryResponse(properties);
            };

            /**
             * Encodes the specified ExecuteSchemeQueryResponse message. Does not implicitly {@link Ydb.Table.ExecuteSchemeQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryResponse} message ExecuteSchemeQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteSchemeQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteSchemeQueryResponse message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteSchemeQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryResponse} message ExecuteSchemeQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteSchemeQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteSchemeQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteSchemeQueryResponse} ExecuteSchemeQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteSchemeQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteSchemeQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteSchemeQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteSchemeQueryResponse} ExecuteSchemeQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteSchemeQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteSchemeQueryResponse message.
             * @function verify
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteSchemeQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteSchemeQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteSchemeQueryResponse} ExecuteSchemeQueryResponse
             */
            ExecuteSchemeQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteSchemeQueryResponse)
                    return object;
                var message = new $root.Ydb.Table.ExecuteSchemeQueryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.ExecuteSchemeQueryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteSchemeQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Ydb.Table.ExecuteSchemeQueryResponse} message ExecuteSchemeQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteSchemeQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExecuteSchemeQueryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteSchemeQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteSchemeQueryResponse;
        })();

        Table.TransactionMeta = (function() {

            /**
             * Properties of a TransactionMeta.
             * @memberof Ydb.Table
             * @interface ITransactionMeta
             * @property {string|null} [id] TransactionMeta id
             */

            /**
             * Constructs a new TransactionMeta.
             * @memberof Ydb.Table
             * @classdesc Represents a TransactionMeta.
             * @implements ITransactionMeta
             * @constructor
             * @param {Ydb.Table.ITransactionMeta=} [properties] Properties to set
             */
            function TransactionMeta(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransactionMeta id.
             * @member {string} id
             * @memberof Ydb.Table.TransactionMeta
             * @instance
             */
            TransactionMeta.prototype.id = "";

            /**
             * Creates a new TransactionMeta instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Ydb.Table.ITransactionMeta=} [properties] Properties to set
             * @returns {Ydb.Table.TransactionMeta} TransactionMeta instance
             */
            TransactionMeta.create = function create(properties) {
                return new TransactionMeta(properties);
            };

            /**
             * Encodes the specified TransactionMeta message. Does not implicitly {@link Ydb.Table.TransactionMeta.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Ydb.Table.ITransactionMeta} message TransactionMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified TransactionMeta message, length delimited. Does not implicitly {@link Ydb.Table.TransactionMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Ydb.Table.ITransactionMeta} message TransactionMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransactionMeta message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TransactionMeta} TransactionMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TransactionMeta();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransactionMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TransactionMeta} TransactionMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransactionMeta message.
             * @function verify
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransactionMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a TransactionMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TransactionMeta} TransactionMeta
             */
            TransactionMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TransactionMeta)
                    return object;
                var message = new $root.Ydb.Table.TransactionMeta();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a TransactionMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Ydb.Table.TransactionMeta} message TransactionMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransactionMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this TransactionMeta to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TransactionMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransactionMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransactionMeta;
        })();

        Table.QueryMeta = (function() {

            /**
             * Properties of a QueryMeta.
             * @memberof Ydb.Table
             * @interface IQueryMeta
             * @property {string|null} [id] QueryMeta id
             * @property {Object.<string,Ydb.IType>|null} [parametersTypes] QueryMeta parametersTypes
             */

            /**
             * Constructs a new QueryMeta.
             * @memberof Ydb.Table
             * @classdesc Represents a QueryMeta.
             * @implements IQueryMeta
             * @constructor
             * @param {Ydb.Table.IQueryMeta=} [properties] Properties to set
             */
            function QueryMeta(properties) {
                this.parametersTypes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryMeta id.
             * @member {string} id
             * @memberof Ydb.Table.QueryMeta
             * @instance
             */
            QueryMeta.prototype.id = "";

            /**
             * QueryMeta parametersTypes.
             * @member {Object.<string,Ydb.IType>} parametersTypes
             * @memberof Ydb.Table.QueryMeta
             * @instance
             */
            QueryMeta.prototype.parametersTypes = $util.emptyObject;

            /**
             * Creates a new QueryMeta instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Ydb.Table.IQueryMeta=} [properties] Properties to set
             * @returns {Ydb.Table.QueryMeta} QueryMeta instance
             */
            QueryMeta.create = function create(properties) {
                return new QueryMeta(properties);
            };

            /**
             * Encodes the specified QueryMeta message. Does not implicitly {@link Ydb.Table.QueryMeta.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Ydb.Table.IQueryMeta} message QueryMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.parametersTypes != null && message.hasOwnProperty("parametersTypes"))
                    for (var keys = Object.keys(message.parametersTypes), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.Type.encode(message.parametersTypes[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified QueryMeta message, length delimited. Does not implicitly {@link Ydb.Table.QueryMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Ydb.Table.IQueryMeta} message QueryMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryMeta message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.QueryMeta} QueryMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.QueryMeta(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.parametersTypes === $util.emptyObject)
                            message.parametersTypes = {};
                        key = reader.string();
                        reader.pos++;
                        message.parametersTypes[key] = $root.Ydb.Type.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.QueryMeta} QueryMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryMeta message.
             * @function verify
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.parametersTypes != null && message.hasOwnProperty("parametersTypes")) {
                    if (!$util.isObject(message.parametersTypes))
                        return "parametersTypes: object expected";
                    var key = Object.keys(message.parametersTypes);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.Type.verify(message.parametersTypes[key[i]]);
                        if (error)
                            return "parametersTypes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.QueryMeta} QueryMeta
             */
            QueryMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.QueryMeta)
                    return object;
                var message = new $root.Ydb.Table.QueryMeta();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.parametersTypes) {
                    if (typeof object.parametersTypes !== "object")
                        throw TypeError(".Ydb.Table.QueryMeta.parametersTypes: object expected");
                    message.parametersTypes = {};
                    for (var keys = Object.keys(object.parametersTypes), i = 0; i < keys.length; ++i) {
                        if (typeof object.parametersTypes[keys[i]] !== "object")
                            throw TypeError(".Ydb.Table.QueryMeta.parametersTypes: object expected");
                        message.parametersTypes[keys[i]] = $root.Ydb.Type.fromObject(object.parametersTypes[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Ydb.Table.QueryMeta} message QueryMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parametersTypes = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                var keys2;
                if (message.parametersTypes && (keys2 = Object.keys(message.parametersTypes)).length) {
                    object.parametersTypes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parametersTypes[keys2[j]] = $root.Ydb.Type.toObject(message.parametersTypes[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this QueryMeta to JSON.
             * @function toJSON
             * @memberof Ydb.Table.QueryMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryMeta;
        })();

        Table.ExecuteQueryResult = (function() {

            /**
             * Properties of an ExecuteQueryResult.
             * @memberof Ydb.Table
             * @interface IExecuteQueryResult
             * @property {Array.<Ydb.IResultSet>|null} [resultSets] ExecuteQueryResult resultSets
             * @property {Ydb.Table.ITransactionMeta|null} [txMeta] ExecuteQueryResult txMeta
             * @property {Ydb.Table.IQueryMeta|null} [queryMeta] ExecuteQueryResult queryMeta
             * @property {Ydb.TableStats.IQueryStats|null} [queryStats] ExecuteQueryResult queryStats
             */

            /**
             * Constructs a new ExecuteQueryResult.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteQueryResult.
             * @implements IExecuteQueryResult
             * @constructor
             * @param {Ydb.Table.IExecuteQueryResult=} [properties] Properties to set
             */
            function ExecuteQueryResult(properties) {
                this.resultSets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteQueryResult resultSets.
             * @member {Array.<Ydb.IResultSet>} resultSets
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             */
            ExecuteQueryResult.prototype.resultSets = $util.emptyArray;

            /**
             * ExecuteQueryResult txMeta.
             * @member {Ydb.Table.ITransactionMeta|null|undefined} txMeta
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             */
            ExecuteQueryResult.prototype.txMeta = null;

            /**
             * ExecuteQueryResult queryMeta.
             * @member {Ydb.Table.IQueryMeta|null|undefined} queryMeta
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             */
            ExecuteQueryResult.prototype.queryMeta = null;

            /**
             * ExecuteQueryResult queryStats.
             * @member {Ydb.TableStats.IQueryStats|null|undefined} queryStats
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             */
            ExecuteQueryResult.prototype.queryStats = null;

            /**
             * Creates a new ExecuteQueryResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Ydb.Table.IExecuteQueryResult=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteQueryResult} ExecuteQueryResult instance
             */
            ExecuteQueryResult.create = function create(properties) {
                return new ExecuteQueryResult(properties);
            };

            /**
             * Encodes the specified ExecuteQueryResult message. Does not implicitly {@link Ydb.Table.ExecuteQueryResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Ydb.Table.IExecuteQueryResult} message ExecuteQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultSets != null && message.resultSets.length)
                    for (var i = 0; i < message.resultSets.length; ++i)
                        $root.Ydb.ResultSet.encode(message.resultSets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.txMeta != null && message.hasOwnProperty("txMeta"))
                    $root.Ydb.Table.TransactionMeta.encode(message.txMeta, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.queryMeta != null && message.hasOwnProperty("queryMeta"))
                    $root.Ydb.Table.QueryMeta.encode(message.queryMeta, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.queryStats != null && message.hasOwnProperty("queryStats"))
                    $root.Ydb.TableStats.QueryStats.encode(message.queryStats, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteQueryResult message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Ydb.Table.IExecuteQueryResult} message ExecuteQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteQueryResult} ExecuteQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteQueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.resultSets && message.resultSets.length))
                            message.resultSets = [];
                        message.resultSets.push($root.Ydb.ResultSet.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.txMeta = $root.Ydb.Table.TransactionMeta.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.queryMeta = $root.Ydb.Table.QueryMeta.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.queryStats = $root.Ydb.TableStats.QueryStats.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteQueryResult} ExecuteQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteQueryResult message.
             * @function verify
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultSets != null && message.hasOwnProperty("resultSets")) {
                    if (!Array.isArray(message.resultSets))
                        return "resultSets: array expected";
                    for (var i = 0; i < message.resultSets.length; ++i) {
                        var error = $root.Ydb.ResultSet.verify(message.resultSets[i]);
                        if (error)
                            return "resultSets." + error;
                    }
                }
                if (message.txMeta != null && message.hasOwnProperty("txMeta")) {
                    var error = $root.Ydb.Table.TransactionMeta.verify(message.txMeta);
                    if (error)
                        return "txMeta." + error;
                }
                if (message.queryMeta != null && message.hasOwnProperty("queryMeta")) {
                    var error = $root.Ydb.Table.QueryMeta.verify(message.queryMeta);
                    if (error)
                        return "queryMeta." + error;
                }
                if (message.queryStats != null && message.hasOwnProperty("queryStats")) {
                    var error = $root.Ydb.TableStats.QueryStats.verify(message.queryStats);
                    if (error)
                        return "queryStats." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteQueryResult} ExecuteQueryResult
             */
            ExecuteQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteQueryResult)
                    return object;
                var message = new $root.Ydb.Table.ExecuteQueryResult();
                if (object.resultSets) {
                    if (!Array.isArray(object.resultSets))
                        throw TypeError(".Ydb.Table.ExecuteQueryResult.resultSets: array expected");
                    message.resultSets = [];
                    for (var i = 0; i < object.resultSets.length; ++i) {
                        if (typeof object.resultSets[i] !== "object")
                            throw TypeError(".Ydb.Table.ExecuteQueryResult.resultSets: object expected");
                        message.resultSets[i] = $root.Ydb.ResultSet.fromObject(object.resultSets[i]);
                    }
                }
                if (object.txMeta != null) {
                    if (typeof object.txMeta !== "object")
                        throw TypeError(".Ydb.Table.ExecuteQueryResult.txMeta: object expected");
                    message.txMeta = $root.Ydb.Table.TransactionMeta.fromObject(object.txMeta);
                }
                if (object.queryMeta != null) {
                    if (typeof object.queryMeta !== "object")
                        throw TypeError(".Ydb.Table.ExecuteQueryResult.queryMeta: object expected");
                    message.queryMeta = $root.Ydb.Table.QueryMeta.fromObject(object.queryMeta);
                }
                if (object.queryStats != null) {
                    if (typeof object.queryStats !== "object")
                        throw TypeError(".Ydb.Table.ExecuteQueryResult.queryStats: object expected");
                    message.queryStats = $root.Ydb.TableStats.QueryStats.fromObject(object.queryStats);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Ydb.Table.ExecuteQueryResult} message ExecuteQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.resultSets = [];
                if (options.defaults) {
                    object.txMeta = null;
                    object.queryMeta = null;
                    object.queryStats = null;
                }
                if (message.resultSets && message.resultSets.length) {
                    object.resultSets = [];
                    for (var j = 0; j < message.resultSets.length; ++j)
                        object.resultSets[j] = $root.Ydb.ResultSet.toObject(message.resultSets[j], options);
                }
                if (message.txMeta != null && message.hasOwnProperty("txMeta"))
                    object.txMeta = $root.Ydb.Table.TransactionMeta.toObject(message.txMeta, options);
                if (message.queryMeta != null && message.hasOwnProperty("queryMeta"))
                    object.queryMeta = $root.Ydb.Table.QueryMeta.toObject(message.queryMeta, options);
                if (message.queryStats != null && message.hasOwnProperty("queryStats"))
                    object.queryStats = $root.Ydb.TableStats.QueryStats.toObject(message.queryStats, options);
                return object;
            };

            /**
             * Converts this ExecuteQueryResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteQueryResult;
        })();

        Table.ExplainDataQueryRequest = (function() {

            /**
             * Properties of an ExplainDataQueryRequest.
             * @memberof Ydb.Table
             * @interface IExplainDataQueryRequest
             * @property {string|null} [sessionId] ExplainDataQueryRequest sessionId
             * @property {string|null} [yqlText] ExplainDataQueryRequest yqlText
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExplainDataQueryRequest operationParams
             */

            /**
             * Constructs a new ExplainDataQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an ExplainDataQueryRequest.
             * @implements IExplainDataQueryRequest
             * @constructor
             * @param {Ydb.Table.IExplainDataQueryRequest=} [properties] Properties to set
             */
            function ExplainDataQueryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplainDataQueryRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @instance
             */
            ExplainDataQueryRequest.prototype.sessionId = "";

            /**
             * ExplainDataQueryRequest yqlText.
             * @member {string} yqlText
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @instance
             */
            ExplainDataQueryRequest.prototype.yqlText = "";

            /**
             * ExplainDataQueryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @instance
             */
            ExplainDataQueryRequest.prototype.operationParams = null;

            /**
             * Creates a new ExplainDataQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Ydb.Table.IExplainDataQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ExplainDataQueryRequest} ExplainDataQueryRequest instance
             */
            ExplainDataQueryRequest.create = function create(properties) {
                return new ExplainDataQueryRequest(properties);
            };

            /**
             * Encodes the specified ExplainDataQueryRequest message. Does not implicitly {@link Ydb.Table.ExplainDataQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Ydb.Table.IExplainDataQueryRequest} message ExplainDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainDataQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.yqlText);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExplainDataQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.ExplainDataQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Ydb.Table.IExplainDataQueryRequest} message ExplainDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainDataQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplainDataQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExplainDataQueryRequest} ExplainDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainDataQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExplainDataQueryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.yqlText = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplainDataQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExplainDataQueryRequest} ExplainDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainDataQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplainDataQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplainDataQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    if (!$util.isString(message.yqlText))
                        return "yqlText: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates an ExplainDataQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExplainDataQueryRequest} ExplainDataQueryRequest
             */
            ExplainDataQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExplainDataQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.ExplainDataQueryRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.yqlText != null)
                    message.yqlText = String(object.yqlText);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.ExplainDataQueryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExplainDataQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Ydb.Table.ExplainDataQueryRequest} message ExplainDataQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplainDataQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.yqlText = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    object.yqlText = message.yqlText;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this ExplainDataQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplainDataQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplainDataQueryRequest;
        })();

        Table.ExplainDataQueryResponse = (function() {

            /**
             * Properties of an ExplainDataQueryResponse.
             * @memberof Ydb.Table
             * @interface IExplainDataQueryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExplainDataQueryResponse operation
             */

            /**
             * Constructs a new ExplainDataQueryResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an ExplainDataQueryResponse.
             * @implements IExplainDataQueryResponse
             * @constructor
             * @param {Ydb.Table.IExplainDataQueryResponse=} [properties] Properties to set
             */
            function ExplainDataQueryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplainDataQueryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @instance
             */
            ExplainDataQueryResponse.prototype.operation = null;

            /**
             * Creates a new ExplainDataQueryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Ydb.Table.IExplainDataQueryResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ExplainDataQueryResponse} ExplainDataQueryResponse instance
             */
            ExplainDataQueryResponse.create = function create(properties) {
                return new ExplainDataQueryResponse(properties);
            };

            /**
             * Encodes the specified ExplainDataQueryResponse message. Does not implicitly {@link Ydb.Table.ExplainDataQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Ydb.Table.IExplainDataQueryResponse} message ExplainDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainDataQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExplainDataQueryResponse message, length delimited. Does not implicitly {@link Ydb.Table.ExplainDataQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Ydb.Table.IExplainDataQueryResponse} message ExplainDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainDataQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplainDataQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExplainDataQueryResponse} ExplainDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainDataQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExplainDataQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplainDataQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExplainDataQueryResponse} ExplainDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainDataQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplainDataQueryResponse message.
             * @function verify
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplainDataQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExplainDataQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExplainDataQueryResponse} ExplainDataQueryResponse
             */
            ExplainDataQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExplainDataQueryResponse)
                    return object;
                var message = new $root.Ydb.Table.ExplainDataQueryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.ExplainDataQueryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExplainDataQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Ydb.Table.ExplainDataQueryResponse} message ExplainDataQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplainDataQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExplainDataQueryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplainDataQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplainDataQueryResponse;
        })();

        Table.ExplainQueryResult = (function() {

            /**
             * Properties of an ExplainQueryResult.
             * @memberof Ydb.Table
             * @interface IExplainQueryResult
             * @property {string|null} [queryAst] ExplainQueryResult queryAst
             * @property {string|null} [queryPlan] ExplainQueryResult queryPlan
             */

            /**
             * Constructs a new ExplainQueryResult.
             * @memberof Ydb.Table
             * @classdesc Represents an ExplainQueryResult.
             * @implements IExplainQueryResult
             * @constructor
             * @param {Ydb.Table.IExplainQueryResult=} [properties] Properties to set
             */
            function ExplainQueryResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplainQueryResult queryAst.
             * @member {string} queryAst
             * @memberof Ydb.Table.ExplainQueryResult
             * @instance
             */
            ExplainQueryResult.prototype.queryAst = "";

            /**
             * ExplainQueryResult queryPlan.
             * @member {string} queryPlan
             * @memberof Ydb.Table.ExplainQueryResult
             * @instance
             */
            ExplainQueryResult.prototype.queryPlan = "";

            /**
             * Creates a new ExplainQueryResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Ydb.Table.IExplainQueryResult=} [properties] Properties to set
             * @returns {Ydb.Table.ExplainQueryResult} ExplainQueryResult instance
             */
            ExplainQueryResult.create = function create(properties) {
                return new ExplainQueryResult(properties);
            };

            /**
             * Encodes the specified ExplainQueryResult message. Does not implicitly {@link Ydb.Table.ExplainQueryResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Ydb.Table.IExplainQueryResult} message ExplainQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queryAst != null && message.hasOwnProperty("queryAst"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queryAst);
                if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queryPlan);
                return writer;
            };

            /**
             * Encodes the specified ExplainQueryResult message, length delimited. Does not implicitly {@link Ydb.Table.ExplainQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Ydb.Table.IExplainQueryResult} message ExplainQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplainQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExplainQueryResult} ExplainQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExplainQueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queryAst = reader.string();
                        break;
                    case 2:
                        message.queryPlan = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplainQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExplainQueryResult} ExplainQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplainQueryResult message.
             * @function verify
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplainQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queryAst != null && message.hasOwnProperty("queryAst"))
                    if (!$util.isString(message.queryAst))
                        return "queryAst: string expected";
                if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
                    if (!$util.isString(message.queryPlan))
                        return "queryPlan: string expected";
                return null;
            };

            /**
             * Creates an ExplainQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExplainQueryResult} ExplainQueryResult
             */
            ExplainQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExplainQueryResult)
                    return object;
                var message = new $root.Ydb.Table.ExplainQueryResult();
                if (object.queryAst != null)
                    message.queryAst = String(object.queryAst);
                if (object.queryPlan != null)
                    message.queryPlan = String(object.queryPlan);
                return message;
            };

            /**
             * Creates a plain object from an ExplainQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Ydb.Table.ExplainQueryResult} message ExplainQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplainQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queryAst = "";
                    object.queryPlan = "";
                }
                if (message.queryAst != null && message.hasOwnProperty("queryAst"))
                    object.queryAst = message.queryAst;
                if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
                    object.queryPlan = message.queryPlan;
                return object;
            };

            /**
             * Converts this ExplainQueryResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExplainQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplainQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplainQueryResult;
        })();

        Table.PrepareDataQueryRequest = (function() {

            /**
             * Properties of a PrepareDataQueryRequest.
             * @memberof Ydb.Table
             * @interface IPrepareDataQueryRequest
             * @property {string|null} [sessionId] PrepareDataQueryRequest sessionId
             * @property {string|null} [yqlText] PrepareDataQueryRequest yqlText
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] PrepareDataQueryRequest operationParams
             */

            /**
             * Constructs a new PrepareDataQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a PrepareDataQueryRequest.
             * @implements IPrepareDataQueryRequest
             * @constructor
             * @param {Ydb.Table.IPrepareDataQueryRequest=} [properties] Properties to set
             */
            function PrepareDataQueryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrepareDataQueryRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @instance
             */
            PrepareDataQueryRequest.prototype.sessionId = "";

            /**
             * PrepareDataQueryRequest yqlText.
             * @member {string} yqlText
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @instance
             */
            PrepareDataQueryRequest.prototype.yqlText = "";

            /**
             * PrepareDataQueryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @instance
             */
            PrepareDataQueryRequest.prototype.operationParams = null;

            /**
             * Creates a new PrepareDataQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Ydb.Table.IPrepareDataQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.PrepareDataQueryRequest} PrepareDataQueryRequest instance
             */
            PrepareDataQueryRequest.create = function create(properties) {
                return new PrepareDataQueryRequest(properties);
            };

            /**
             * Encodes the specified PrepareDataQueryRequest message. Does not implicitly {@link Ydb.Table.PrepareDataQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Ydb.Table.IPrepareDataQueryRequest} message PrepareDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareDataQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.yqlText);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PrepareDataQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.PrepareDataQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Ydb.Table.IPrepareDataQueryRequest} message PrepareDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareDataQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrepareDataQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PrepareDataQueryRequest} PrepareDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareDataQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PrepareDataQueryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.yqlText = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrepareDataQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PrepareDataQueryRequest} PrepareDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareDataQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrepareDataQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrepareDataQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    if (!$util.isString(message.yqlText))
                        return "yqlText: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a PrepareDataQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PrepareDataQueryRequest} PrepareDataQueryRequest
             */
            PrepareDataQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PrepareDataQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.PrepareDataQueryRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.yqlText != null)
                    message.yqlText = String(object.yqlText);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.PrepareDataQueryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a PrepareDataQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Ydb.Table.PrepareDataQueryRequest} message PrepareDataQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrepareDataQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.yqlText = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    object.yqlText = message.yqlText;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this PrepareDataQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrepareDataQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrepareDataQueryRequest;
        })();

        Table.PrepareDataQueryResponse = (function() {

            /**
             * Properties of a PrepareDataQueryResponse.
             * @memberof Ydb.Table
             * @interface IPrepareDataQueryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] PrepareDataQueryResponse operation
             */

            /**
             * Constructs a new PrepareDataQueryResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a PrepareDataQueryResponse.
             * @implements IPrepareDataQueryResponse
             * @constructor
             * @param {Ydb.Table.IPrepareDataQueryResponse=} [properties] Properties to set
             */
            function PrepareDataQueryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrepareDataQueryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @instance
             */
            PrepareDataQueryResponse.prototype.operation = null;

            /**
             * Creates a new PrepareDataQueryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Ydb.Table.IPrepareDataQueryResponse=} [properties] Properties to set
             * @returns {Ydb.Table.PrepareDataQueryResponse} PrepareDataQueryResponse instance
             */
            PrepareDataQueryResponse.create = function create(properties) {
                return new PrepareDataQueryResponse(properties);
            };

            /**
             * Encodes the specified PrepareDataQueryResponse message. Does not implicitly {@link Ydb.Table.PrepareDataQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Ydb.Table.IPrepareDataQueryResponse} message PrepareDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareDataQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PrepareDataQueryResponse message, length delimited. Does not implicitly {@link Ydb.Table.PrepareDataQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Ydb.Table.IPrepareDataQueryResponse} message PrepareDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareDataQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrepareDataQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PrepareDataQueryResponse} PrepareDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareDataQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PrepareDataQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrepareDataQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PrepareDataQueryResponse} PrepareDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareDataQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrepareDataQueryResponse message.
             * @function verify
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrepareDataQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a PrepareDataQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PrepareDataQueryResponse} PrepareDataQueryResponse
             */
            PrepareDataQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PrepareDataQueryResponse)
                    return object;
                var message = new $root.Ydb.Table.PrepareDataQueryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.PrepareDataQueryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a PrepareDataQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Ydb.Table.PrepareDataQueryResponse} message PrepareDataQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrepareDataQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this PrepareDataQueryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrepareDataQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrepareDataQueryResponse;
        })();

        Table.PrepareQueryResult = (function() {

            /**
             * Properties of a PrepareQueryResult.
             * @memberof Ydb.Table
             * @interface IPrepareQueryResult
             * @property {string|null} [queryId] PrepareQueryResult queryId
             * @property {Object.<string,Ydb.IType>|null} [parametersTypes] PrepareQueryResult parametersTypes
             */

            /**
             * Constructs a new PrepareQueryResult.
             * @memberof Ydb.Table
             * @classdesc Represents a PrepareQueryResult.
             * @implements IPrepareQueryResult
             * @constructor
             * @param {Ydb.Table.IPrepareQueryResult=} [properties] Properties to set
             */
            function PrepareQueryResult(properties) {
                this.parametersTypes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrepareQueryResult queryId.
             * @member {string} queryId
             * @memberof Ydb.Table.PrepareQueryResult
             * @instance
             */
            PrepareQueryResult.prototype.queryId = "";

            /**
             * PrepareQueryResult parametersTypes.
             * @member {Object.<string,Ydb.IType>} parametersTypes
             * @memberof Ydb.Table.PrepareQueryResult
             * @instance
             */
            PrepareQueryResult.prototype.parametersTypes = $util.emptyObject;

            /**
             * Creates a new PrepareQueryResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Ydb.Table.IPrepareQueryResult=} [properties] Properties to set
             * @returns {Ydb.Table.PrepareQueryResult} PrepareQueryResult instance
             */
            PrepareQueryResult.create = function create(properties) {
                return new PrepareQueryResult(properties);
            };

            /**
             * Encodes the specified PrepareQueryResult message. Does not implicitly {@link Ydb.Table.PrepareQueryResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Ydb.Table.IPrepareQueryResult} message PrepareQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queryId != null && message.hasOwnProperty("queryId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queryId);
                if (message.parametersTypes != null && message.hasOwnProperty("parametersTypes"))
                    for (var keys = Object.keys(message.parametersTypes), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.Type.encode(message.parametersTypes[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified PrepareQueryResult message, length delimited. Does not implicitly {@link Ydb.Table.PrepareQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Ydb.Table.IPrepareQueryResult} message PrepareQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrepareQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PrepareQueryResult} PrepareQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PrepareQueryResult(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queryId = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.parametersTypes === $util.emptyObject)
                            message.parametersTypes = {};
                        key = reader.string();
                        reader.pos++;
                        message.parametersTypes[key] = $root.Ydb.Type.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrepareQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PrepareQueryResult} PrepareQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrepareQueryResult message.
             * @function verify
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrepareQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queryId != null && message.hasOwnProperty("queryId"))
                    if (!$util.isString(message.queryId))
                        return "queryId: string expected";
                if (message.parametersTypes != null && message.hasOwnProperty("parametersTypes")) {
                    if (!$util.isObject(message.parametersTypes))
                        return "parametersTypes: object expected";
                    var key = Object.keys(message.parametersTypes);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.Type.verify(message.parametersTypes[key[i]]);
                        if (error)
                            return "parametersTypes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PrepareQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PrepareQueryResult} PrepareQueryResult
             */
            PrepareQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PrepareQueryResult)
                    return object;
                var message = new $root.Ydb.Table.PrepareQueryResult();
                if (object.queryId != null)
                    message.queryId = String(object.queryId);
                if (object.parametersTypes) {
                    if (typeof object.parametersTypes !== "object")
                        throw TypeError(".Ydb.Table.PrepareQueryResult.parametersTypes: object expected");
                    message.parametersTypes = {};
                    for (var keys = Object.keys(object.parametersTypes), i = 0; i < keys.length; ++i) {
                        if (typeof object.parametersTypes[keys[i]] !== "object")
                            throw TypeError(".Ydb.Table.PrepareQueryResult.parametersTypes: object expected");
                        message.parametersTypes[keys[i]] = $root.Ydb.Type.fromObject(object.parametersTypes[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PrepareQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Ydb.Table.PrepareQueryResult} message PrepareQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrepareQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parametersTypes = {};
                if (options.defaults)
                    object.queryId = "";
                if (message.queryId != null && message.hasOwnProperty("queryId"))
                    object.queryId = message.queryId;
                var keys2;
                if (message.parametersTypes && (keys2 = Object.keys(message.parametersTypes)).length) {
                    object.parametersTypes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parametersTypes[keys2[j]] = $root.Ydb.Type.toObject(message.parametersTypes[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this PrepareQueryResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PrepareQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrepareQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrepareQueryResult;
        })();

        Table.KeepAliveRequest = (function() {

            /**
             * Properties of a KeepAliveRequest.
             * @memberof Ydb.Table
             * @interface IKeepAliveRequest
             * @property {string|null} [sessionId] KeepAliveRequest sessionId
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] KeepAliveRequest operationParams
             */

            /**
             * Constructs a new KeepAliveRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a KeepAliveRequest.
             * @implements IKeepAliveRequest
             * @constructor
             * @param {Ydb.Table.IKeepAliveRequest=} [properties] Properties to set
             */
            function KeepAliveRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeepAliveRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.KeepAliveRequest
             * @instance
             */
            KeepAliveRequest.prototype.sessionId = "";

            /**
             * KeepAliveRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.KeepAliveRequest
             * @instance
             */
            KeepAliveRequest.prototype.operationParams = null;

            /**
             * Creates a new KeepAliveRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Ydb.Table.IKeepAliveRequest=} [properties] Properties to set
             * @returns {Ydb.Table.KeepAliveRequest} KeepAliveRequest instance
             */
            KeepAliveRequest.create = function create(properties) {
                return new KeepAliveRequest(properties);
            };

            /**
             * Encodes the specified KeepAliveRequest message. Does not implicitly {@link Ydb.Table.KeepAliveRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Ydb.Table.IKeepAliveRequest} message KeepAliveRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeepAliveRequest message, length delimited. Does not implicitly {@link Ydb.Table.KeepAliveRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Ydb.Table.IKeepAliveRequest} message KeepAliveRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeepAliveRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.KeepAliveRequest} KeepAliveRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.KeepAliveRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeepAliveRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.KeepAliveRequest} KeepAliveRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeepAliveRequest message.
             * @function verify
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeepAliveRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a KeepAliveRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.KeepAliveRequest} KeepAliveRequest
             */
            KeepAliveRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.KeepAliveRequest)
                    return object;
                var message = new $root.Ydb.Table.KeepAliveRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.KeepAliveRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a KeepAliveRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Ydb.Table.KeepAliveRequest} message KeepAliveRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeepAliveRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this KeepAliveRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.KeepAliveRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeepAliveRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeepAliveRequest;
        })();

        Table.KeepAliveResponse = (function() {

            /**
             * Properties of a KeepAliveResponse.
             * @memberof Ydb.Table
             * @interface IKeepAliveResponse
             * @property {Ydb.Operations.IOperation|null} [operation] KeepAliveResponse operation
             */

            /**
             * Constructs a new KeepAliveResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a KeepAliveResponse.
             * @implements IKeepAliveResponse
             * @constructor
             * @param {Ydb.Table.IKeepAliveResponse=} [properties] Properties to set
             */
            function KeepAliveResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeepAliveResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.KeepAliveResponse
             * @instance
             */
            KeepAliveResponse.prototype.operation = null;

            /**
             * Creates a new KeepAliveResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Ydb.Table.IKeepAliveResponse=} [properties] Properties to set
             * @returns {Ydb.Table.KeepAliveResponse} KeepAliveResponse instance
             */
            KeepAliveResponse.create = function create(properties) {
                return new KeepAliveResponse(properties);
            };

            /**
             * Encodes the specified KeepAliveResponse message. Does not implicitly {@link Ydb.Table.KeepAliveResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Ydb.Table.IKeepAliveResponse} message KeepAliveResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeepAliveResponse message, length delimited. Does not implicitly {@link Ydb.Table.KeepAliveResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Ydb.Table.IKeepAliveResponse} message KeepAliveResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeepAliveResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.KeepAliveResponse} KeepAliveResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.KeepAliveResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeepAliveResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.KeepAliveResponse} KeepAliveResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeepAliveResponse message.
             * @function verify
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeepAliveResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a KeepAliveResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.KeepAliveResponse} KeepAliveResponse
             */
            KeepAliveResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.KeepAliveResponse)
                    return object;
                var message = new $root.Ydb.Table.KeepAliveResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.KeepAliveResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a KeepAliveResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Ydb.Table.KeepAliveResponse} message KeepAliveResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeepAliveResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this KeepAliveResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.KeepAliveResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeepAliveResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeepAliveResponse;
        })();

        Table.KeepAliveResult = (function() {

            /**
             * Properties of a KeepAliveResult.
             * @memberof Ydb.Table
             * @interface IKeepAliveResult
             * @property {Ydb.Table.KeepAliveResult.SessionStatus|null} [sessionStatus] KeepAliveResult sessionStatus
             */

            /**
             * Constructs a new KeepAliveResult.
             * @memberof Ydb.Table
             * @classdesc Represents a KeepAliveResult.
             * @implements IKeepAliveResult
             * @constructor
             * @param {Ydb.Table.IKeepAliveResult=} [properties] Properties to set
             */
            function KeepAliveResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeepAliveResult sessionStatus.
             * @member {Ydb.Table.KeepAliveResult.SessionStatus} sessionStatus
             * @memberof Ydb.Table.KeepAliveResult
             * @instance
             */
            KeepAliveResult.prototype.sessionStatus = 0;

            /**
             * Creates a new KeepAliveResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Ydb.Table.IKeepAliveResult=} [properties] Properties to set
             * @returns {Ydb.Table.KeepAliveResult} KeepAliveResult instance
             */
            KeepAliveResult.create = function create(properties) {
                return new KeepAliveResult(properties);
            };

            /**
             * Encodes the specified KeepAliveResult message. Does not implicitly {@link Ydb.Table.KeepAliveResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Ydb.Table.IKeepAliveResult} message KeepAliveResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionStatus != null && message.hasOwnProperty("sessionStatus"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sessionStatus);
                return writer;
            };

            /**
             * Encodes the specified KeepAliveResult message, length delimited. Does not implicitly {@link Ydb.Table.KeepAliveResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Ydb.Table.IKeepAliveResult} message KeepAliveResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeepAliveResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.KeepAliveResult} KeepAliveResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.KeepAliveResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionStatus = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeepAliveResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.KeepAliveResult} KeepAliveResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeepAliveResult message.
             * @function verify
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeepAliveResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionStatus != null && message.hasOwnProperty("sessionStatus"))
                    switch (message.sessionStatus) {
                    default:
                        return "sessionStatus: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a KeepAliveResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.KeepAliveResult} KeepAliveResult
             */
            KeepAliveResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.KeepAliveResult)
                    return object;
                var message = new $root.Ydb.Table.KeepAliveResult();
                switch (object.sessionStatus) {
                case "SESSION_STATUS_UNSPECIFIED":
                case 0:
                    message.sessionStatus = 0;
                    break;
                case "SESSION_STATUS_READY":
                case 1:
                    message.sessionStatus = 1;
                    break;
                case "SESSION_STATUS_BUSY":
                case 2:
                    message.sessionStatus = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a KeepAliveResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Ydb.Table.KeepAliveResult} message KeepAliveResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeepAliveResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.sessionStatus = options.enums === String ? "SESSION_STATUS_UNSPECIFIED" : 0;
                if (message.sessionStatus != null && message.hasOwnProperty("sessionStatus"))
                    object.sessionStatus = options.enums === String ? $root.Ydb.Table.KeepAliveResult.SessionStatus[message.sessionStatus] : message.sessionStatus;
                return object;
            };

            /**
             * Converts this KeepAliveResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.KeepAliveResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeepAliveResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * SessionStatus enum.
             * @name Ydb.Table.KeepAliveResult.SessionStatus
             * @enum {string}
             * @property {number} SESSION_STATUS_UNSPECIFIED=0 SESSION_STATUS_UNSPECIFIED value
             * @property {number} SESSION_STATUS_READY=1 SESSION_STATUS_READY value
             * @property {number} SESSION_STATUS_BUSY=2 SESSION_STATUS_BUSY value
             */
            KeepAliveResult.SessionStatus = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SESSION_STATUS_UNSPECIFIED"] = 0;
                values[valuesById[1] = "SESSION_STATUS_READY"] = 1;
                values[valuesById[2] = "SESSION_STATUS_BUSY"] = 2;
                return values;
            })();

            return KeepAliveResult;
        })();

        Table.BeginTransactionRequest = (function() {

            /**
             * Properties of a BeginTransactionRequest.
             * @memberof Ydb.Table
             * @interface IBeginTransactionRequest
             * @property {string|null} [sessionId] BeginTransactionRequest sessionId
             * @property {Ydb.Table.ITransactionSettings|null} [txSettings] BeginTransactionRequest txSettings
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] BeginTransactionRequest operationParams
             */

            /**
             * Constructs a new BeginTransactionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a BeginTransactionRequest.
             * @implements IBeginTransactionRequest
             * @constructor
             * @param {Ydb.Table.IBeginTransactionRequest=} [properties] Properties to set
             */
            function BeginTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BeginTransactionRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.BeginTransactionRequest
             * @instance
             */
            BeginTransactionRequest.prototype.sessionId = "";

            /**
             * BeginTransactionRequest txSettings.
             * @member {Ydb.Table.ITransactionSettings|null|undefined} txSettings
             * @memberof Ydb.Table.BeginTransactionRequest
             * @instance
             */
            BeginTransactionRequest.prototype.txSettings = null;

            /**
             * BeginTransactionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.BeginTransactionRequest
             * @instance
             */
            BeginTransactionRequest.prototype.operationParams = null;

            /**
             * Creates a new BeginTransactionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Ydb.Table.IBeginTransactionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.BeginTransactionRequest} BeginTransactionRequest instance
             */
            BeginTransactionRequest.create = function create(properties) {
                return new BeginTransactionRequest(properties);
            };

            /**
             * Encodes the specified BeginTransactionRequest message. Does not implicitly {@link Ydb.Table.BeginTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Ydb.Table.IBeginTransactionRequest} message BeginTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.txSettings != null && message.hasOwnProperty("txSettings"))
                    $root.Ydb.Table.TransactionSettings.encode(message.txSettings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BeginTransactionRequest message, length delimited. Does not implicitly {@link Ydb.Table.BeginTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Ydb.Table.IBeginTransactionRequest} message BeginTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BeginTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BeginTransactionRequest} BeginTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BeginTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.txSettings = $root.Ydb.Table.TransactionSettings.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BeginTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BeginTransactionRequest} BeginTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BeginTransactionRequest message.
             * @function verify
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BeginTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.txSettings != null && message.hasOwnProperty("txSettings")) {
                    var error = $root.Ydb.Table.TransactionSettings.verify(message.txSettings);
                    if (error)
                        return "txSettings." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a BeginTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BeginTransactionRequest} BeginTransactionRequest
             */
            BeginTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BeginTransactionRequest)
                    return object;
                var message = new $root.Ydb.Table.BeginTransactionRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.txSettings != null) {
                    if (typeof object.txSettings !== "object")
                        throw TypeError(".Ydb.Table.BeginTransactionRequest.txSettings: object expected");
                    message.txSettings = $root.Ydb.Table.TransactionSettings.fromObject(object.txSettings);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.BeginTransactionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a BeginTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Ydb.Table.BeginTransactionRequest} message BeginTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BeginTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.txSettings = null;
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.txSettings != null && message.hasOwnProperty("txSettings"))
                    object.txSettings = $root.Ydb.Table.TransactionSettings.toObject(message.txSettings, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this BeginTransactionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BeginTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BeginTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BeginTransactionRequest;
        })();

        Table.BeginTransactionResponse = (function() {

            /**
             * Properties of a BeginTransactionResponse.
             * @memberof Ydb.Table
             * @interface IBeginTransactionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] BeginTransactionResponse operation
             */

            /**
             * Constructs a new BeginTransactionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a BeginTransactionResponse.
             * @implements IBeginTransactionResponse
             * @constructor
             * @param {Ydb.Table.IBeginTransactionResponse=} [properties] Properties to set
             */
            function BeginTransactionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BeginTransactionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.BeginTransactionResponse
             * @instance
             */
            BeginTransactionResponse.prototype.operation = null;

            /**
             * Creates a new BeginTransactionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Ydb.Table.IBeginTransactionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.BeginTransactionResponse} BeginTransactionResponse instance
             */
            BeginTransactionResponse.create = function create(properties) {
                return new BeginTransactionResponse(properties);
            };

            /**
             * Encodes the specified BeginTransactionResponse message. Does not implicitly {@link Ydb.Table.BeginTransactionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Ydb.Table.IBeginTransactionResponse} message BeginTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BeginTransactionResponse message, length delimited. Does not implicitly {@link Ydb.Table.BeginTransactionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Ydb.Table.IBeginTransactionResponse} message BeginTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BeginTransactionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BeginTransactionResponse} BeginTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BeginTransactionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BeginTransactionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BeginTransactionResponse} BeginTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BeginTransactionResponse message.
             * @function verify
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BeginTransactionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a BeginTransactionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BeginTransactionResponse} BeginTransactionResponse
             */
            BeginTransactionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BeginTransactionResponse)
                    return object;
                var message = new $root.Ydb.Table.BeginTransactionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.BeginTransactionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a BeginTransactionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Ydb.Table.BeginTransactionResponse} message BeginTransactionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BeginTransactionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this BeginTransactionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BeginTransactionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BeginTransactionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BeginTransactionResponse;
        })();

        Table.BeginTransactionResult = (function() {

            /**
             * Properties of a BeginTransactionResult.
             * @memberof Ydb.Table
             * @interface IBeginTransactionResult
             * @property {Ydb.Table.ITransactionMeta|null} [txMeta] BeginTransactionResult txMeta
             */

            /**
             * Constructs a new BeginTransactionResult.
             * @memberof Ydb.Table
             * @classdesc Represents a BeginTransactionResult.
             * @implements IBeginTransactionResult
             * @constructor
             * @param {Ydb.Table.IBeginTransactionResult=} [properties] Properties to set
             */
            function BeginTransactionResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BeginTransactionResult txMeta.
             * @member {Ydb.Table.ITransactionMeta|null|undefined} txMeta
             * @memberof Ydb.Table.BeginTransactionResult
             * @instance
             */
            BeginTransactionResult.prototype.txMeta = null;

            /**
             * Creates a new BeginTransactionResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Ydb.Table.IBeginTransactionResult=} [properties] Properties to set
             * @returns {Ydb.Table.BeginTransactionResult} BeginTransactionResult instance
             */
            BeginTransactionResult.create = function create(properties) {
                return new BeginTransactionResult(properties);
            };

            /**
             * Encodes the specified BeginTransactionResult message. Does not implicitly {@link Ydb.Table.BeginTransactionResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Ydb.Table.IBeginTransactionResult} message BeginTransactionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txMeta != null && message.hasOwnProperty("txMeta"))
                    $root.Ydb.Table.TransactionMeta.encode(message.txMeta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BeginTransactionResult message, length delimited. Does not implicitly {@link Ydb.Table.BeginTransactionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Ydb.Table.IBeginTransactionResult} message BeginTransactionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BeginTransactionResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BeginTransactionResult} BeginTransactionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BeginTransactionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txMeta = $root.Ydb.Table.TransactionMeta.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BeginTransactionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BeginTransactionResult} BeginTransactionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BeginTransactionResult message.
             * @function verify
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BeginTransactionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txMeta != null && message.hasOwnProperty("txMeta")) {
                    var error = $root.Ydb.Table.TransactionMeta.verify(message.txMeta);
                    if (error)
                        return "txMeta." + error;
                }
                return null;
            };

            /**
             * Creates a BeginTransactionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BeginTransactionResult} BeginTransactionResult
             */
            BeginTransactionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BeginTransactionResult)
                    return object;
                var message = new $root.Ydb.Table.BeginTransactionResult();
                if (object.txMeta != null) {
                    if (typeof object.txMeta !== "object")
                        throw TypeError(".Ydb.Table.BeginTransactionResult.txMeta: object expected");
                    message.txMeta = $root.Ydb.Table.TransactionMeta.fromObject(object.txMeta);
                }
                return message;
            };

            /**
             * Creates a plain object from a BeginTransactionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Ydb.Table.BeginTransactionResult} message BeginTransactionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BeginTransactionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.txMeta = null;
                if (message.txMeta != null && message.hasOwnProperty("txMeta"))
                    object.txMeta = $root.Ydb.Table.TransactionMeta.toObject(message.txMeta, options);
                return object;
            };

            /**
             * Converts this BeginTransactionResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BeginTransactionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BeginTransactionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BeginTransactionResult;
        })();

        Table.CommitTransactionRequest = (function() {

            /**
             * Properties of a CommitTransactionRequest.
             * @memberof Ydb.Table
             * @interface ICommitTransactionRequest
             * @property {string|null} [sessionId] CommitTransactionRequest sessionId
             * @property {string|null} [txId] CommitTransactionRequest txId
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CommitTransactionRequest operationParams
             */

            /**
             * Constructs a new CommitTransactionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CommitTransactionRequest.
             * @implements ICommitTransactionRequest
             * @constructor
             * @param {Ydb.Table.ICommitTransactionRequest=} [properties] Properties to set
             */
            function CommitTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommitTransactionRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CommitTransactionRequest
             * @instance
             */
            CommitTransactionRequest.prototype.sessionId = "";

            /**
             * CommitTransactionRequest txId.
             * @member {string} txId
             * @memberof Ydb.Table.CommitTransactionRequest
             * @instance
             */
            CommitTransactionRequest.prototype.txId = "";

            /**
             * CommitTransactionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CommitTransactionRequest
             * @instance
             */
            CommitTransactionRequest.prototype.operationParams = null;

            /**
             * Creates a new CommitTransactionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Ydb.Table.ICommitTransactionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CommitTransactionRequest} CommitTransactionRequest instance
             */
            CommitTransactionRequest.create = function create(properties) {
                return new CommitTransactionRequest(properties);
            };

            /**
             * Encodes the specified CommitTransactionRequest message. Does not implicitly {@link Ydb.Table.CommitTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Ydb.Table.ICommitTransactionRequest} message CommitTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.txId != null && message.hasOwnProperty("txId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.txId);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CommitTransactionRequest message, length delimited. Does not implicitly {@link Ydb.Table.CommitTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Ydb.Table.ICommitTransactionRequest} message CommitTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommitTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CommitTransactionRequest} CommitTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CommitTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.txId = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommitTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CommitTransactionRequest} CommitTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommitTransactionRequest message.
             * @function verify
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a CommitTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CommitTransactionRequest} CommitTransactionRequest
             */
            CommitTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CommitTransactionRequest)
                    return object;
                var message = new $root.Ydb.Table.CommitTransactionRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CommitTransactionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a CommitTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Ydb.Table.CommitTransactionRequest} message CommitTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.txId = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this CommitTransactionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CommitTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CommitTransactionRequest;
        })();

        Table.CommitTransactionResponse = (function() {

            /**
             * Properties of a CommitTransactionResponse.
             * @memberof Ydb.Table
             * @interface ICommitTransactionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CommitTransactionResponse operation
             */

            /**
             * Constructs a new CommitTransactionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CommitTransactionResponse.
             * @implements ICommitTransactionResponse
             * @constructor
             * @param {Ydb.Table.ICommitTransactionResponse=} [properties] Properties to set
             */
            function CommitTransactionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommitTransactionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CommitTransactionResponse
             * @instance
             */
            CommitTransactionResponse.prototype.operation = null;

            /**
             * Creates a new CommitTransactionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Ydb.Table.ICommitTransactionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CommitTransactionResponse} CommitTransactionResponse instance
             */
            CommitTransactionResponse.create = function create(properties) {
                return new CommitTransactionResponse(properties);
            };

            /**
             * Encodes the specified CommitTransactionResponse message. Does not implicitly {@link Ydb.Table.CommitTransactionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Ydb.Table.ICommitTransactionResponse} message CommitTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CommitTransactionResponse message, length delimited. Does not implicitly {@link Ydb.Table.CommitTransactionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Ydb.Table.ICommitTransactionResponse} message CommitTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommitTransactionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CommitTransactionResponse} CommitTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CommitTransactionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommitTransactionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CommitTransactionResponse} CommitTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommitTransactionResponse message.
             * @function verify
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitTransactionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CommitTransactionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CommitTransactionResponse} CommitTransactionResponse
             */
            CommitTransactionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CommitTransactionResponse)
                    return object;
                var message = new $root.Ydb.Table.CommitTransactionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CommitTransactionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CommitTransactionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Ydb.Table.CommitTransactionResponse} message CommitTransactionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitTransactionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CommitTransactionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CommitTransactionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitTransactionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CommitTransactionResponse;
        })();

        Table.RollbackTransactionRequest = (function() {

            /**
             * Properties of a RollbackTransactionRequest.
             * @memberof Ydb.Table
             * @interface IRollbackTransactionRequest
             * @property {string|null} [sessionId] RollbackTransactionRequest sessionId
             * @property {string|null} [txId] RollbackTransactionRequest txId
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] RollbackTransactionRequest operationParams
             */

            /**
             * Constructs a new RollbackTransactionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a RollbackTransactionRequest.
             * @implements IRollbackTransactionRequest
             * @constructor
             * @param {Ydb.Table.IRollbackTransactionRequest=} [properties] Properties to set
             */
            function RollbackTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RollbackTransactionRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @instance
             */
            RollbackTransactionRequest.prototype.sessionId = "";

            /**
             * RollbackTransactionRequest txId.
             * @member {string} txId
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @instance
             */
            RollbackTransactionRequest.prototype.txId = "";

            /**
             * RollbackTransactionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @instance
             */
            RollbackTransactionRequest.prototype.operationParams = null;

            /**
             * Creates a new RollbackTransactionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Ydb.Table.IRollbackTransactionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.RollbackTransactionRequest} RollbackTransactionRequest instance
             */
            RollbackTransactionRequest.create = function create(properties) {
                return new RollbackTransactionRequest(properties);
            };

            /**
             * Encodes the specified RollbackTransactionRequest message. Does not implicitly {@link Ydb.Table.RollbackTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Ydb.Table.IRollbackTransactionRequest} message RollbackTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RollbackTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.txId != null && message.hasOwnProperty("txId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.txId);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RollbackTransactionRequest message, length delimited. Does not implicitly {@link Ydb.Table.RollbackTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Ydb.Table.IRollbackTransactionRequest} message RollbackTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RollbackTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RollbackTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.RollbackTransactionRequest} RollbackTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RollbackTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.RollbackTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.txId = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RollbackTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.RollbackTransactionRequest} RollbackTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RollbackTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RollbackTransactionRequest message.
             * @function verify
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RollbackTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a RollbackTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.RollbackTransactionRequest} RollbackTransactionRequest
             */
            RollbackTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.RollbackTransactionRequest)
                    return object;
                var message = new $root.Ydb.Table.RollbackTransactionRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.RollbackTransactionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a RollbackTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Ydb.Table.RollbackTransactionRequest} message RollbackTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RollbackTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.txId = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this RollbackTransactionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RollbackTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RollbackTransactionRequest;
        })();

        Table.RollbackTransactionResponse = (function() {

            /**
             * Properties of a RollbackTransactionResponse.
             * @memberof Ydb.Table
             * @interface IRollbackTransactionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] RollbackTransactionResponse operation
             */

            /**
             * Constructs a new RollbackTransactionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a RollbackTransactionResponse.
             * @implements IRollbackTransactionResponse
             * @constructor
             * @param {Ydb.Table.IRollbackTransactionResponse=} [properties] Properties to set
             */
            function RollbackTransactionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RollbackTransactionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @instance
             */
            RollbackTransactionResponse.prototype.operation = null;

            /**
             * Creates a new RollbackTransactionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Ydb.Table.IRollbackTransactionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.RollbackTransactionResponse} RollbackTransactionResponse instance
             */
            RollbackTransactionResponse.create = function create(properties) {
                return new RollbackTransactionResponse(properties);
            };

            /**
             * Encodes the specified RollbackTransactionResponse message. Does not implicitly {@link Ydb.Table.RollbackTransactionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Ydb.Table.IRollbackTransactionResponse} message RollbackTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RollbackTransactionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RollbackTransactionResponse message, length delimited. Does not implicitly {@link Ydb.Table.RollbackTransactionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Ydb.Table.IRollbackTransactionResponse} message RollbackTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RollbackTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RollbackTransactionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.RollbackTransactionResponse} RollbackTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RollbackTransactionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.RollbackTransactionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RollbackTransactionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.RollbackTransactionResponse} RollbackTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RollbackTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RollbackTransactionResponse message.
             * @function verify
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RollbackTransactionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a RollbackTransactionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.RollbackTransactionResponse} RollbackTransactionResponse
             */
            RollbackTransactionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.RollbackTransactionResponse)
                    return object;
                var message = new $root.Ydb.Table.RollbackTransactionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.RollbackTransactionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a RollbackTransactionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Ydb.Table.RollbackTransactionResponse} message RollbackTransactionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RollbackTransactionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this RollbackTransactionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RollbackTransactionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RollbackTransactionResponse;
        })();

        Table.StoragePolicyDescription = (function() {

            /**
             * Properties of a StoragePolicyDescription.
             * @memberof Ydb.Table
             * @interface IStoragePolicyDescription
             * @property {string|null} [name] StoragePolicyDescription name
             * @property {Object.<string,string>|null} [labels] StoragePolicyDescription labels
             */

            /**
             * Constructs a new StoragePolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a StoragePolicyDescription.
             * @implements IStoragePolicyDescription
             * @constructor
             * @param {Ydb.Table.IStoragePolicyDescription=} [properties] Properties to set
             */
            function StoragePolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoragePolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.StoragePolicyDescription
             * @instance
             */
            StoragePolicyDescription.prototype.name = "";

            /**
             * StoragePolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.StoragePolicyDescription
             * @instance
             */
            StoragePolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new StoragePolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Ydb.Table.IStoragePolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.StoragePolicyDescription} StoragePolicyDescription instance
             */
            StoragePolicyDescription.create = function create(properties) {
                return new StoragePolicyDescription(properties);
            };

            /**
             * Encodes the specified StoragePolicyDescription message. Does not implicitly {@link Ydb.Table.StoragePolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Ydb.Table.IStoragePolicyDescription} message StoragePolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StoragePolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.StoragePolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Ydb.Table.IStoragePolicyDescription} message StoragePolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoragePolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.StoragePolicyDescription} StoragePolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.StoragePolicyDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoragePolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.StoragePolicyDescription} StoragePolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoragePolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoragePolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a StoragePolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.StoragePolicyDescription} StoragePolicyDescription
             */
            StoragePolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.StoragePolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.StoragePolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a StoragePolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Ydb.Table.StoragePolicyDescription} message StoragePolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoragePolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this StoragePolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.StoragePolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoragePolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoragePolicyDescription;
        })();

        Table.CompactionPolicyDescription = (function() {

            /**
             * Properties of a CompactionPolicyDescription.
             * @memberof Ydb.Table
             * @interface ICompactionPolicyDescription
             * @property {string|null} [name] CompactionPolicyDescription name
             * @property {Object.<string,string>|null} [labels] CompactionPolicyDescription labels
             */

            /**
             * Constructs a new CompactionPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a CompactionPolicyDescription.
             * @implements ICompactionPolicyDescription
             * @constructor
             * @param {Ydb.Table.ICompactionPolicyDescription=} [properties] Properties to set
             */
            function CompactionPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompactionPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @instance
             */
            CompactionPolicyDescription.prototype.name = "";

            /**
             * CompactionPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @instance
             */
            CompactionPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new CompactionPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Ydb.Table.ICompactionPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.CompactionPolicyDescription} CompactionPolicyDescription instance
             */
            CompactionPolicyDescription.create = function create(properties) {
                return new CompactionPolicyDescription(properties);
            };

            /**
             * Encodes the specified CompactionPolicyDescription message. Does not implicitly {@link Ydb.Table.CompactionPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Ydb.Table.ICompactionPolicyDescription} message CompactionPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactionPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CompactionPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.CompactionPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Ydb.Table.ICompactionPolicyDescription} message CompactionPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactionPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompactionPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CompactionPolicyDescription} CompactionPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactionPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CompactionPolicyDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CompactionPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CompactionPolicyDescription} CompactionPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactionPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompactionPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompactionPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a CompactionPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CompactionPolicyDescription} CompactionPolicyDescription
             */
            CompactionPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CompactionPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.CompactionPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.CompactionPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a CompactionPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Ydb.Table.CompactionPolicyDescription} message CompactionPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CompactionPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this CompactionPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CompactionPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CompactionPolicyDescription;
        })();

        Table.PartitioningPolicyDescription = (function() {

            /**
             * Properties of a PartitioningPolicyDescription.
             * @memberof Ydb.Table
             * @interface IPartitioningPolicyDescription
             * @property {string|null} [name] PartitioningPolicyDescription name
             * @property {Object.<string,string>|null} [labels] PartitioningPolicyDescription labels
             */

            /**
             * Constructs a new PartitioningPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a PartitioningPolicyDescription.
             * @implements IPartitioningPolicyDescription
             * @constructor
             * @param {Ydb.Table.IPartitioningPolicyDescription=} [properties] Properties to set
             */
            function PartitioningPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PartitioningPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @instance
             */
            PartitioningPolicyDescription.prototype.name = "";

            /**
             * PartitioningPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @instance
             */
            PartitioningPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new PartitioningPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Ydb.Table.IPartitioningPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.PartitioningPolicyDescription} PartitioningPolicyDescription instance
             */
            PartitioningPolicyDescription.create = function create(properties) {
                return new PartitioningPolicyDescription(properties);
            };

            /**
             * Encodes the specified PartitioningPolicyDescription message. Does not implicitly {@link Ydb.Table.PartitioningPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Ydb.Table.IPartitioningPolicyDescription} message PartitioningPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PartitioningPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.PartitioningPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Ydb.Table.IPartitioningPolicyDescription} message PartitioningPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PartitioningPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PartitioningPolicyDescription} PartitioningPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PartitioningPolicyDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PartitioningPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PartitioningPolicyDescription} PartitioningPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PartitioningPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PartitioningPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a PartitioningPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PartitioningPolicyDescription} PartitioningPolicyDescription
             */
            PartitioningPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PartitioningPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.PartitioningPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.PartitioningPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a PartitioningPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Ydb.Table.PartitioningPolicyDescription} message PartitioningPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PartitioningPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this PartitioningPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PartitioningPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PartitioningPolicyDescription;
        })();

        Table.ExecutionPolicyDescription = (function() {

            /**
             * Properties of an ExecutionPolicyDescription.
             * @memberof Ydb.Table
             * @interface IExecutionPolicyDescription
             * @property {string|null} [name] ExecutionPolicyDescription name
             * @property {Object.<string,string>|null} [labels] ExecutionPolicyDescription labels
             */

            /**
             * Constructs a new ExecutionPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecutionPolicyDescription.
             * @implements IExecutionPolicyDescription
             * @constructor
             * @param {Ydb.Table.IExecutionPolicyDescription=} [properties] Properties to set
             */
            function ExecutionPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @instance
             */
            ExecutionPolicyDescription.prototype.name = "";

            /**
             * ExecutionPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @instance
             */
            ExecutionPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new ExecutionPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Ydb.Table.IExecutionPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.ExecutionPolicyDescription} ExecutionPolicyDescription instance
             */
            ExecutionPolicyDescription.create = function create(properties) {
                return new ExecutionPolicyDescription(properties);
            };

            /**
             * Encodes the specified ExecutionPolicyDescription message. Does not implicitly {@link Ydb.Table.ExecutionPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Ydb.Table.IExecutionPolicyDescription} message ExecutionPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecutionPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.ExecutionPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Ydb.Table.IExecutionPolicyDescription} message ExecutionPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecutionPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecutionPolicyDescription} ExecutionPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecutionPolicyDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecutionPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecutionPolicyDescription} ExecutionPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecutionPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an ExecutionPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecutionPolicyDescription} ExecutionPolicyDescription
             */
            ExecutionPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecutionPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.ExecutionPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.ExecutionPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecutionPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Ydb.Table.ExecutionPolicyDescription} message ExecutionPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecutionPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this ExecutionPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecutionPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecutionPolicyDescription;
        })();

        Table.ReplicationPolicyDescription = (function() {

            /**
             * Properties of a ReplicationPolicyDescription.
             * @memberof Ydb.Table
             * @interface IReplicationPolicyDescription
             * @property {string|null} [name] ReplicationPolicyDescription name
             * @property {Object.<string,string>|null} [labels] ReplicationPolicyDescription labels
             */

            /**
             * Constructs a new ReplicationPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a ReplicationPolicyDescription.
             * @implements IReplicationPolicyDescription
             * @constructor
             * @param {Ydb.Table.IReplicationPolicyDescription=} [properties] Properties to set
             */
            function ReplicationPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplicationPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @instance
             */
            ReplicationPolicyDescription.prototype.name = "";

            /**
             * ReplicationPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @instance
             */
            ReplicationPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new ReplicationPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Ydb.Table.IReplicationPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.ReplicationPolicyDescription} ReplicationPolicyDescription instance
             */
            ReplicationPolicyDescription.create = function create(properties) {
                return new ReplicationPolicyDescription(properties);
            };

            /**
             * Encodes the specified ReplicationPolicyDescription message. Does not implicitly {@link Ydb.Table.ReplicationPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Ydb.Table.IReplicationPolicyDescription} message ReplicationPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReplicationPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.ReplicationPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Ydb.Table.IReplicationPolicyDescription} message ReplicationPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplicationPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReplicationPolicyDescription} ReplicationPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReplicationPolicyDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplicationPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReplicationPolicyDescription} ReplicationPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplicationPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplicationPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a ReplicationPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReplicationPolicyDescription} ReplicationPolicyDescription
             */
            ReplicationPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReplicationPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.ReplicationPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.ReplicationPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReplicationPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Ydb.Table.ReplicationPolicyDescription} message ReplicationPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicationPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this ReplicationPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplicationPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplicationPolicyDescription;
        })();

        Table.CachingPolicyDescription = (function() {

            /**
             * Properties of a CachingPolicyDescription.
             * @memberof Ydb.Table
             * @interface ICachingPolicyDescription
             * @property {string|null} [name] CachingPolicyDescription name
             * @property {Object.<string,string>|null} [labels] CachingPolicyDescription labels
             */

            /**
             * Constructs a new CachingPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a CachingPolicyDescription.
             * @implements ICachingPolicyDescription
             * @constructor
             * @param {Ydb.Table.ICachingPolicyDescription=} [properties] Properties to set
             */
            function CachingPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CachingPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.CachingPolicyDescription
             * @instance
             */
            CachingPolicyDescription.prototype.name = "";

            /**
             * CachingPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.CachingPolicyDescription
             * @instance
             */
            CachingPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new CachingPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Ydb.Table.ICachingPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.CachingPolicyDescription} CachingPolicyDescription instance
             */
            CachingPolicyDescription.create = function create(properties) {
                return new CachingPolicyDescription(properties);
            };

            /**
             * Encodes the specified CachingPolicyDescription message. Does not implicitly {@link Ydb.Table.CachingPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Ydb.Table.ICachingPolicyDescription} message CachingPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CachingPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CachingPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.CachingPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Ydb.Table.ICachingPolicyDescription} message CachingPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CachingPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CachingPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CachingPolicyDescription} CachingPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CachingPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CachingPolicyDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CachingPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CachingPolicyDescription} CachingPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CachingPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CachingPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CachingPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a CachingPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CachingPolicyDescription} CachingPolicyDescription
             */
            CachingPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CachingPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.CachingPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.CachingPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a CachingPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Ydb.Table.CachingPolicyDescription} message CachingPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CachingPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this CachingPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CachingPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CachingPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CachingPolicyDescription;
        })();

        Table.TableProfileDescription = (function() {

            /**
             * Properties of a TableProfileDescription.
             * @memberof Ydb.Table
             * @interface ITableProfileDescription
             * @property {string|null} [name] TableProfileDescription name
             * @property {Object.<string,string>|null} [labels] TableProfileDescription labels
             * @property {string|null} [defaultStoragePolicy] TableProfileDescription defaultStoragePolicy
             * @property {Array.<string>|null} [allowedStoragePolicies] TableProfileDescription allowedStoragePolicies
             * @property {string|null} [defaultCompactionPolicy] TableProfileDescription defaultCompactionPolicy
             * @property {Array.<string>|null} [allowedCompactionPolicies] TableProfileDescription allowedCompactionPolicies
             * @property {string|null} [defaultPartitioningPolicy] TableProfileDescription defaultPartitioningPolicy
             * @property {Array.<string>|null} [allowedPartitioningPolicies] TableProfileDescription allowedPartitioningPolicies
             * @property {string|null} [defaultExecutionPolicy] TableProfileDescription defaultExecutionPolicy
             * @property {Array.<string>|null} [allowedExecutionPolicies] TableProfileDescription allowedExecutionPolicies
             * @property {string|null} [defaultReplicationPolicy] TableProfileDescription defaultReplicationPolicy
             * @property {Array.<string>|null} [allowedReplicationPolicies] TableProfileDescription allowedReplicationPolicies
             * @property {string|null} [defaultCachingPolicy] TableProfileDescription defaultCachingPolicy
             * @property {Array.<string>|null} [allowedCachingPolicies] TableProfileDescription allowedCachingPolicies
             */

            /**
             * Constructs a new TableProfileDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a TableProfileDescription.
             * @implements ITableProfileDescription
             * @constructor
             * @param {Ydb.Table.ITableProfileDescription=} [properties] Properties to set
             */
            function TableProfileDescription(properties) {
                this.labels = {};
                this.allowedStoragePolicies = [];
                this.allowedCompactionPolicies = [];
                this.allowedPartitioningPolicies = [];
                this.allowedExecutionPolicies = [];
                this.allowedReplicationPolicies = [];
                this.allowedCachingPolicies = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableProfileDescription name.
             * @member {string} name
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.name = "";

            /**
             * TableProfileDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.labels = $util.emptyObject;

            /**
             * TableProfileDescription defaultStoragePolicy.
             * @member {string} defaultStoragePolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultStoragePolicy = "";

            /**
             * TableProfileDescription allowedStoragePolicies.
             * @member {Array.<string>} allowedStoragePolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedStoragePolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultCompactionPolicy.
             * @member {string} defaultCompactionPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultCompactionPolicy = "";

            /**
             * TableProfileDescription allowedCompactionPolicies.
             * @member {Array.<string>} allowedCompactionPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedCompactionPolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultPartitioningPolicy.
             * @member {string} defaultPartitioningPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultPartitioningPolicy = "";

            /**
             * TableProfileDescription allowedPartitioningPolicies.
             * @member {Array.<string>} allowedPartitioningPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedPartitioningPolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultExecutionPolicy.
             * @member {string} defaultExecutionPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultExecutionPolicy = "";

            /**
             * TableProfileDescription allowedExecutionPolicies.
             * @member {Array.<string>} allowedExecutionPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedExecutionPolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultReplicationPolicy.
             * @member {string} defaultReplicationPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultReplicationPolicy = "";

            /**
             * TableProfileDescription allowedReplicationPolicies.
             * @member {Array.<string>} allowedReplicationPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedReplicationPolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultCachingPolicy.
             * @member {string} defaultCachingPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultCachingPolicy = "";

            /**
             * TableProfileDescription allowedCachingPolicies.
             * @member {Array.<string>} allowedCachingPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedCachingPolicies = $util.emptyArray;

            /**
             * Creates a new TableProfileDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Ydb.Table.ITableProfileDescription=} [properties] Properties to set
             * @returns {Ydb.Table.TableProfileDescription} TableProfileDescription instance
             */
            TableProfileDescription.create = function create(properties) {
                return new TableProfileDescription(properties);
            };

            /**
             * Encodes the specified TableProfileDescription message. Does not implicitly {@link Ydb.Table.TableProfileDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Ydb.Table.ITableProfileDescription} message TableProfileDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableProfileDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                if (message.defaultStoragePolicy != null && message.hasOwnProperty("defaultStoragePolicy"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.defaultStoragePolicy);
                if (message.allowedStoragePolicies != null && message.allowedStoragePolicies.length)
                    for (var i = 0; i < message.allowedStoragePolicies.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.allowedStoragePolicies[i]);
                if (message.defaultCompactionPolicy != null && message.hasOwnProperty("defaultCompactionPolicy"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.defaultCompactionPolicy);
                if (message.allowedCompactionPolicies != null && message.allowedCompactionPolicies.length)
                    for (var i = 0; i < message.allowedCompactionPolicies.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.allowedCompactionPolicies[i]);
                if (message.defaultPartitioningPolicy != null && message.hasOwnProperty("defaultPartitioningPolicy"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultPartitioningPolicy);
                if (message.allowedPartitioningPolicies != null && message.allowedPartitioningPolicies.length)
                    for (var i = 0; i < message.allowedPartitioningPolicies.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.allowedPartitioningPolicies[i]);
                if (message.defaultExecutionPolicy != null && message.hasOwnProperty("defaultExecutionPolicy"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.defaultExecutionPolicy);
                if (message.allowedExecutionPolicies != null && message.allowedExecutionPolicies.length)
                    for (var i = 0; i < message.allowedExecutionPolicies.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.allowedExecutionPolicies[i]);
                if (message.defaultReplicationPolicy != null && message.hasOwnProperty("defaultReplicationPolicy"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.defaultReplicationPolicy);
                if (message.allowedReplicationPolicies != null && message.allowedReplicationPolicies.length)
                    for (var i = 0; i < message.allowedReplicationPolicies.length; ++i)
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.allowedReplicationPolicies[i]);
                if (message.defaultCachingPolicy != null && message.hasOwnProperty("defaultCachingPolicy"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.defaultCachingPolicy);
                if (message.allowedCachingPolicies != null && message.allowedCachingPolicies.length)
                    for (var i = 0; i < message.allowedCachingPolicies.length; ++i)
                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.allowedCachingPolicies[i]);
                return writer;
            };

            /**
             * Encodes the specified TableProfileDescription message, length delimited. Does not implicitly {@link Ydb.Table.TableProfileDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Ydb.Table.ITableProfileDescription} message TableProfileDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableProfileDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableProfileDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TableProfileDescription} TableProfileDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableProfileDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TableProfileDescription(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        key = reader.string();
                        reader.pos++;
                        message.labels[key] = reader.string();
                        break;
                    case 3:
                        message.defaultStoragePolicy = reader.string();
                        break;
                    case 4:
                        if (!(message.allowedStoragePolicies && message.allowedStoragePolicies.length))
                            message.allowedStoragePolicies = [];
                        message.allowedStoragePolicies.push(reader.string());
                        break;
                    case 5:
                        message.defaultCompactionPolicy = reader.string();
                        break;
                    case 6:
                        if (!(message.allowedCompactionPolicies && message.allowedCompactionPolicies.length))
                            message.allowedCompactionPolicies = [];
                        message.allowedCompactionPolicies.push(reader.string());
                        break;
                    case 7:
                        message.defaultPartitioningPolicy = reader.string();
                        break;
                    case 8:
                        if (!(message.allowedPartitioningPolicies && message.allowedPartitioningPolicies.length))
                            message.allowedPartitioningPolicies = [];
                        message.allowedPartitioningPolicies.push(reader.string());
                        break;
                    case 9:
                        message.defaultExecutionPolicy = reader.string();
                        break;
                    case 10:
                        if (!(message.allowedExecutionPolicies && message.allowedExecutionPolicies.length))
                            message.allowedExecutionPolicies = [];
                        message.allowedExecutionPolicies.push(reader.string());
                        break;
                    case 11:
                        message.defaultReplicationPolicy = reader.string();
                        break;
                    case 12:
                        if (!(message.allowedReplicationPolicies && message.allowedReplicationPolicies.length))
                            message.allowedReplicationPolicies = [];
                        message.allowedReplicationPolicies.push(reader.string());
                        break;
                    case 13:
                        message.defaultCachingPolicy = reader.string();
                        break;
                    case 14:
                        if (!(message.allowedCachingPolicies && message.allowedCachingPolicies.length))
                            message.allowedCachingPolicies = [];
                        message.allowedCachingPolicies.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableProfileDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TableProfileDescription} TableProfileDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableProfileDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableProfileDescription message.
             * @function verify
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableProfileDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                if (message.defaultStoragePolicy != null && message.hasOwnProperty("defaultStoragePolicy"))
                    if (!$util.isString(message.defaultStoragePolicy))
                        return "defaultStoragePolicy: string expected";
                if (message.allowedStoragePolicies != null && message.hasOwnProperty("allowedStoragePolicies")) {
                    if (!Array.isArray(message.allowedStoragePolicies))
                        return "allowedStoragePolicies: array expected";
                    for (var i = 0; i < message.allowedStoragePolicies.length; ++i)
                        if (!$util.isString(message.allowedStoragePolicies[i]))
                            return "allowedStoragePolicies: string[] expected";
                }
                if (message.defaultCompactionPolicy != null && message.hasOwnProperty("defaultCompactionPolicy"))
                    if (!$util.isString(message.defaultCompactionPolicy))
                        return "defaultCompactionPolicy: string expected";
                if (message.allowedCompactionPolicies != null && message.hasOwnProperty("allowedCompactionPolicies")) {
                    if (!Array.isArray(message.allowedCompactionPolicies))
                        return "allowedCompactionPolicies: array expected";
                    for (var i = 0; i < message.allowedCompactionPolicies.length; ++i)
                        if (!$util.isString(message.allowedCompactionPolicies[i]))
                            return "allowedCompactionPolicies: string[] expected";
                }
                if (message.defaultPartitioningPolicy != null && message.hasOwnProperty("defaultPartitioningPolicy"))
                    if (!$util.isString(message.defaultPartitioningPolicy))
                        return "defaultPartitioningPolicy: string expected";
                if (message.allowedPartitioningPolicies != null && message.hasOwnProperty("allowedPartitioningPolicies")) {
                    if (!Array.isArray(message.allowedPartitioningPolicies))
                        return "allowedPartitioningPolicies: array expected";
                    for (var i = 0; i < message.allowedPartitioningPolicies.length; ++i)
                        if (!$util.isString(message.allowedPartitioningPolicies[i]))
                            return "allowedPartitioningPolicies: string[] expected";
                }
                if (message.defaultExecutionPolicy != null && message.hasOwnProperty("defaultExecutionPolicy"))
                    if (!$util.isString(message.defaultExecutionPolicy))
                        return "defaultExecutionPolicy: string expected";
                if (message.allowedExecutionPolicies != null && message.hasOwnProperty("allowedExecutionPolicies")) {
                    if (!Array.isArray(message.allowedExecutionPolicies))
                        return "allowedExecutionPolicies: array expected";
                    for (var i = 0; i < message.allowedExecutionPolicies.length; ++i)
                        if (!$util.isString(message.allowedExecutionPolicies[i]))
                            return "allowedExecutionPolicies: string[] expected";
                }
                if (message.defaultReplicationPolicy != null && message.hasOwnProperty("defaultReplicationPolicy"))
                    if (!$util.isString(message.defaultReplicationPolicy))
                        return "defaultReplicationPolicy: string expected";
                if (message.allowedReplicationPolicies != null && message.hasOwnProperty("allowedReplicationPolicies")) {
                    if (!Array.isArray(message.allowedReplicationPolicies))
                        return "allowedReplicationPolicies: array expected";
                    for (var i = 0; i < message.allowedReplicationPolicies.length; ++i)
                        if (!$util.isString(message.allowedReplicationPolicies[i]))
                            return "allowedReplicationPolicies: string[] expected";
                }
                if (message.defaultCachingPolicy != null && message.hasOwnProperty("defaultCachingPolicy"))
                    if (!$util.isString(message.defaultCachingPolicy))
                        return "defaultCachingPolicy: string expected";
                if (message.allowedCachingPolicies != null && message.hasOwnProperty("allowedCachingPolicies")) {
                    if (!Array.isArray(message.allowedCachingPolicies))
                        return "allowedCachingPolicies: array expected";
                    for (var i = 0; i < message.allowedCachingPolicies.length; ++i)
                        if (!$util.isString(message.allowedCachingPolicies[i]))
                            return "allowedCachingPolicies: string[] expected";
                }
                return null;
            };

            /**
             * Creates a TableProfileDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TableProfileDescription} TableProfileDescription
             */
            TableProfileDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TableProfileDescription)
                    return object;
                var message = new $root.Ydb.Table.TableProfileDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.TableProfileDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                if (object.defaultStoragePolicy != null)
                    message.defaultStoragePolicy = String(object.defaultStoragePolicy);
                if (object.allowedStoragePolicies) {
                    if (!Array.isArray(object.allowedStoragePolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedStoragePolicies: array expected");
                    message.allowedStoragePolicies = [];
                    for (var i = 0; i < object.allowedStoragePolicies.length; ++i)
                        message.allowedStoragePolicies[i] = String(object.allowedStoragePolicies[i]);
                }
                if (object.defaultCompactionPolicy != null)
                    message.defaultCompactionPolicy = String(object.defaultCompactionPolicy);
                if (object.allowedCompactionPolicies) {
                    if (!Array.isArray(object.allowedCompactionPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedCompactionPolicies: array expected");
                    message.allowedCompactionPolicies = [];
                    for (var i = 0; i < object.allowedCompactionPolicies.length; ++i)
                        message.allowedCompactionPolicies[i] = String(object.allowedCompactionPolicies[i]);
                }
                if (object.defaultPartitioningPolicy != null)
                    message.defaultPartitioningPolicy = String(object.defaultPartitioningPolicy);
                if (object.allowedPartitioningPolicies) {
                    if (!Array.isArray(object.allowedPartitioningPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedPartitioningPolicies: array expected");
                    message.allowedPartitioningPolicies = [];
                    for (var i = 0; i < object.allowedPartitioningPolicies.length; ++i)
                        message.allowedPartitioningPolicies[i] = String(object.allowedPartitioningPolicies[i]);
                }
                if (object.defaultExecutionPolicy != null)
                    message.defaultExecutionPolicy = String(object.defaultExecutionPolicy);
                if (object.allowedExecutionPolicies) {
                    if (!Array.isArray(object.allowedExecutionPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedExecutionPolicies: array expected");
                    message.allowedExecutionPolicies = [];
                    for (var i = 0; i < object.allowedExecutionPolicies.length; ++i)
                        message.allowedExecutionPolicies[i] = String(object.allowedExecutionPolicies[i]);
                }
                if (object.defaultReplicationPolicy != null)
                    message.defaultReplicationPolicy = String(object.defaultReplicationPolicy);
                if (object.allowedReplicationPolicies) {
                    if (!Array.isArray(object.allowedReplicationPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedReplicationPolicies: array expected");
                    message.allowedReplicationPolicies = [];
                    for (var i = 0; i < object.allowedReplicationPolicies.length; ++i)
                        message.allowedReplicationPolicies[i] = String(object.allowedReplicationPolicies[i]);
                }
                if (object.defaultCachingPolicy != null)
                    message.defaultCachingPolicy = String(object.defaultCachingPolicy);
                if (object.allowedCachingPolicies) {
                    if (!Array.isArray(object.allowedCachingPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedCachingPolicies: array expected");
                    message.allowedCachingPolicies = [];
                    for (var i = 0; i < object.allowedCachingPolicies.length; ++i)
                        message.allowedCachingPolicies[i] = String(object.allowedCachingPolicies[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableProfileDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Ydb.Table.TableProfileDescription} message TableProfileDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableProfileDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.allowedStoragePolicies = [];
                    object.allowedCompactionPolicies = [];
                    object.allowedPartitioningPolicies = [];
                    object.allowedExecutionPolicies = [];
                    object.allowedReplicationPolicies = [];
                    object.allowedCachingPolicies = [];
                }
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults) {
                    object.name = "";
                    object.defaultStoragePolicy = "";
                    object.defaultCompactionPolicy = "";
                    object.defaultPartitioningPolicy = "";
                    object.defaultExecutionPolicy = "";
                    object.defaultReplicationPolicy = "";
                    object.defaultCachingPolicy = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                if (message.defaultStoragePolicy != null && message.hasOwnProperty("defaultStoragePolicy"))
                    object.defaultStoragePolicy = message.defaultStoragePolicy;
                if (message.allowedStoragePolicies && message.allowedStoragePolicies.length) {
                    object.allowedStoragePolicies = [];
                    for (var j = 0; j < message.allowedStoragePolicies.length; ++j)
                        object.allowedStoragePolicies[j] = message.allowedStoragePolicies[j];
                }
                if (message.defaultCompactionPolicy != null && message.hasOwnProperty("defaultCompactionPolicy"))
                    object.defaultCompactionPolicy = message.defaultCompactionPolicy;
                if (message.allowedCompactionPolicies && message.allowedCompactionPolicies.length) {
                    object.allowedCompactionPolicies = [];
                    for (var j = 0; j < message.allowedCompactionPolicies.length; ++j)
                        object.allowedCompactionPolicies[j] = message.allowedCompactionPolicies[j];
                }
                if (message.defaultPartitioningPolicy != null && message.hasOwnProperty("defaultPartitioningPolicy"))
                    object.defaultPartitioningPolicy = message.defaultPartitioningPolicy;
                if (message.allowedPartitioningPolicies && message.allowedPartitioningPolicies.length) {
                    object.allowedPartitioningPolicies = [];
                    for (var j = 0; j < message.allowedPartitioningPolicies.length; ++j)
                        object.allowedPartitioningPolicies[j] = message.allowedPartitioningPolicies[j];
                }
                if (message.defaultExecutionPolicy != null && message.hasOwnProperty("defaultExecutionPolicy"))
                    object.defaultExecutionPolicy = message.defaultExecutionPolicy;
                if (message.allowedExecutionPolicies && message.allowedExecutionPolicies.length) {
                    object.allowedExecutionPolicies = [];
                    for (var j = 0; j < message.allowedExecutionPolicies.length; ++j)
                        object.allowedExecutionPolicies[j] = message.allowedExecutionPolicies[j];
                }
                if (message.defaultReplicationPolicy != null && message.hasOwnProperty("defaultReplicationPolicy"))
                    object.defaultReplicationPolicy = message.defaultReplicationPolicy;
                if (message.allowedReplicationPolicies && message.allowedReplicationPolicies.length) {
                    object.allowedReplicationPolicies = [];
                    for (var j = 0; j < message.allowedReplicationPolicies.length; ++j)
                        object.allowedReplicationPolicies[j] = message.allowedReplicationPolicies[j];
                }
                if (message.defaultCachingPolicy != null && message.hasOwnProperty("defaultCachingPolicy"))
                    object.defaultCachingPolicy = message.defaultCachingPolicy;
                if (message.allowedCachingPolicies && message.allowedCachingPolicies.length) {
                    object.allowedCachingPolicies = [];
                    for (var j = 0; j < message.allowedCachingPolicies.length; ++j)
                        object.allowedCachingPolicies[j] = message.allowedCachingPolicies[j];
                }
                return object;
            };

            /**
             * Converts this TableProfileDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableProfileDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableProfileDescription;
        })();

        Table.DescribeTableOptionsRequest = (function() {

            /**
             * Properties of a DescribeTableOptionsRequest.
             * @memberof Ydb.Table
             * @interface IDescribeTableOptionsRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DescribeTableOptionsRequest operationParams
             */

            /**
             * Constructs a new DescribeTableOptionsRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableOptionsRequest.
             * @implements IDescribeTableOptionsRequest
             * @constructor
             * @param {Ydb.Table.IDescribeTableOptionsRequest=} [properties] Properties to set
             */
            function DescribeTableOptionsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableOptionsRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @instance
             */
            DescribeTableOptionsRequest.prototype.operationParams = null;

            /**
             * Creates a new DescribeTableOptionsRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsRequest=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableOptionsRequest} DescribeTableOptionsRequest instance
             */
            DescribeTableOptionsRequest.create = function create(properties) {
                return new DescribeTableOptionsRequest(properties);
            };

            /**
             * Encodes the specified DescribeTableOptionsRequest message. Does not implicitly {@link Ydb.Table.DescribeTableOptionsRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsRequest} message DescribeTableOptionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableOptionsRequest message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableOptionsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsRequest} message DescribeTableOptionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableOptionsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableOptionsRequest} DescribeTableOptionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableOptionsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableOptionsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableOptionsRequest} DescribeTableOptionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableOptionsRequest message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableOptionsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeTableOptionsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableOptionsRequest} DescribeTableOptionsRequest
             */
            DescribeTableOptionsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableOptionsRequest)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableOptionsRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableOptionsRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableOptionsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Ydb.Table.DescribeTableOptionsRequest} message DescribeTableOptionsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableOptionsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operationParams = null;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this DescribeTableOptionsRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableOptionsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableOptionsRequest;
        })();

        Table.DescribeTableOptionsResponse = (function() {

            /**
             * Properties of a DescribeTableOptionsResponse.
             * @memberof Ydb.Table
             * @interface IDescribeTableOptionsResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DescribeTableOptionsResponse operation
             */

            /**
             * Constructs a new DescribeTableOptionsResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableOptionsResponse.
             * @implements IDescribeTableOptionsResponse
             * @constructor
             * @param {Ydb.Table.IDescribeTableOptionsResponse=} [properties] Properties to set
             */
            function DescribeTableOptionsResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableOptionsResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @instance
             */
            DescribeTableOptionsResponse.prototype.operation = null;

            /**
             * Creates a new DescribeTableOptionsResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResponse=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableOptionsResponse} DescribeTableOptionsResponse instance
             */
            DescribeTableOptionsResponse.create = function create(properties) {
                return new DescribeTableOptionsResponse(properties);
            };

            /**
             * Encodes the specified DescribeTableOptionsResponse message. Does not implicitly {@link Ydb.Table.DescribeTableOptionsResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResponse} message DescribeTableOptionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableOptionsResponse message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableOptionsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResponse} message DescribeTableOptionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableOptionsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableOptionsResponse} DescribeTableOptionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableOptionsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableOptionsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableOptionsResponse} DescribeTableOptionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableOptionsResponse message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableOptionsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeTableOptionsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableOptionsResponse} DescribeTableOptionsResponse
             */
            DescribeTableOptionsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableOptionsResponse)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableOptionsResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableOptionsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Ydb.Table.DescribeTableOptionsResponse} message DescribeTableOptionsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableOptionsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DescribeTableOptionsResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableOptionsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableOptionsResponse;
        })();

        Table.DescribeTableOptionsResult = (function() {

            /**
             * Properties of a DescribeTableOptionsResult.
             * @memberof Ydb.Table
             * @interface IDescribeTableOptionsResult
             * @property {Array.<Ydb.Table.ITableProfileDescription>|null} [tableProfilePresets] DescribeTableOptionsResult tableProfilePresets
             * @property {Array.<Ydb.Table.IStoragePolicyDescription>|null} [storagePolicyPresets] DescribeTableOptionsResult storagePolicyPresets
             * @property {Array.<Ydb.Table.ICompactionPolicyDescription>|null} [compactionPolicyPresets] DescribeTableOptionsResult compactionPolicyPresets
             * @property {Array.<Ydb.Table.IPartitioningPolicyDescription>|null} [partitioningPolicyPresets] DescribeTableOptionsResult partitioningPolicyPresets
             * @property {Array.<Ydb.Table.IExecutionPolicyDescription>|null} [executionPolicyPresets] DescribeTableOptionsResult executionPolicyPresets
             * @property {Array.<Ydb.Table.IReplicationPolicyDescription>|null} [replicationPolicyPresets] DescribeTableOptionsResult replicationPolicyPresets
             * @property {Array.<Ydb.Table.ICachingPolicyDescription>|null} [cachingPolicyPresets] DescribeTableOptionsResult cachingPolicyPresets
             */

            /**
             * Constructs a new DescribeTableOptionsResult.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableOptionsResult.
             * @implements IDescribeTableOptionsResult
             * @constructor
             * @param {Ydb.Table.IDescribeTableOptionsResult=} [properties] Properties to set
             */
            function DescribeTableOptionsResult(properties) {
                this.tableProfilePresets = [];
                this.storagePolicyPresets = [];
                this.compactionPolicyPresets = [];
                this.partitioningPolicyPresets = [];
                this.executionPolicyPresets = [];
                this.replicationPolicyPresets = [];
                this.cachingPolicyPresets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableOptionsResult tableProfilePresets.
             * @member {Array.<Ydb.Table.ITableProfileDescription>} tableProfilePresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.tableProfilePresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult storagePolicyPresets.
             * @member {Array.<Ydb.Table.IStoragePolicyDescription>} storagePolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.storagePolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult compactionPolicyPresets.
             * @member {Array.<Ydb.Table.ICompactionPolicyDescription>} compactionPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.compactionPolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult partitioningPolicyPresets.
             * @member {Array.<Ydb.Table.IPartitioningPolicyDescription>} partitioningPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.partitioningPolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult executionPolicyPresets.
             * @member {Array.<Ydb.Table.IExecutionPolicyDescription>} executionPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.executionPolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult replicationPolicyPresets.
             * @member {Array.<Ydb.Table.IReplicationPolicyDescription>} replicationPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.replicationPolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult cachingPolicyPresets.
             * @member {Array.<Ydb.Table.ICachingPolicyDescription>} cachingPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.cachingPolicyPresets = $util.emptyArray;

            /**
             * Creates a new DescribeTableOptionsResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResult=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableOptionsResult} DescribeTableOptionsResult instance
             */
            DescribeTableOptionsResult.create = function create(properties) {
                return new DescribeTableOptionsResult(properties);
            };

            /**
             * Encodes the specified DescribeTableOptionsResult message. Does not implicitly {@link Ydb.Table.DescribeTableOptionsResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResult} message DescribeTableOptionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableProfilePresets != null && message.tableProfilePresets.length)
                    for (var i = 0; i < message.tableProfilePresets.length; ++i)
                        $root.Ydb.Table.TableProfileDescription.encode(message.tableProfilePresets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.storagePolicyPresets != null && message.storagePolicyPresets.length)
                    for (var i = 0; i < message.storagePolicyPresets.length; ++i)
                        $root.Ydb.Table.StoragePolicyDescription.encode(message.storagePolicyPresets[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.compactionPolicyPresets != null && message.compactionPolicyPresets.length)
                    for (var i = 0; i < message.compactionPolicyPresets.length; ++i)
                        $root.Ydb.Table.CompactionPolicyDescription.encode(message.compactionPolicyPresets[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.partitioningPolicyPresets != null && message.partitioningPolicyPresets.length)
                    for (var i = 0; i < message.partitioningPolicyPresets.length; ++i)
                        $root.Ydb.Table.PartitioningPolicyDescription.encode(message.partitioningPolicyPresets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.executionPolicyPresets != null && message.executionPolicyPresets.length)
                    for (var i = 0; i < message.executionPolicyPresets.length; ++i)
                        $root.Ydb.Table.ExecutionPolicyDescription.encode(message.executionPolicyPresets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.replicationPolicyPresets != null && message.replicationPolicyPresets.length)
                    for (var i = 0; i < message.replicationPolicyPresets.length; ++i)
                        $root.Ydb.Table.ReplicationPolicyDescription.encode(message.replicationPolicyPresets[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.cachingPolicyPresets != null && message.cachingPolicyPresets.length)
                    for (var i = 0; i < message.cachingPolicyPresets.length; ++i)
                        $root.Ydb.Table.CachingPolicyDescription.encode(message.cachingPolicyPresets[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableOptionsResult message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableOptionsResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResult} message DescribeTableOptionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableOptionsResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableOptionsResult} DescribeTableOptionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableOptionsResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tableProfilePresets && message.tableProfilePresets.length))
                            message.tableProfilePresets = [];
                        message.tableProfilePresets.push($root.Ydb.Table.TableProfileDescription.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.storagePolicyPresets && message.storagePolicyPresets.length))
                            message.storagePolicyPresets = [];
                        message.storagePolicyPresets.push($root.Ydb.Table.StoragePolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.compactionPolicyPresets && message.compactionPolicyPresets.length))
                            message.compactionPolicyPresets = [];
                        message.compactionPolicyPresets.push($root.Ydb.Table.CompactionPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.partitioningPolicyPresets && message.partitioningPolicyPresets.length))
                            message.partitioningPolicyPresets = [];
                        message.partitioningPolicyPresets.push($root.Ydb.Table.PartitioningPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.executionPolicyPresets && message.executionPolicyPresets.length))
                            message.executionPolicyPresets = [];
                        message.executionPolicyPresets.push($root.Ydb.Table.ExecutionPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.replicationPolicyPresets && message.replicationPolicyPresets.length))
                            message.replicationPolicyPresets = [];
                        message.replicationPolicyPresets.push($root.Ydb.Table.ReplicationPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.cachingPolicyPresets && message.cachingPolicyPresets.length))
                            message.cachingPolicyPresets = [];
                        message.cachingPolicyPresets.push($root.Ydb.Table.CachingPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableOptionsResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableOptionsResult} DescribeTableOptionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableOptionsResult message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableOptionsResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableProfilePresets != null && message.hasOwnProperty("tableProfilePresets")) {
                    if (!Array.isArray(message.tableProfilePresets))
                        return "tableProfilePresets: array expected";
                    for (var i = 0; i < message.tableProfilePresets.length; ++i) {
                        var error = $root.Ydb.Table.TableProfileDescription.verify(message.tableProfilePresets[i]);
                        if (error)
                            return "tableProfilePresets." + error;
                    }
                }
                if (message.storagePolicyPresets != null && message.hasOwnProperty("storagePolicyPresets")) {
                    if (!Array.isArray(message.storagePolicyPresets))
                        return "storagePolicyPresets: array expected";
                    for (var i = 0; i < message.storagePolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.StoragePolicyDescription.verify(message.storagePolicyPresets[i]);
                        if (error)
                            return "storagePolicyPresets." + error;
                    }
                }
                if (message.compactionPolicyPresets != null && message.hasOwnProperty("compactionPolicyPresets")) {
                    if (!Array.isArray(message.compactionPolicyPresets))
                        return "compactionPolicyPresets: array expected";
                    for (var i = 0; i < message.compactionPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.CompactionPolicyDescription.verify(message.compactionPolicyPresets[i]);
                        if (error)
                            return "compactionPolicyPresets." + error;
                    }
                }
                if (message.partitioningPolicyPresets != null && message.hasOwnProperty("partitioningPolicyPresets")) {
                    if (!Array.isArray(message.partitioningPolicyPresets))
                        return "partitioningPolicyPresets: array expected";
                    for (var i = 0; i < message.partitioningPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.PartitioningPolicyDescription.verify(message.partitioningPolicyPresets[i]);
                        if (error)
                            return "partitioningPolicyPresets." + error;
                    }
                }
                if (message.executionPolicyPresets != null && message.hasOwnProperty("executionPolicyPresets")) {
                    if (!Array.isArray(message.executionPolicyPresets))
                        return "executionPolicyPresets: array expected";
                    for (var i = 0; i < message.executionPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.ExecutionPolicyDescription.verify(message.executionPolicyPresets[i]);
                        if (error)
                            return "executionPolicyPresets." + error;
                    }
                }
                if (message.replicationPolicyPresets != null && message.hasOwnProperty("replicationPolicyPresets")) {
                    if (!Array.isArray(message.replicationPolicyPresets))
                        return "replicationPolicyPresets: array expected";
                    for (var i = 0; i < message.replicationPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.ReplicationPolicyDescription.verify(message.replicationPolicyPresets[i]);
                        if (error)
                            return "replicationPolicyPresets." + error;
                    }
                }
                if (message.cachingPolicyPresets != null && message.hasOwnProperty("cachingPolicyPresets")) {
                    if (!Array.isArray(message.cachingPolicyPresets))
                        return "cachingPolicyPresets: array expected";
                    for (var i = 0; i < message.cachingPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.CachingPolicyDescription.verify(message.cachingPolicyPresets[i]);
                        if (error)
                            return "cachingPolicyPresets." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DescribeTableOptionsResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableOptionsResult} DescribeTableOptionsResult
             */
            DescribeTableOptionsResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableOptionsResult)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableOptionsResult();
                if (object.tableProfilePresets) {
                    if (!Array.isArray(object.tableProfilePresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.tableProfilePresets: array expected");
                    message.tableProfilePresets = [];
                    for (var i = 0; i < object.tableProfilePresets.length; ++i) {
                        if (typeof object.tableProfilePresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.tableProfilePresets: object expected");
                        message.tableProfilePresets[i] = $root.Ydb.Table.TableProfileDescription.fromObject(object.tableProfilePresets[i]);
                    }
                }
                if (object.storagePolicyPresets) {
                    if (!Array.isArray(object.storagePolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.storagePolicyPresets: array expected");
                    message.storagePolicyPresets = [];
                    for (var i = 0; i < object.storagePolicyPresets.length; ++i) {
                        if (typeof object.storagePolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.storagePolicyPresets: object expected");
                        message.storagePolicyPresets[i] = $root.Ydb.Table.StoragePolicyDescription.fromObject(object.storagePolicyPresets[i]);
                    }
                }
                if (object.compactionPolicyPresets) {
                    if (!Array.isArray(object.compactionPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.compactionPolicyPresets: array expected");
                    message.compactionPolicyPresets = [];
                    for (var i = 0; i < object.compactionPolicyPresets.length; ++i) {
                        if (typeof object.compactionPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.compactionPolicyPresets: object expected");
                        message.compactionPolicyPresets[i] = $root.Ydb.Table.CompactionPolicyDescription.fromObject(object.compactionPolicyPresets[i]);
                    }
                }
                if (object.partitioningPolicyPresets) {
                    if (!Array.isArray(object.partitioningPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.partitioningPolicyPresets: array expected");
                    message.partitioningPolicyPresets = [];
                    for (var i = 0; i < object.partitioningPolicyPresets.length; ++i) {
                        if (typeof object.partitioningPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.partitioningPolicyPresets: object expected");
                        message.partitioningPolicyPresets[i] = $root.Ydb.Table.PartitioningPolicyDescription.fromObject(object.partitioningPolicyPresets[i]);
                    }
                }
                if (object.executionPolicyPresets) {
                    if (!Array.isArray(object.executionPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.executionPolicyPresets: array expected");
                    message.executionPolicyPresets = [];
                    for (var i = 0; i < object.executionPolicyPresets.length; ++i) {
                        if (typeof object.executionPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.executionPolicyPresets: object expected");
                        message.executionPolicyPresets[i] = $root.Ydb.Table.ExecutionPolicyDescription.fromObject(object.executionPolicyPresets[i]);
                    }
                }
                if (object.replicationPolicyPresets) {
                    if (!Array.isArray(object.replicationPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.replicationPolicyPresets: array expected");
                    message.replicationPolicyPresets = [];
                    for (var i = 0; i < object.replicationPolicyPresets.length; ++i) {
                        if (typeof object.replicationPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.replicationPolicyPresets: object expected");
                        message.replicationPolicyPresets[i] = $root.Ydb.Table.ReplicationPolicyDescription.fromObject(object.replicationPolicyPresets[i]);
                    }
                }
                if (object.cachingPolicyPresets) {
                    if (!Array.isArray(object.cachingPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.cachingPolicyPresets: array expected");
                    message.cachingPolicyPresets = [];
                    for (var i = 0; i < object.cachingPolicyPresets.length; ++i) {
                        if (typeof object.cachingPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.cachingPolicyPresets: object expected");
                        message.cachingPolicyPresets[i] = $root.Ydb.Table.CachingPolicyDescription.fromObject(object.cachingPolicyPresets[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableOptionsResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Ydb.Table.DescribeTableOptionsResult} message DescribeTableOptionsResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableOptionsResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.tableProfilePresets = [];
                    object.storagePolicyPresets = [];
                    object.compactionPolicyPresets = [];
                    object.partitioningPolicyPresets = [];
                    object.executionPolicyPresets = [];
                    object.replicationPolicyPresets = [];
                    object.cachingPolicyPresets = [];
                }
                if (message.tableProfilePresets && message.tableProfilePresets.length) {
                    object.tableProfilePresets = [];
                    for (var j = 0; j < message.tableProfilePresets.length; ++j)
                        object.tableProfilePresets[j] = $root.Ydb.Table.TableProfileDescription.toObject(message.tableProfilePresets[j], options);
                }
                if (message.storagePolicyPresets && message.storagePolicyPresets.length) {
                    object.storagePolicyPresets = [];
                    for (var j = 0; j < message.storagePolicyPresets.length; ++j)
                        object.storagePolicyPresets[j] = $root.Ydb.Table.StoragePolicyDescription.toObject(message.storagePolicyPresets[j], options);
                }
                if (message.compactionPolicyPresets && message.compactionPolicyPresets.length) {
                    object.compactionPolicyPresets = [];
                    for (var j = 0; j < message.compactionPolicyPresets.length; ++j)
                        object.compactionPolicyPresets[j] = $root.Ydb.Table.CompactionPolicyDescription.toObject(message.compactionPolicyPresets[j], options);
                }
                if (message.partitioningPolicyPresets && message.partitioningPolicyPresets.length) {
                    object.partitioningPolicyPresets = [];
                    for (var j = 0; j < message.partitioningPolicyPresets.length; ++j)
                        object.partitioningPolicyPresets[j] = $root.Ydb.Table.PartitioningPolicyDescription.toObject(message.partitioningPolicyPresets[j], options);
                }
                if (message.executionPolicyPresets && message.executionPolicyPresets.length) {
                    object.executionPolicyPresets = [];
                    for (var j = 0; j < message.executionPolicyPresets.length; ++j)
                        object.executionPolicyPresets[j] = $root.Ydb.Table.ExecutionPolicyDescription.toObject(message.executionPolicyPresets[j], options);
                }
                if (message.replicationPolicyPresets && message.replicationPolicyPresets.length) {
                    object.replicationPolicyPresets = [];
                    for (var j = 0; j < message.replicationPolicyPresets.length; ++j)
                        object.replicationPolicyPresets[j] = $root.Ydb.Table.ReplicationPolicyDescription.toObject(message.replicationPolicyPresets[j], options);
                }
                if (message.cachingPolicyPresets && message.cachingPolicyPresets.length) {
                    object.cachingPolicyPresets = [];
                    for (var j = 0; j < message.cachingPolicyPresets.length; ++j)
                        object.cachingPolicyPresets[j] = $root.Ydb.Table.CachingPolicyDescription.toObject(message.cachingPolicyPresets[j], options);
                }
                return object;
            };

            /**
             * Converts this DescribeTableOptionsResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableOptionsResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableOptionsResult;
        })();

        Table.KeyRange = (function() {

            /**
             * Properties of a KeyRange.
             * @memberof Ydb.Table
             * @interface IKeyRange
             * @property {Ydb.ITypedValue|null} [greater] KeyRange greater
             * @property {Ydb.ITypedValue|null} [greaterOrEqual] KeyRange greaterOrEqual
             * @property {Ydb.ITypedValue|null} [less] KeyRange less
             * @property {Ydb.ITypedValue|null} [lessOrEqual] KeyRange lessOrEqual
             */

            /**
             * Constructs a new KeyRange.
             * @memberof Ydb.Table
             * @classdesc Represents a KeyRange.
             * @implements IKeyRange
             * @constructor
             * @param {Ydb.Table.IKeyRange=} [properties] Properties to set
             */
            function KeyRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyRange greater.
             * @member {Ydb.ITypedValue|null|undefined} greater
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            KeyRange.prototype.greater = null;

            /**
             * KeyRange greaterOrEqual.
             * @member {Ydb.ITypedValue|null|undefined} greaterOrEqual
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            KeyRange.prototype.greaterOrEqual = null;

            /**
             * KeyRange less.
             * @member {Ydb.ITypedValue|null|undefined} less
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            KeyRange.prototype.less = null;

            /**
             * KeyRange lessOrEqual.
             * @member {Ydb.ITypedValue|null|undefined} lessOrEqual
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            KeyRange.prototype.lessOrEqual = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * KeyRange fromBound.
             * @member {"greater"|"greaterOrEqual"|undefined} fromBound
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            Object.defineProperty(KeyRange.prototype, "fromBound", {
                get: $util.oneOfGetter($oneOfFields = ["greater", "greaterOrEqual"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * KeyRange toBound.
             * @member {"less"|"lessOrEqual"|undefined} toBound
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            Object.defineProperty(KeyRange.prototype, "toBound", {
                get: $util.oneOfGetter($oneOfFields = ["less", "lessOrEqual"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new KeyRange instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Ydb.Table.IKeyRange=} [properties] Properties to set
             * @returns {Ydb.Table.KeyRange} KeyRange instance
             */
            KeyRange.create = function create(properties) {
                return new KeyRange(properties);
            };

            /**
             * Encodes the specified KeyRange message. Does not implicitly {@link Ydb.Table.KeyRange.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Ydb.Table.IKeyRange} message KeyRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.greater != null && message.hasOwnProperty("greater"))
                    $root.Ydb.TypedValue.encode(message.greater, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.greaterOrEqual != null && message.hasOwnProperty("greaterOrEqual"))
                    $root.Ydb.TypedValue.encode(message.greaterOrEqual, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.less != null && message.hasOwnProperty("less"))
                    $root.Ydb.TypedValue.encode(message.less, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.lessOrEqual != null && message.hasOwnProperty("lessOrEqual"))
                    $root.Ydb.TypedValue.encode(message.lessOrEqual, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeyRange message, length delimited. Does not implicitly {@link Ydb.Table.KeyRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Ydb.Table.IKeyRange} message KeyRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyRange message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.KeyRange} KeyRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.KeyRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.greater = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.greaterOrEqual = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.less = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.lessOrEqual = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.KeyRange} KeyRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyRange message.
             * @function verify
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.greater != null && message.hasOwnProperty("greater")) {
                    properties.fromBound = 1;
                    {
                        var error = $root.Ydb.TypedValue.verify(message.greater);
                        if (error)
                            return "greater." + error;
                    }
                }
                if (message.greaterOrEqual != null && message.hasOwnProperty("greaterOrEqual")) {
                    if (properties.fromBound === 1)
                        return "fromBound: multiple values";
                    properties.fromBound = 1;
                    {
                        var error = $root.Ydb.TypedValue.verify(message.greaterOrEqual);
                        if (error)
                            return "greaterOrEqual." + error;
                    }
                }
                if (message.less != null && message.hasOwnProperty("less")) {
                    properties.toBound = 1;
                    {
                        var error = $root.Ydb.TypedValue.verify(message.less);
                        if (error)
                            return "less." + error;
                    }
                }
                if (message.lessOrEqual != null && message.hasOwnProperty("lessOrEqual")) {
                    if (properties.toBound === 1)
                        return "toBound: multiple values";
                    properties.toBound = 1;
                    {
                        var error = $root.Ydb.TypedValue.verify(message.lessOrEqual);
                        if (error)
                            return "lessOrEqual." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a KeyRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.KeyRange} KeyRange
             */
            KeyRange.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.KeyRange)
                    return object;
                var message = new $root.Ydb.Table.KeyRange();
                if (object.greater != null) {
                    if (typeof object.greater !== "object")
                        throw TypeError(".Ydb.Table.KeyRange.greater: object expected");
                    message.greater = $root.Ydb.TypedValue.fromObject(object.greater);
                }
                if (object.greaterOrEqual != null) {
                    if (typeof object.greaterOrEqual !== "object")
                        throw TypeError(".Ydb.Table.KeyRange.greaterOrEqual: object expected");
                    message.greaterOrEqual = $root.Ydb.TypedValue.fromObject(object.greaterOrEqual);
                }
                if (object.less != null) {
                    if (typeof object.less !== "object")
                        throw TypeError(".Ydb.Table.KeyRange.less: object expected");
                    message.less = $root.Ydb.TypedValue.fromObject(object.less);
                }
                if (object.lessOrEqual != null) {
                    if (typeof object.lessOrEqual !== "object")
                        throw TypeError(".Ydb.Table.KeyRange.lessOrEqual: object expected");
                    message.lessOrEqual = $root.Ydb.TypedValue.fromObject(object.lessOrEqual);
                }
                return message;
            };

            /**
             * Creates a plain object from a KeyRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Ydb.Table.KeyRange} message KeyRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.greater != null && message.hasOwnProperty("greater")) {
                    object.greater = $root.Ydb.TypedValue.toObject(message.greater, options);
                    if (options.oneofs)
                        object.fromBound = "greater";
                }
                if (message.greaterOrEqual != null && message.hasOwnProperty("greaterOrEqual")) {
                    object.greaterOrEqual = $root.Ydb.TypedValue.toObject(message.greaterOrEqual, options);
                    if (options.oneofs)
                        object.fromBound = "greaterOrEqual";
                }
                if (message.less != null && message.hasOwnProperty("less")) {
                    object.less = $root.Ydb.TypedValue.toObject(message.less, options);
                    if (options.oneofs)
                        object.toBound = "less";
                }
                if (message.lessOrEqual != null && message.hasOwnProperty("lessOrEqual")) {
                    object.lessOrEqual = $root.Ydb.TypedValue.toObject(message.lessOrEqual, options);
                    if (options.oneofs)
                        object.toBound = "lessOrEqual";
                }
                return object;
            };

            /**
             * Converts this KeyRange to JSON.
             * @function toJSON
             * @memberof Ydb.Table.KeyRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeyRange;
        })();

        Table.ReadTableRequest = (function() {

            /**
             * Properties of a ReadTableRequest.
             * @memberof Ydb.Table
             * @interface IReadTableRequest
             * @property {string|null} [sessionId] ReadTableRequest sessionId
             * @property {string|null} [path] ReadTableRequest path
             * @property {Ydb.Table.IKeyRange|null} [keyRange] ReadTableRequest keyRange
             * @property {Array.<string>|null} [columns] ReadTableRequest columns
             * @property {boolean|null} [ordered] ReadTableRequest ordered
             * @property {number|Long|null} [rowLimit] ReadTableRequest rowLimit
             * @property {Ydb.FeatureFlag.Status|null} [useSnapshot] ReadTableRequest useSnapshot
             */

            /**
             * Constructs a new ReadTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a ReadTableRequest.
             * @implements IReadTableRequest
             * @constructor
             * @param {Ydb.Table.IReadTableRequest=} [properties] Properties to set
             */
            function ReadTableRequest(properties) {
                this.columns = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.sessionId = "";

            /**
             * ReadTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.path = "";

            /**
             * ReadTableRequest keyRange.
             * @member {Ydb.Table.IKeyRange|null|undefined} keyRange
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.keyRange = null;

            /**
             * ReadTableRequest columns.
             * @member {Array.<string>} columns
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.columns = $util.emptyArray;

            /**
             * ReadTableRequest ordered.
             * @member {boolean} ordered
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.ordered = false;

            /**
             * ReadTableRequest rowLimit.
             * @member {number|Long} rowLimit
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.rowLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ReadTableRequest useSnapshot.
             * @member {Ydb.FeatureFlag.Status} useSnapshot
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.useSnapshot = 0;

            /**
             * Creates a new ReadTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Ydb.Table.IReadTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ReadTableRequest} ReadTableRequest instance
             */
            ReadTableRequest.create = function create(properties) {
                return new ReadTableRequest(properties);
            };

            /**
             * Encodes the specified ReadTableRequest message. Does not implicitly {@link Ydb.Table.ReadTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Ydb.Table.IReadTableRequest} message ReadTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.keyRange != null && message.hasOwnProperty("keyRange"))
                    $root.Ydb.Table.KeyRange.encode(message.keyRange, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.columns != null && message.columns.length)
                    for (var i = 0; i < message.columns.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.columns[i]);
                if (message.ordered != null && message.hasOwnProperty("ordered"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.ordered);
                if (message.rowLimit != null && message.hasOwnProperty("rowLimit"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.rowLimit);
                if (message.useSnapshot != null && message.hasOwnProperty("useSnapshot"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.useSnapshot);
                return writer;
            };

            /**
             * Encodes the specified ReadTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.ReadTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Ydb.Table.IReadTableRequest} message ReadTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReadTableRequest} ReadTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReadTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 3:
                        message.keyRange = $root.Ydb.Table.KeyRange.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.columns && message.columns.length))
                            message.columns = [];
                        message.columns.push(reader.string());
                        break;
                    case 5:
                        message.ordered = reader.bool();
                        break;
                    case 6:
                        message.rowLimit = reader.uint64();
                        break;
                    case 7:
                        message.useSnapshot = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReadTableRequest} ReadTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadTableRequest message.
             * @function verify
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.keyRange != null && message.hasOwnProperty("keyRange")) {
                    var error = $root.Ydb.Table.KeyRange.verify(message.keyRange);
                    if (error)
                        return "keyRange." + error;
                }
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (var i = 0; i < message.columns.length; ++i)
                        if (!$util.isString(message.columns[i]))
                            return "columns: string[] expected";
                }
                if (message.ordered != null && message.hasOwnProperty("ordered"))
                    if (typeof message.ordered !== "boolean")
                        return "ordered: boolean expected";
                if (message.rowLimit != null && message.hasOwnProperty("rowLimit"))
                    if (!$util.isInteger(message.rowLimit) && !(message.rowLimit && $util.isInteger(message.rowLimit.low) && $util.isInteger(message.rowLimit.high)))
                        return "rowLimit: integer|Long expected";
                if (message.useSnapshot != null && message.hasOwnProperty("useSnapshot"))
                    switch (message.useSnapshot) {
                    default:
                        return "useSnapshot: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a ReadTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReadTableRequest} ReadTableRequest
             */
            ReadTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReadTableRequest)
                    return object;
                var message = new $root.Ydb.Table.ReadTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.keyRange != null) {
                    if (typeof object.keyRange !== "object")
                        throw TypeError(".Ydb.Table.ReadTableRequest.keyRange: object expected");
                    message.keyRange = $root.Ydb.Table.KeyRange.fromObject(object.keyRange);
                }
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".Ydb.Table.ReadTableRequest.columns: array expected");
                    message.columns = [];
                    for (var i = 0; i < object.columns.length; ++i)
                        message.columns[i] = String(object.columns[i]);
                }
                if (object.ordered != null)
                    message.ordered = Boolean(object.ordered);
                if (object.rowLimit != null)
                    if ($util.Long)
                        (message.rowLimit = $util.Long.fromValue(object.rowLimit)).unsigned = true;
                    else if (typeof object.rowLimit === "string")
                        message.rowLimit = parseInt(object.rowLimit, 10);
                    else if (typeof object.rowLimit === "number")
                        message.rowLimit = object.rowLimit;
                    else if (typeof object.rowLimit === "object")
                        message.rowLimit = new $util.LongBits(object.rowLimit.low >>> 0, object.rowLimit.high >>> 0).toNumber(true);
                switch (object.useSnapshot) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.useSnapshot = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.useSnapshot = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.useSnapshot = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Ydb.Table.ReadTableRequest} message ReadTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.columns = [];
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.keyRange = null;
                    object.ordered = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.rowLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowLimit = options.longs === String ? "0" : 0;
                    object.useSnapshot = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.keyRange != null && message.hasOwnProperty("keyRange"))
                    object.keyRange = $root.Ydb.Table.KeyRange.toObject(message.keyRange, options);
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (var j = 0; j < message.columns.length; ++j)
                        object.columns[j] = message.columns[j];
                }
                if (message.ordered != null && message.hasOwnProperty("ordered"))
                    object.ordered = message.ordered;
                if (message.rowLimit != null && message.hasOwnProperty("rowLimit"))
                    if (typeof message.rowLimit === "number")
                        object.rowLimit = options.longs === String ? String(message.rowLimit) : message.rowLimit;
                    else
                        object.rowLimit = options.longs === String ? $util.Long.prototype.toString.call(message.rowLimit) : options.longs === Number ? new $util.LongBits(message.rowLimit.low >>> 0, message.rowLimit.high >>> 0).toNumber(true) : message.rowLimit;
                if (message.useSnapshot != null && message.hasOwnProperty("useSnapshot"))
                    object.useSnapshot = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.useSnapshot] : message.useSnapshot;
                return object;
            };

            /**
             * Converts this ReadTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadTableRequest;
        })();

        Table.ReadTableResponse = (function() {

            /**
             * Properties of a ReadTableResponse.
             * @memberof Ydb.Table
             * @interface IReadTableResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] ReadTableResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ReadTableResponse issues
             * @property {Ydb.Table.IReadTableResult|null} [result] ReadTableResponse result
             */

            /**
             * Constructs a new ReadTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a ReadTableResponse.
             * @implements IReadTableResponse
             * @constructor
             * @param {Ydb.Table.IReadTableResponse=} [properties] Properties to set
             */
            function ReadTableResponse(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadTableResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Table.ReadTableResponse
             * @instance
             */
            ReadTableResponse.prototype.status = 0;

            /**
             * ReadTableResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Table.ReadTableResponse
             * @instance
             */
            ReadTableResponse.prototype.issues = $util.emptyArray;

            /**
             * ReadTableResponse result.
             * @member {Ydb.Table.IReadTableResult|null|undefined} result
             * @memberof Ydb.Table.ReadTableResponse
             * @instance
             */
            ReadTableResponse.prototype.result = null;

            /**
             * Creates a new ReadTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Ydb.Table.IReadTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ReadTableResponse} ReadTableResponse instance
             */
            ReadTableResponse.create = function create(properties) {
                return new ReadTableResponse(properties);
            };

            /**
             * Encodes the specified ReadTableResponse message. Does not implicitly {@link Ydb.Table.ReadTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Ydb.Table.IReadTableResponse} message ReadTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.result != null && message.hasOwnProperty("result"))
                    $root.Ydb.Table.ReadTableResult.encode(message.result, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.ReadTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Ydb.Table.IReadTableResponse} message ReadTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReadTableResponse} ReadTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReadTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.result = $root.Ydb.Table.ReadTableResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReadTableResponse} ReadTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadTableResponse message.
             * @function verify
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    var error = $root.Ydb.Table.ReadTableResult.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                return null;
            };

            /**
             * Creates a ReadTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReadTableResponse} ReadTableResponse
             */
            ReadTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReadTableResponse)
                    return object;
                var message = new $root.Ydb.Table.ReadTableResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Table.ReadTableResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Table.ReadTableResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".Ydb.Table.ReadTableResponse.result: object expected");
                    message.result = $root.Ydb.Table.ReadTableResult.fromObject(object.result);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Ydb.Table.ReadTableResponse} message ReadTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults) {
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    object.result = null;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.Ydb.Table.ReadTableResult.toObject(message.result, options);
                return object;
            };

            /**
             * Converts this ReadTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReadTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadTableResponse;
        })();

        Table.ReadTableResult = (function() {

            /**
             * Properties of a ReadTableResult.
             * @memberof Ydb.Table
             * @interface IReadTableResult
             * @property {Ydb.IResultSet|null} [resultSet] ReadTableResult resultSet
             */

            /**
             * Constructs a new ReadTableResult.
             * @memberof Ydb.Table
             * @classdesc Represents a ReadTableResult.
             * @implements IReadTableResult
             * @constructor
             * @param {Ydb.Table.IReadTableResult=} [properties] Properties to set
             */
            function ReadTableResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadTableResult resultSet.
             * @member {Ydb.IResultSet|null|undefined} resultSet
             * @memberof Ydb.Table.ReadTableResult
             * @instance
             */
            ReadTableResult.prototype.resultSet = null;

            /**
             * Creates a new ReadTableResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Ydb.Table.IReadTableResult=} [properties] Properties to set
             * @returns {Ydb.Table.ReadTableResult} ReadTableResult instance
             */
            ReadTableResult.create = function create(properties) {
                return new ReadTableResult(properties);
            };

            /**
             * Encodes the specified ReadTableResult message. Does not implicitly {@link Ydb.Table.ReadTableResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Ydb.Table.IReadTableResult} message ReadTableResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultSet != null && message.hasOwnProperty("resultSet"))
                    $root.Ydb.ResultSet.encode(message.resultSet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadTableResult message, length delimited. Does not implicitly {@link Ydb.Table.ReadTableResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Ydb.Table.IReadTableResult} message ReadTableResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadTableResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReadTableResult} ReadTableResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReadTableResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resultSet = $root.Ydb.ResultSet.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadTableResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReadTableResult} ReadTableResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadTableResult message.
             * @function verify
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadTableResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultSet != null && message.hasOwnProperty("resultSet")) {
                    var error = $root.Ydb.ResultSet.verify(message.resultSet);
                    if (error)
                        return "resultSet." + error;
                }
                return null;
            };

            /**
             * Creates a ReadTableResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReadTableResult} ReadTableResult
             */
            ReadTableResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReadTableResult)
                    return object;
                var message = new $root.Ydb.Table.ReadTableResult();
                if (object.resultSet != null) {
                    if (typeof object.resultSet !== "object")
                        throw TypeError(".Ydb.Table.ReadTableResult.resultSet: object expected");
                    message.resultSet = $root.Ydb.ResultSet.fromObject(object.resultSet);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadTableResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Ydb.Table.ReadTableResult} message ReadTableResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadTableResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.resultSet = null;
                if (message.resultSet != null && message.hasOwnProperty("resultSet"))
                    object.resultSet = $root.Ydb.ResultSet.toObject(message.resultSet, options);
                return object;
            };

            /**
             * Converts this ReadTableResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReadTableResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadTableResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadTableResult;
        })();

        Table.BulkUpsertRequest = (function() {

            /**
             * Properties of a BulkUpsertRequest.
             * @memberof Ydb.Table
             * @interface IBulkUpsertRequest
             * @property {string|null} [table] BulkUpsertRequest table
             * @property {Ydb.ITypedValue|null} [rows] BulkUpsertRequest rows
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] BulkUpsertRequest operationParams
             */

            /**
             * Constructs a new BulkUpsertRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a BulkUpsertRequest.
             * @implements IBulkUpsertRequest
             * @constructor
             * @param {Ydb.Table.IBulkUpsertRequest=} [properties] Properties to set
             */
            function BulkUpsertRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BulkUpsertRequest table.
             * @member {string} table
             * @memberof Ydb.Table.BulkUpsertRequest
             * @instance
             */
            BulkUpsertRequest.prototype.table = "";

            /**
             * BulkUpsertRequest rows.
             * @member {Ydb.ITypedValue|null|undefined} rows
             * @memberof Ydb.Table.BulkUpsertRequest
             * @instance
             */
            BulkUpsertRequest.prototype.rows = null;

            /**
             * BulkUpsertRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.BulkUpsertRequest
             * @instance
             */
            BulkUpsertRequest.prototype.operationParams = null;

            /**
             * Creates a new BulkUpsertRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Ydb.Table.IBulkUpsertRequest=} [properties] Properties to set
             * @returns {Ydb.Table.BulkUpsertRequest} BulkUpsertRequest instance
             */
            BulkUpsertRequest.create = function create(properties) {
                return new BulkUpsertRequest(properties);
            };

            /**
             * Encodes the specified BulkUpsertRequest message. Does not implicitly {@link Ydb.Table.BulkUpsertRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Ydb.Table.IBulkUpsertRequest} message BulkUpsertRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.table != null && message.hasOwnProperty("table"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.table);
                if (message.rows != null && message.hasOwnProperty("rows"))
                    $root.Ydb.TypedValue.encode(message.rows, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BulkUpsertRequest message, length delimited. Does not implicitly {@link Ydb.Table.BulkUpsertRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Ydb.Table.IBulkUpsertRequest} message BulkUpsertRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BulkUpsertRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BulkUpsertRequest} BulkUpsertRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BulkUpsertRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.table = reader.string();
                        break;
                    case 2:
                        message.rows = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BulkUpsertRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BulkUpsertRequest} BulkUpsertRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BulkUpsertRequest message.
             * @function verify
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BulkUpsertRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.table != null && message.hasOwnProperty("table"))
                    if (!$util.isString(message.table))
                        return "table: string expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    var error = $root.Ydb.TypedValue.verify(message.rows);
                    if (error)
                        return "rows." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a BulkUpsertRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BulkUpsertRequest} BulkUpsertRequest
             */
            BulkUpsertRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BulkUpsertRequest)
                    return object;
                var message = new $root.Ydb.Table.BulkUpsertRequest();
                if (object.table != null)
                    message.table = String(object.table);
                if (object.rows != null) {
                    if (typeof object.rows !== "object")
                        throw TypeError(".Ydb.Table.BulkUpsertRequest.rows: object expected");
                    message.rows = $root.Ydb.TypedValue.fromObject(object.rows);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.BulkUpsertRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a BulkUpsertRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Ydb.Table.BulkUpsertRequest} message BulkUpsertRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BulkUpsertRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.table = "";
                    object.rows = null;
                    object.operationParams = null;
                }
                if (message.table != null && message.hasOwnProperty("table"))
                    object.table = message.table;
                if (message.rows != null && message.hasOwnProperty("rows"))
                    object.rows = $root.Ydb.TypedValue.toObject(message.rows, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this BulkUpsertRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BulkUpsertRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BulkUpsertRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BulkUpsertRequest;
        })();

        Table.BulkUpsertResponse = (function() {

            /**
             * Properties of a BulkUpsertResponse.
             * @memberof Ydb.Table
             * @interface IBulkUpsertResponse
             * @property {Ydb.Operations.IOperation|null} [operation] BulkUpsertResponse operation
             */

            /**
             * Constructs a new BulkUpsertResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a BulkUpsertResponse.
             * @implements IBulkUpsertResponse
             * @constructor
             * @param {Ydb.Table.IBulkUpsertResponse=} [properties] Properties to set
             */
            function BulkUpsertResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BulkUpsertResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.BulkUpsertResponse
             * @instance
             */
            BulkUpsertResponse.prototype.operation = null;

            /**
             * Creates a new BulkUpsertResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Ydb.Table.IBulkUpsertResponse=} [properties] Properties to set
             * @returns {Ydb.Table.BulkUpsertResponse} BulkUpsertResponse instance
             */
            BulkUpsertResponse.create = function create(properties) {
                return new BulkUpsertResponse(properties);
            };

            /**
             * Encodes the specified BulkUpsertResponse message. Does not implicitly {@link Ydb.Table.BulkUpsertResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Ydb.Table.IBulkUpsertResponse} message BulkUpsertResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && message.hasOwnProperty("operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BulkUpsertResponse message, length delimited. Does not implicitly {@link Ydb.Table.BulkUpsertResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Ydb.Table.IBulkUpsertResponse} message BulkUpsertResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BulkUpsertResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BulkUpsertResponse} BulkUpsertResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BulkUpsertResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BulkUpsertResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BulkUpsertResponse} BulkUpsertResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BulkUpsertResponse message.
             * @function verify
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BulkUpsertResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a BulkUpsertResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BulkUpsertResponse} BulkUpsertResponse
             */
            BulkUpsertResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BulkUpsertResponse)
                    return object;
                var message = new $root.Ydb.Table.BulkUpsertResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.BulkUpsertResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a BulkUpsertResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Ydb.Table.BulkUpsertResponse} message BulkUpsertResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BulkUpsertResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this BulkUpsertResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BulkUpsertResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BulkUpsertResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BulkUpsertResponse;
        })();

        Table.BulkUpsertResult = (function() {

            /**
             * Properties of a BulkUpsertResult.
             * @memberof Ydb.Table
             * @interface IBulkUpsertResult
             */

            /**
             * Constructs a new BulkUpsertResult.
             * @memberof Ydb.Table
             * @classdesc Represents a BulkUpsertResult.
             * @implements IBulkUpsertResult
             * @constructor
             * @param {Ydb.Table.IBulkUpsertResult=} [properties] Properties to set
             */
            function BulkUpsertResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BulkUpsertResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Ydb.Table.IBulkUpsertResult=} [properties] Properties to set
             * @returns {Ydb.Table.BulkUpsertResult} BulkUpsertResult instance
             */
            BulkUpsertResult.create = function create(properties) {
                return new BulkUpsertResult(properties);
            };

            /**
             * Encodes the specified BulkUpsertResult message. Does not implicitly {@link Ydb.Table.BulkUpsertResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Ydb.Table.IBulkUpsertResult} message BulkUpsertResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BulkUpsertResult message, length delimited. Does not implicitly {@link Ydb.Table.BulkUpsertResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Ydb.Table.IBulkUpsertResult} message BulkUpsertResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BulkUpsertResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BulkUpsertResult} BulkUpsertResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BulkUpsertResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BulkUpsertResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BulkUpsertResult} BulkUpsertResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BulkUpsertResult message.
             * @function verify
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BulkUpsertResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BulkUpsertResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BulkUpsertResult} BulkUpsertResult
             */
            BulkUpsertResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BulkUpsertResult)
                    return object;
                return new $root.Ydb.Table.BulkUpsertResult();
            };

            /**
             * Creates a plain object from a BulkUpsertResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Ydb.Table.BulkUpsertResult} message BulkUpsertResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BulkUpsertResult.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BulkUpsertResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BulkUpsertResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BulkUpsertResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BulkUpsertResult;
        })();

        Table.ExecuteStreamQueryRequest = (function() {

            /**
             * Properties of an ExecuteStreamQueryRequest.
             * @memberof Ydb.Table
             * @interface IExecuteStreamQueryRequest
             * @property {Ydb.Table.ExecuteStreamQueryRequest.Mode|null} [mode] ExecuteStreamQueryRequest mode
             * @property {Ydb.Table.IQuery|null} [query] ExecuteStreamQueryRequest query
             * @property {Object.<string,Ydb.ITypedValue>|null} [parameters] ExecuteStreamQueryRequest parameters
             */

            /**
             * Constructs a new ExecuteStreamQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteStreamQueryRequest.
             * @implements IExecuteStreamQueryRequest
             * @constructor
             * @param {Ydb.Table.IExecuteStreamQueryRequest=} [properties] Properties to set
             */
            function ExecuteStreamQueryRequest(properties) {
                this.parameters = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteStreamQueryRequest mode.
             * @member {Ydb.Table.ExecuteStreamQueryRequest.Mode} mode
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @instance
             */
            ExecuteStreamQueryRequest.prototype.mode = 0;

            /**
             * ExecuteStreamQueryRequest query.
             * @member {Ydb.Table.IQuery|null|undefined} query
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @instance
             */
            ExecuteStreamQueryRequest.prototype.query = null;

            /**
             * ExecuteStreamQueryRequest parameters.
             * @member {Object.<string,Ydb.ITypedValue>} parameters
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @instance
             */
            ExecuteStreamQueryRequest.prototype.parameters = $util.emptyObject;

            /**
             * Creates a new ExecuteStreamQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteStreamQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteStreamQueryRequest} ExecuteStreamQueryRequest instance
             */
            ExecuteStreamQueryRequest.create = function create(properties) {
                return new ExecuteStreamQueryRequest(properties);
            };

            /**
             * Encodes the specified ExecuteStreamQueryRequest message. Does not implicitly {@link Ydb.Table.ExecuteStreamQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteStreamQueryRequest} message ExecuteStreamQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteStreamQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mode != null && message.hasOwnProperty("mode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                if (message.query != null && message.hasOwnProperty("query"))
                    $root.Ydb.Table.Query.encode(message.query, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.parameters != null && message.hasOwnProperty("parameters"))
                    for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.TypedValue.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified ExecuteStreamQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteStreamQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteStreamQueryRequest} message ExecuteStreamQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteStreamQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteStreamQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteStreamQueryRequest} ExecuteStreamQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteStreamQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteStreamQueryRequest(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mode = reader.int32();
                        break;
                    case 2:
                        message.query = $root.Ydb.Table.Query.decode(reader, reader.uint32());
                        break;
                    case 3:
                        reader.skip().pos++;
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        key = reader.string();
                        reader.pos++;
                        message.parameters[key] = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteStreamQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteStreamQueryRequest} ExecuteStreamQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteStreamQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteStreamQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteStreamQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.query != null && message.hasOwnProperty("query")) {
                    var error = $root.Ydb.Table.Query.verify(message.query);
                    if (error)
                        return "query." + error;
                }
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!$util.isObject(message.parameters))
                        return "parameters: object expected";
                    var key = Object.keys(message.parameters);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.parameters[key[i]]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExecuteStreamQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteStreamQueryRequest} ExecuteStreamQueryRequest
             */
            ExecuteStreamQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteStreamQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.ExecuteStreamQueryRequest();
                switch (object.mode) {
                case "MODE_UNSPECIFIED":
                case 0:
                    message.mode = 0;
                    break;
                case "MODE_EXEC":
                case 1:
                    message.mode = 1;
                    break;
                }
                if (object.query != null) {
                    if (typeof object.query !== "object")
                        throw TypeError(".Ydb.Table.ExecuteStreamQueryRequest.query: object expected");
                    message.query = $root.Ydb.Table.Query.fromObject(object.query);
                }
                if (object.parameters) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".Ydb.Table.ExecuteStreamQueryRequest.parameters: object expected");
                    message.parameters = {};
                    for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                        if (typeof object.parameters[keys[i]] !== "object")
                            throw TypeError(".Ydb.Table.ExecuteStreamQueryRequest.parameters: object expected");
                        message.parameters[keys[i]] = $root.Ydb.TypedValue.fromObject(object.parameters[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteStreamQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @static
             * @param {Ydb.Table.ExecuteStreamQueryRequest} message ExecuteStreamQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteStreamQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parameters = {};
                if (options.defaults) {
                    object.mode = options.enums === String ? "MODE_UNSPECIFIED" : 0;
                    object.query = null;
                }
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.Ydb.Table.ExecuteStreamQueryRequest.Mode[message.mode] : message.mode;
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = $root.Ydb.Table.Query.toObject(message.query, options);
                var keys2;
                if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                    object.parameters = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parameters[keys2[j]] = $root.Ydb.TypedValue.toObject(message.parameters[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this ExecuteStreamQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteStreamQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteStreamQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Mode enum.
             * @name Ydb.Table.ExecuteStreamQueryRequest.Mode
             * @enum {string}
             * @property {number} MODE_UNSPECIFIED=0 MODE_UNSPECIFIED value
             * @property {number} MODE_EXEC=1 MODE_EXEC value
             */
            ExecuteStreamQueryRequest.Mode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MODE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "MODE_EXEC"] = 1;
                return values;
            })();

            return ExecuteStreamQueryRequest;
        })();

        Table.ExecuteStreamQueryResponse = (function() {

            /**
             * Properties of an ExecuteStreamQueryResponse.
             * @memberof Ydb.Table
             * @interface IExecuteStreamQueryResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] ExecuteStreamQueryResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ExecuteStreamQueryResponse issues
             * @property {Ydb.Table.IExecuteStreamQueryResult|null} [result] ExecuteStreamQueryResponse result
             */

            /**
             * Constructs a new ExecuteStreamQueryResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteStreamQueryResponse.
             * @implements IExecuteStreamQueryResponse
             * @constructor
             * @param {Ydb.Table.IExecuteStreamQueryResponse=} [properties] Properties to set
             */
            function ExecuteStreamQueryResponse(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteStreamQueryResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @instance
             */
            ExecuteStreamQueryResponse.prototype.status = 0;

            /**
             * ExecuteStreamQueryResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @instance
             */
            ExecuteStreamQueryResponse.prototype.issues = $util.emptyArray;

            /**
             * ExecuteStreamQueryResponse result.
             * @member {Ydb.Table.IExecuteStreamQueryResult|null|undefined} result
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @instance
             */
            ExecuteStreamQueryResponse.prototype.result = null;

            /**
             * Creates a new ExecuteStreamQueryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteStreamQueryResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteStreamQueryResponse} ExecuteStreamQueryResponse instance
             */
            ExecuteStreamQueryResponse.create = function create(properties) {
                return new ExecuteStreamQueryResponse(properties);
            };

            /**
             * Encodes the specified ExecuteStreamQueryResponse message. Does not implicitly {@link Ydb.Table.ExecuteStreamQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteStreamQueryResponse} message ExecuteStreamQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteStreamQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.result != null && message.hasOwnProperty("result"))
                    $root.Ydb.Table.ExecuteStreamQueryResult.encode(message.result, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteStreamQueryResponse message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteStreamQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteStreamQueryResponse} message ExecuteStreamQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteStreamQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteStreamQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteStreamQueryResponse} ExecuteStreamQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteStreamQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteStreamQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.result = $root.Ydb.Table.ExecuteStreamQueryResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteStreamQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteStreamQueryResponse} ExecuteStreamQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteStreamQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteStreamQueryResponse message.
             * @function verify
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteStreamQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    var error = $root.Ydb.Table.ExecuteStreamQueryResult.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteStreamQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteStreamQueryResponse} ExecuteStreamQueryResponse
             */
            ExecuteStreamQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteStreamQueryResponse)
                    return object;
                var message = new $root.Ydb.Table.ExecuteStreamQueryResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Table.ExecuteStreamQueryResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Table.ExecuteStreamQueryResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".Ydb.Table.ExecuteStreamQueryResponse.result: object expected");
                    message.result = $root.Ydb.Table.ExecuteStreamQueryResult.fromObject(object.result);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteStreamQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @static
             * @param {Ydb.Table.ExecuteStreamQueryResponse} message ExecuteStreamQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteStreamQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults) {
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    object.result = null;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.Ydb.Table.ExecuteStreamQueryResult.toObject(message.result, options);
                return object;
            };

            /**
             * Converts this ExecuteStreamQueryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteStreamQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteStreamQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteStreamQueryResponse;
        })();

        Table.ExecuteStreamQueryResult = (function() {

            /**
             * Properties of an ExecuteStreamQueryResult.
             * @memberof Ydb.Table
             * @interface IExecuteStreamQueryResult
             * @property {Ydb.IResultSet|null} [resultSet] ExecuteStreamQueryResult resultSet
             */

            /**
             * Constructs a new ExecuteStreamQueryResult.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteStreamQueryResult.
             * @implements IExecuteStreamQueryResult
             * @constructor
             * @param {Ydb.Table.IExecuteStreamQueryResult=} [properties] Properties to set
             */
            function ExecuteStreamQueryResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteStreamQueryResult resultSet.
             * @member {Ydb.IResultSet|null|undefined} resultSet
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @instance
             */
            ExecuteStreamQueryResult.prototype.resultSet = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ExecuteStreamQueryResult type.
             * @member {"resultSet"|undefined} type
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @instance
             */
            Object.defineProperty(ExecuteStreamQueryResult.prototype, "type", {
                get: $util.oneOfGetter($oneOfFields = ["resultSet"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ExecuteStreamQueryResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @static
             * @param {Ydb.Table.IExecuteStreamQueryResult=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteStreamQueryResult} ExecuteStreamQueryResult instance
             */
            ExecuteStreamQueryResult.create = function create(properties) {
                return new ExecuteStreamQueryResult(properties);
            };

            /**
             * Encodes the specified ExecuteStreamQueryResult message. Does not implicitly {@link Ydb.Table.ExecuteStreamQueryResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @static
             * @param {Ydb.Table.IExecuteStreamQueryResult} message ExecuteStreamQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteStreamQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultSet != null && message.hasOwnProperty("resultSet"))
                    $root.Ydb.ResultSet.encode(message.resultSet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteStreamQueryResult message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteStreamQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @static
             * @param {Ydb.Table.IExecuteStreamQueryResult} message ExecuteStreamQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteStreamQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteStreamQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteStreamQueryResult} ExecuteStreamQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteStreamQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteStreamQueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resultSet = $root.Ydb.ResultSet.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteStreamQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteStreamQueryResult} ExecuteStreamQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteStreamQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteStreamQueryResult message.
             * @function verify
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteStreamQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.resultSet != null && message.hasOwnProperty("resultSet")) {
                    properties.type = 1;
                    {
                        var error = $root.Ydb.ResultSet.verify(message.resultSet);
                        if (error)
                            return "resultSet." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExecuteStreamQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteStreamQueryResult} ExecuteStreamQueryResult
             */
            ExecuteStreamQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteStreamQueryResult)
                    return object;
                var message = new $root.Ydb.Table.ExecuteStreamQueryResult();
                if (object.resultSet != null) {
                    if (typeof object.resultSet !== "object")
                        throw TypeError(".Ydb.Table.ExecuteStreamQueryResult.resultSet: object expected");
                    message.resultSet = $root.Ydb.ResultSet.fromObject(object.resultSet);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteStreamQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @static
             * @param {Ydb.Table.ExecuteStreamQueryResult} message ExecuteStreamQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteStreamQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.resultSet != null && message.hasOwnProperty("resultSet")) {
                    object.resultSet = $root.Ydb.ResultSet.toObject(message.resultSet, options);
                    if (options.oneofs)
                        object.type = "resultSet";
                }
                return object;
            };

            /**
             * Converts this ExecuteStreamQueryResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteStreamQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteStreamQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteStreamQueryResult;
        })();

        return Table;
    })();

    Ydb.FeatureFlag = (function() {

        /**
         * Properties of a FeatureFlag.
         * @memberof Ydb
         * @interface IFeatureFlag
         */

        /**
         * Constructs a new FeatureFlag.
         * @memberof Ydb
         * @classdesc Represents a FeatureFlag.
         * @implements IFeatureFlag
         * @constructor
         * @param {Ydb.IFeatureFlag=} [properties] Properties to set
         */
        function FeatureFlag(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FeatureFlag instance using the specified properties.
         * @function create
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Ydb.IFeatureFlag=} [properties] Properties to set
         * @returns {Ydb.FeatureFlag} FeatureFlag instance
         */
        FeatureFlag.create = function create(properties) {
            return new FeatureFlag(properties);
        };

        /**
         * Encodes the specified FeatureFlag message. Does not implicitly {@link Ydb.FeatureFlag.verify|verify} messages.
         * @function encode
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Ydb.IFeatureFlag} message FeatureFlag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureFlag.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FeatureFlag message, length delimited. Does not implicitly {@link Ydb.FeatureFlag.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Ydb.IFeatureFlag} message FeatureFlag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureFlag.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeatureFlag message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.FeatureFlag} FeatureFlag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureFlag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.FeatureFlag();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeatureFlag message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.FeatureFlag} FeatureFlag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureFlag.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeatureFlag message.
         * @function verify
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeatureFlag.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a FeatureFlag message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.FeatureFlag} FeatureFlag
         */
        FeatureFlag.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.FeatureFlag)
                return object;
            return new $root.Ydb.FeatureFlag();
        };

        /**
         * Creates a plain object from a FeatureFlag message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Ydb.FeatureFlag} message FeatureFlag
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeatureFlag.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FeatureFlag to JSON.
         * @function toJSON
         * @memberof Ydb.FeatureFlag
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeatureFlag.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name Ydb.FeatureFlag.Status
         * @enum {string}
         * @property {number} STATUS_UNSPECIFIED=0 STATUS_UNSPECIFIED value
         * @property {number} ENABLED=1 ENABLED value
         * @property {number} DISABLED=2 DISABLED value
         */
        FeatureFlag.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STATUS_UNSPECIFIED"] = 0;
            values[valuesById[1] = "ENABLED"] = 1;
            values[valuesById[2] = "DISABLED"] = 2;
            return values;
        })();

        return FeatureFlag;
    })();

    Ydb.TableStats = (function() {

        /**
         * Namespace TableStats.
         * @memberof Ydb
         * @namespace
         */
        var TableStats = {};

        TableStats.OperationStats = (function() {

            /**
             * Properties of an OperationStats.
             * @memberof Ydb.TableStats
             * @interface IOperationStats
             * @property {number|Long|null} [rows] OperationStats rows
             * @property {number|Long|null} [bytes] OperationStats bytes
             */

            /**
             * Constructs a new OperationStats.
             * @memberof Ydb.TableStats
             * @classdesc Represents an OperationStats.
             * @implements IOperationStats
             * @constructor
             * @param {Ydb.TableStats.IOperationStats=} [properties] Properties to set
             */
            function OperationStats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OperationStats rows.
             * @member {number|Long} rows
             * @memberof Ydb.TableStats.OperationStats
             * @instance
             */
            OperationStats.prototype.rows = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * OperationStats bytes.
             * @member {number|Long} bytes
             * @memberof Ydb.TableStats.OperationStats
             * @instance
             */
            OperationStats.prototype.bytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new OperationStats instance using the specified properties.
             * @function create
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Ydb.TableStats.IOperationStats=} [properties] Properties to set
             * @returns {Ydb.TableStats.OperationStats} OperationStats instance
             */
            OperationStats.create = function create(properties) {
                return new OperationStats(properties);
            };

            /**
             * Encodes the specified OperationStats message. Does not implicitly {@link Ydb.TableStats.OperationStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Ydb.TableStats.IOperationStats} message OperationStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && message.hasOwnProperty("rows"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.rows);
                if (message.bytes != null && message.hasOwnProperty("bytes"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.bytes);
                return writer;
            };

            /**
             * Encodes the specified OperationStats message, length delimited. Does not implicitly {@link Ydb.TableStats.OperationStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Ydb.TableStats.IOperationStats} message OperationStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OperationStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.TableStats.OperationStats} OperationStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TableStats.OperationStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rows = reader.uint64();
                        break;
                    case 2:
                        message.bytes = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OperationStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.TableStats.OperationStats} OperationStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OperationStats message.
             * @function verify
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OperationStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rows != null && message.hasOwnProperty("rows"))
                    if (!$util.isInteger(message.rows) && !(message.rows && $util.isInteger(message.rows.low) && $util.isInteger(message.rows.high)))
                        return "rows: integer|Long expected";
                if (message.bytes != null && message.hasOwnProperty("bytes"))
                    if (!$util.isInteger(message.bytes) && !(message.bytes && $util.isInteger(message.bytes.low) && $util.isInteger(message.bytes.high)))
                        return "bytes: integer|Long expected";
                return null;
            };

            /**
             * Creates an OperationStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.TableStats.OperationStats} OperationStats
             */
            OperationStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.TableStats.OperationStats)
                    return object;
                var message = new $root.Ydb.TableStats.OperationStats();
                if (object.rows != null)
                    if ($util.Long)
                        (message.rows = $util.Long.fromValue(object.rows)).unsigned = true;
                    else if (typeof object.rows === "string")
                        message.rows = parseInt(object.rows, 10);
                    else if (typeof object.rows === "number")
                        message.rows = object.rows;
                    else if (typeof object.rows === "object")
                        message.rows = new $util.LongBits(object.rows.low >>> 0, object.rows.high >>> 0).toNumber(true);
                if (object.bytes != null)
                    if ($util.Long)
                        (message.bytes = $util.Long.fromValue(object.bytes)).unsigned = true;
                    else if (typeof object.bytes === "string")
                        message.bytes = parseInt(object.bytes, 10);
                    else if (typeof object.bytes === "number")
                        message.bytes = object.bytes;
                    else if (typeof object.bytes === "object")
                        message.bytes = new $util.LongBits(object.bytes.low >>> 0, object.bytes.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an OperationStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Ydb.TableStats.OperationStats} message OperationStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OperationStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.rows = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rows = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.bytes = options.longs === String ? "0" : 0;
                }
                if (message.rows != null && message.hasOwnProperty("rows"))
                    if (typeof message.rows === "number")
                        object.rows = options.longs === String ? String(message.rows) : message.rows;
                    else
                        object.rows = options.longs === String ? $util.Long.prototype.toString.call(message.rows) : options.longs === Number ? new $util.LongBits(message.rows.low >>> 0, message.rows.high >>> 0).toNumber(true) : message.rows;
                if (message.bytes != null && message.hasOwnProperty("bytes"))
                    if (typeof message.bytes === "number")
                        object.bytes = options.longs === String ? String(message.bytes) : message.bytes;
                    else
                        object.bytes = options.longs === String ? $util.Long.prototype.toString.call(message.bytes) : options.longs === Number ? new $util.LongBits(message.bytes.low >>> 0, message.bytes.high >>> 0).toNumber(true) : message.bytes;
                return object;
            };

            /**
             * Converts this OperationStats to JSON.
             * @function toJSON
             * @memberof Ydb.TableStats.OperationStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OperationStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OperationStats;
        })();

        TableStats.TableAccessStats = (function() {

            /**
             * Properties of a TableAccessStats.
             * @memberof Ydb.TableStats
             * @interface ITableAccessStats
             * @property {string|null} [name] TableAccessStats name
             * @property {Ydb.TableStats.IOperationStats|null} [reads] TableAccessStats reads
             * @property {Ydb.TableStats.IOperationStats|null} [updates] TableAccessStats updates
             * @property {Ydb.TableStats.IOperationStats|null} [deletes] TableAccessStats deletes
             */

            /**
             * Constructs a new TableAccessStats.
             * @memberof Ydb.TableStats
             * @classdesc Represents a TableAccessStats.
             * @implements ITableAccessStats
             * @constructor
             * @param {Ydb.TableStats.ITableAccessStats=} [properties] Properties to set
             */
            function TableAccessStats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableAccessStats name.
             * @member {string} name
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             */
            TableAccessStats.prototype.name = "";

            /**
             * TableAccessStats reads.
             * @member {Ydb.TableStats.IOperationStats|null|undefined} reads
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             */
            TableAccessStats.prototype.reads = null;

            /**
             * TableAccessStats updates.
             * @member {Ydb.TableStats.IOperationStats|null|undefined} updates
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             */
            TableAccessStats.prototype.updates = null;

            /**
             * TableAccessStats deletes.
             * @member {Ydb.TableStats.IOperationStats|null|undefined} deletes
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             */
            TableAccessStats.prototype.deletes = null;

            /**
             * Creates a new TableAccessStats instance using the specified properties.
             * @function create
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Ydb.TableStats.ITableAccessStats=} [properties] Properties to set
             * @returns {Ydb.TableStats.TableAccessStats} TableAccessStats instance
             */
            TableAccessStats.create = function create(properties) {
                return new TableAccessStats(properties);
            };

            /**
             * Encodes the specified TableAccessStats message. Does not implicitly {@link Ydb.TableStats.TableAccessStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Ydb.TableStats.ITableAccessStats} message TableAccessStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableAccessStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.reads != null && message.hasOwnProperty("reads"))
                    $root.Ydb.TableStats.OperationStats.encode(message.reads, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.updates != null && message.hasOwnProperty("updates"))
                    $root.Ydb.TableStats.OperationStats.encode(message.updates, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.deletes != null && message.hasOwnProperty("deletes"))
                    $root.Ydb.TableStats.OperationStats.encode(message.deletes, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableAccessStats message, length delimited. Does not implicitly {@link Ydb.TableStats.TableAccessStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Ydb.TableStats.ITableAccessStats} message TableAccessStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableAccessStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableAccessStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.TableStats.TableAccessStats} TableAccessStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableAccessStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TableStats.TableAccessStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.reads = $root.Ydb.TableStats.OperationStats.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.updates = $root.Ydb.TableStats.OperationStats.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.deletes = $root.Ydb.TableStats.OperationStats.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableAccessStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.TableStats.TableAccessStats} TableAccessStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableAccessStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableAccessStats message.
             * @function verify
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableAccessStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.reads != null && message.hasOwnProperty("reads")) {
                    var error = $root.Ydb.TableStats.OperationStats.verify(message.reads);
                    if (error)
                        return "reads." + error;
                }
                if (message.updates != null && message.hasOwnProperty("updates")) {
                    var error = $root.Ydb.TableStats.OperationStats.verify(message.updates);
                    if (error)
                        return "updates." + error;
                }
                if (message.deletes != null && message.hasOwnProperty("deletes")) {
                    var error = $root.Ydb.TableStats.OperationStats.verify(message.deletes);
                    if (error)
                        return "deletes." + error;
                }
                return null;
            };

            /**
             * Creates a TableAccessStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.TableStats.TableAccessStats} TableAccessStats
             */
            TableAccessStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.TableStats.TableAccessStats)
                    return object;
                var message = new $root.Ydb.TableStats.TableAccessStats();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.reads != null) {
                    if (typeof object.reads !== "object")
                        throw TypeError(".Ydb.TableStats.TableAccessStats.reads: object expected");
                    message.reads = $root.Ydb.TableStats.OperationStats.fromObject(object.reads);
                }
                if (object.updates != null) {
                    if (typeof object.updates !== "object")
                        throw TypeError(".Ydb.TableStats.TableAccessStats.updates: object expected");
                    message.updates = $root.Ydb.TableStats.OperationStats.fromObject(object.updates);
                }
                if (object.deletes != null) {
                    if (typeof object.deletes !== "object")
                        throw TypeError(".Ydb.TableStats.TableAccessStats.deletes: object expected");
                    message.deletes = $root.Ydb.TableStats.OperationStats.fromObject(object.deletes);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableAccessStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Ydb.TableStats.TableAccessStats} message TableAccessStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableAccessStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.reads = null;
                    object.updates = null;
                    object.deletes = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.reads != null && message.hasOwnProperty("reads"))
                    object.reads = $root.Ydb.TableStats.OperationStats.toObject(message.reads, options);
                if (message.updates != null && message.hasOwnProperty("updates"))
                    object.updates = $root.Ydb.TableStats.OperationStats.toObject(message.updates, options);
                if (message.deletes != null && message.hasOwnProperty("deletes"))
                    object.deletes = $root.Ydb.TableStats.OperationStats.toObject(message.deletes, options);
                return object;
            };

            /**
             * Converts this TableAccessStats to JSON.
             * @function toJSON
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableAccessStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableAccessStats;
        })();

        TableStats.QueryPhaseStats = (function() {

            /**
             * Properties of a QueryPhaseStats.
             * @memberof Ydb.TableStats
             * @interface IQueryPhaseStats
             * @property {number|Long|null} [durationUs] QueryPhaseStats durationUs
             * @property {Array.<Ydb.TableStats.ITableAccessStats>|null} [tableAccess] QueryPhaseStats tableAccess
             */

            /**
             * Constructs a new QueryPhaseStats.
             * @memberof Ydb.TableStats
             * @classdesc Represents a QueryPhaseStats.
             * @implements IQueryPhaseStats
             * @constructor
             * @param {Ydb.TableStats.IQueryPhaseStats=} [properties] Properties to set
             */
            function QueryPhaseStats(properties) {
                this.tableAccess = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryPhaseStats durationUs.
             * @member {number|Long} durationUs
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @instance
             */
            QueryPhaseStats.prototype.durationUs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * QueryPhaseStats tableAccess.
             * @member {Array.<Ydb.TableStats.ITableAccessStats>} tableAccess
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @instance
             */
            QueryPhaseStats.prototype.tableAccess = $util.emptyArray;

            /**
             * Creates a new QueryPhaseStats instance using the specified properties.
             * @function create
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Ydb.TableStats.IQueryPhaseStats=} [properties] Properties to set
             * @returns {Ydb.TableStats.QueryPhaseStats} QueryPhaseStats instance
             */
            QueryPhaseStats.create = function create(properties) {
                return new QueryPhaseStats(properties);
            };

            /**
             * Encodes the specified QueryPhaseStats message. Does not implicitly {@link Ydb.TableStats.QueryPhaseStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Ydb.TableStats.IQueryPhaseStats} message QueryPhaseStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryPhaseStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.durationUs != null && message.hasOwnProperty("durationUs"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.durationUs);
                if (message.tableAccess != null && message.tableAccess.length)
                    for (var i = 0; i < message.tableAccess.length; ++i)
                        $root.Ydb.TableStats.TableAccessStats.encode(message.tableAccess[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryPhaseStats message, length delimited. Does not implicitly {@link Ydb.TableStats.QueryPhaseStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Ydb.TableStats.IQueryPhaseStats} message QueryPhaseStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryPhaseStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryPhaseStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.TableStats.QueryPhaseStats} QueryPhaseStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryPhaseStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TableStats.QueryPhaseStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.durationUs = reader.uint64();
                        break;
                    case 2:
                        if (!(message.tableAccess && message.tableAccess.length))
                            message.tableAccess = [];
                        message.tableAccess.push($root.Ydb.TableStats.TableAccessStats.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryPhaseStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.TableStats.QueryPhaseStats} QueryPhaseStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryPhaseStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryPhaseStats message.
             * @function verify
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryPhaseStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.durationUs != null && message.hasOwnProperty("durationUs"))
                    if (!$util.isInteger(message.durationUs) && !(message.durationUs && $util.isInteger(message.durationUs.low) && $util.isInteger(message.durationUs.high)))
                        return "durationUs: integer|Long expected";
                if (message.tableAccess != null && message.hasOwnProperty("tableAccess")) {
                    if (!Array.isArray(message.tableAccess))
                        return "tableAccess: array expected";
                    for (var i = 0; i < message.tableAccess.length; ++i) {
                        var error = $root.Ydb.TableStats.TableAccessStats.verify(message.tableAccess[i]);
                        if (error)
                            return "tableAccess." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryPhaseStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.TableStats.QueryPhaseStats} QueryPhaseStats
             */
            QueryPhaseStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.TableStats.QueryPhaseStats)
                    return object;
                var message = new $root.Ydb.TableStats.QueryPhaseStats();
                if (object.durationUs != null)
                    if ($util.Long)
                        (message.durationUs = $util.Long.fromValue(object.durationUs)).unsigned = true;
                    else if (typeof object.durationUs === "string")
                        message.durationUs = parseInt(object.durationUs, 10);
                    else if (typeof object.durationUs === "number")
                        message.durationUs = object.durationUs;
                    else if (typeof object.durationUs === "object")
                        message.durationUs = new $util.LongBits(object.durationUs.low >>> 0, object.durationUs.high >>> 0).toNumber(true);
                if (object.tableAccess) {
                    if (!Array.isArray(object.tableAccess))
                        throw TypeError(".Ydb.TableStats.QueryPhaseStats.tableAccess: array expected");
                    message.tableAccess = [];
                    for (var i = 0; i < object.tableAccess.length; ++i) {
                        if (typeof object.tableAccess[i] !== "object")
                            throw TypeError(".Ydb.TableStats.QueryPhaseStats.tableAccess: object expected");
                        message.tableAccess[i] = $root.Ydb.TableStats.TableAccessStats.fromObject(object.tableAccess[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryPhaseStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Ydb.TableStats.QueryPhaseStats} message QueryPhaseStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryPhaseStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tableAccess = [];
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.durationUs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.durationUs = options.longs === String ? "0" : 0;
                if (message.durationUs != null && message.hasOwnProperty("durationUs"))
                    if (typeof message.durationUs === "number")
                        object.durationUs = options.longs === String ? String(message.durationUs) : message.durationUs;
                    else
                        object.durationUs = options.longs === String ? $util.Long.prototype.toString.call(message.durationUs) : options.longs === Number ? new $util.LongBits(message.durationUs.low >>> 0, message.durationUs.high >>> 0).toNumber(true) : message.durationUs;
                if (message.tableAccess && message.tableAccess.length) {
                    object.tableAccess = [];
                    for (var j = 0; j < message.tableAccess.length; ++j)
                        object.tableAccess[j] = $root.Ydb.TableStats.TableAccessStats.toObject(message.tableAccess[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryPhaseStats to JSON.
             * @function toJSON
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryPhaseStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryPhaseStats;
        })();

        TableStats.QueryStats = (function() {

            /**
             * Properties of a QueryStats.
             * @memberof Ydb.TableStats
             * @interface IQueryStats
             * @property {Array.<Ydb.TableStats.IQueryPhaseStats>|null} [queryPhases] QueryStats queryPhases
             */

            /**
             * Constructs a new QueryStats.
             * @memberof Ydb.TableStats
             * @classdesc Represents a QueryStats.
             * @implements IQueryStats
             * @constructor
             * @param {Ydb.TableStats.IQueryStats=} [properties] Properties to set
             */
            function QueryStats(properties) {
                this.queryPhases = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryStats queryPhases.
             * @member {Array.<Ydb.TableStats.IQueryPhaseStats>} queryPhases
             * @memberof Ydb.TableStats.QueryStats
             * @instance
             */
            QueryStats.prototype.queryPhases = $util.emptyArray;

            /**
             * Creates a new QueryStats instance using the specified properties.
             * @function create
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Ydb.TableStats.IQueryStats=} [properties] Properties to set
             * @returns {Ydb.TableStats.QueryStats} QueryStats instance
             */
            QueryStats.create = function create(properties) {
                return new QueryStats(properties);
            };

            /**
             * Encodes the specified QueryStats message. Does not implicitly {@link Ydb.TableStats.QueryStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Ydb.TableStats.IQueryStats} message QueryStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queryPhases != null && message.queryPhases.length)
                    for (var i = 0; i < message.queryPhases.length; ++i)
                        $root.Ydb.TableStats.QueryPhaseStats.encode(message.queryPhases[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryStats message, length delimited. Does not implicitly {@link Ydb.TableStats.QueryStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Ydb.TableStats.IQueryStats} message QueryStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.TableStats.QueryStats} QueryStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TableStats.QueryStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.queryPhases && message.queryPhases.length))
                            message.queryPhases = [];
                        message.queryPhases.push($root.Ydb.TableStats.QueryPhaseStats.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.TableStats.QueryStats} QueryStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryStats message.
             * @function verify
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queryPhases != null && message.hasOwnProperty("queryPhases")) {
                    if (!Array.isArray(message.queryPhases))
                        return "queryPhases: array expected";
                    for (var i = 0; i < message.queryPhases.length; ++i) {
                        var error = $root.Ydb.TableStats.QueryPhaseStats.verify(message.queryPhases[i]);
                        if (error)
                            return "queryPhases." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.TableStats.QueryStats} QueryStats
             */
            QueryStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.TableStats.QueryStats)
                    return object;
                var message = new $root.Ydb.TableStats.QueryStats();
                if (object.queryPhases) {
                    if (!Array.isArray(object.queryPhases))
                        throw TypeError(".Ydb.TableStats.QueryStats.queryPhases: array expected");
                    message.queryPhases = [];
                    for (var i = 0; i < object.queryPhases.length; ++i) {
                        if (typeof object.queryPhases[i] !== "object")
                            throw TypeError(".Ydb.TableStats.QueryStats.queryPhases: object expected");
                        message.queryPhases[i] = $root.Ydb.TableStats.QueryPhaseStats.fromObject(object.queryPhases[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Ydb.TableStats.QueryStats} message QueryStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.queryPhases = [];
                if (message.queryPhases && message.queryPhases.length) {
                    object.queryPhases = [];
                    for (var j = 0; j < message.queryPhases.length; ++j)
                        object.queryPhases[j] = $root.Ydb.TableStats.QueryPhaseStats.toObject(message.queryPhases[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryStats to JSON.
             * @function toJSON
             * @memberof Ydb.TableStats.QueryStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryStats;
        })();

        return TableStats;
    })();

    return Ydb;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {number|Long|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */

            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;

            /**
             * Creates a new Duration instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             * @returns {google.protobuf.Duration} Duration instance
             */
            Duration.create = function create(properties) {
                return new Duration(properties);
            };

            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Duration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Duration message.
             * @function verify
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Duration)
                    return object;
                var message = new $root.google.protobuf.Duration();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Duration to JSON.
             * @function toJSON
             * @memberof google.protobuf.Duration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Duration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Duration;
        })();

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (var i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (var i = 0; i < message.file.length; ++i) {
                        var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (var i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (var j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && message.hasOwnProperty("package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (var i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (var i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (var i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (var i = 0; i < message.messageType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i) {
                        var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (var i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (var i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (var i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (var i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (var j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (var j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (var j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (var j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (var i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (var i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (var i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (var i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (var i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (var i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (var i = 0; i < message.field.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (var i = 0; i < message.nestedType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (var i = 0; i < message.extensionRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (var i = 0; i < message.oneofDecl.length; ++i) {
                        var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (var i = 0; i < message.reservedRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (var i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                var message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (var i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (var i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (var i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (var i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (var i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (var i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (var j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (var j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (var j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (var j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (var j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (var j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {string}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {string}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i) {
                        var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (var i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (var i = 0; i < message.method.length; ++i) {
                        var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (var i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (var j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                var message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = false;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {string}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                var message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             * @property {boolean|null} [".Ydb.required"] FieldOptions .Ydb.required
             * @property {Ydb.ILimit|null} [".Ydb.size"] FieldOptions .Ydb.size
             * @property {Ydb.ILimit|null} [".Ydb.length"] FieldOptions .Ydb.length
             * @property {Ydb.IMapKey|null} [".Ydb.mapKey"] FieldOptions .Ydb.mapKey
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * FieldOptions .Ydb.required.
             * @member {boolean} .Ydb.required
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".Ydb.required"] = false;

            /**
             * FieldOptions .Ydb.size.
             * @member {Ydb.ILimit|null|undefined} .Ydb.size
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".Ydb.size"] = null;

            /**
             * FieldOptions .Ydb.length.
             * @member {Ydb.ILimit|null|undefined} .Ydb.length
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".Ydb.length"] = null;

            /**
             * FieldOptions .Ydb.mapKey.
             * @member {Ydb.IMapKey|null|undefined} .Ydb.mapKey
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".Ydb.mapKey"] = null;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && message.hasOwnProperty("packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && message.hasOwnProperty("weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".Ydb.required"] != null && message.hasOwnProperty(".Ydb.required"))
                    writer.uint32(/* id 87650, wireType 0 =*/701200).bool(message[".Ydb.required"]);
                if (message[".Ydb.size"] != null && message.hasOwnProperty(".Ydb.size"))
                    $root.Ydb.Limit.encode(message[".Ydb.size"], writer.uint32(/* id 87651, wireType 2 =*/701210).fork()).ldelim();
                if (message[".Ydb.length"] != null && message.hasOwnProperty(".Ydb.length"))
                    $root.Ydb.Limit.encode(message[".Ydb.length"], writer.uint32(/* id 87652, wireType 2 =*/701218).fork()).ldelim();
                if (message[".Ydb.mapKey"] != null && message.hasOwnProperty(".Ydb.mapKey"))
                    $root.Ydb.MapKey.encode(message[".Ydb.mapKey"], writer.uint32(/* id 87653, wireType 2 =*/701226).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 87650:
                        message[".Ydb.required"] = reader.bool();
                        break;
                    case 87651:
                        message[".Ydb.size"] = $root.Ydb.Limit.decode(reader, reader.uint32());
                        break;
                    case 87652:
                        message[".Ydb.length"] = $root.Ydb.Limit.decode(reader, reader.uint32());
                        break;
                    case 87653:
                        message[".Ydb.mapKey"] = $root.Ydb.MapKey.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".Ydb.required"] != null && message.hasOwnProperty(".Ydb.required"))
                    if (typeof message[".Ydb.required"] !== "boolean")
                        return ".Ydb.required: boolean expected";
                if (message[".Ydb.size"] != null && message.hasOwnProperty(".Ydb.size")) {
                    var error = $root.Ydb.Limit.verify(message[".Ydb.size"]);
                    if (error)
                        return ".Ydb.size." + error;
                }
                if (message[".Ydb.length"] != null && message.hasOwnProperty(".Ydb.length")) {
                    var error = $root.Ydb.Limit.verify(message[".Ydb.length"]);
                    if (error)
                        return ".Ydb.length." + error;
                }
                if (message[".Ydb.mapKey"] != null && message.hasOwnProperty(".Ydb.mapKey")) {
                    var error = $root.Ydb.MapKey.verify(message[".Ydb.mapKey"]);
                    if (error)
                        return ".Ydb.mapKey." + error;
                }
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                var message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".Ydb.required"] != null)
                    message[".Ydb.required"] = Boolean(object[".Ydb.required"]);
                if (object[".Ydb.size"] != null) {
                    if (typeof object[".Ydb.size"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..Ydb.size: object expected");
                    message[".Ydb.size"] = $root.Ydb.Limit.fromObject(object[".Ydb.size"]);
                }
                if (object[".Ydb.length"] != null) {
                    if (typeof object[".Ydb.length"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..Ydb.length: object expected");
                    message[".Ydb.length"] = $root.Ydb.Limit.fromObject(object[".Ydb.length"]);
                }
                if (object[".Ydb.mapKey"] != null) {
                    if (typeof object[".Ydb.mapKey"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..Ydb.mapKey: object expected");
                    message[".Ydb.mapKey"] = $root.Ydb.MapKey.fromObject(object[".Ydb.mapKey"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object[".Ydb.required"] = false;
                    object[".Ydb.size"] = null;
                    object[".Ydb.length"] = null;
                    object[".Ydb.mapKey"] = null;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".Ydb.required"] != null && message.hasOwnProperty(".Ydb.required"))
                    object[".Ydb.required"] = message[".Ydb.required"];
                if (message[".Ydb.size"] != null && message.hasOwnProperty(".Ydb.size"))
                    object[".Ydb.size"] = $root.Ydb.Limit.toObject(message[".Ydb.size"], options);
                if (message[".Ydb.length"] != null && message.hasOwnProperty(".Ydb.length"))
                    object[".Ydb.length"] = $root.Ydb.Limit.toObject(message[".Ydb.length"], options);
                if (message[".Ydb.mapKey"] != null && message.hasOwnProperty(".Ydb.mapKey"))
                    object[".Ydb.mapKey"] = $root.Ydb.MapKey.toObject(message[".Ydb.mapKey"], options);
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {string}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {string}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                var message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                var message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                var message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                var message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MethodOptions .google.api.http.
             * @member {google.api.IHttpRule|null|undefined} .google.api.http
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.api.http"] = null;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 72295728:
                        message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                    var error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                    if (error)
                        return ".google.api.http." + error;
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                var message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".google.api.http"] != null) {
                    if (typeof object[".google.api.http"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
                    message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object[".google.api.http"] = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (var i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (var i = 0; i < message.name.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                var message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (var i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (var j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (var i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (var i = 0; i < message.location.length; ++i) {
                        var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                var message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (var i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (var j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (var i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (var i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (var i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (var j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (var j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (var i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (var i = 0; i < message.annotation.length; ++i) {
                        var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                var message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (var i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (var j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        protobuf.Struct = (function() {

            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */

            /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */
            function Struct(properties) {
                this.fields = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */
            Struct.prototype.fields = $util.emptyObject;

            /**
             * Creates a new Struct instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             * @returns {google.protobuf.Struct} Struct instance
             */
            Struct.create = function create(properties) {
                return new Struct(properties);
            };

            /**
             * Encodes the specified Struct message. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fields != null && message.hasOwnProperty("fields"))
                    for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Struct message, length delimited. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Struct message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.fields === $util.emptyObject)
                            message.fields = {};
                        key = reader.string();
                        reader.pos++;
                        message.fields[key] = $root.google.protobuf.Value.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Struct message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields))
                        return "fields: object expected";
                    var key = Object.keys(message.fields);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Struct message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Struct} Struct
             */
            Struct.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Struct)
                    return object;
                var message = new $root.google.protobuf.Struct();
                if (object.fields) {
                    if (typeof object.fields !== "object")
                        throw TypeError(".google.protobuf.Struct.fields: object expected");
                    message.fields = {};
                    for (var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {
                        if (typeof object.fields[keys[i]] !== "object")
                            throw TypeError(".google.protobuf.Struct.fields: object expected");
                        message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Struct message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.Struct} message Struct
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Struct.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.fields = {};
                var keys2;
                if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                    object.fields = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Struct to JSON.
             * @function toJSON
             * @memberof google.protobuf.Struct
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Struct.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Struct;
        })();

        protobuf.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */

            /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.nullValue = 0;

            /**
             * Value numberValue.
             * @member {number} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.numberValue = 0;

            /**
             * Value stringValue.
             * @member {string} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.stringValue = "";

            /**
             * Value boolValue.
             * @member {boolean} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.boolValue = false;

            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.structValue = null;

            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.listValue = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue=} [properties] Properties to set
             * @returns {google.protobuf.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nullValue != null && message.hasOwnProperty("nullValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nullValue);
                if (message.numberValue != null && message.hasOwnProperty("numberValue"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.numberValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                if (message.boolValue != null && message.hasOwnProperty("boolValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolValue);
                if (message.structValue != null && message.hasOwnProperty("structValue"))
                    $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.listValue != null && message.hasOwnProperty("listValue"))
                    $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nullValue = reader.int32();
                        break;
                    case 2:
                        message.numberValue = reader.double();
                        break;
                    case 3:
                        message.stringValue = reader.string();
                        break;
                    case 4:
                        message.boolValue = reader.bool();
                        break;
                    case 5:
                        message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch (message.nullValue) {
                    default:
                        return "nullValue: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number")
                        return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error)
                            return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error)
                            return "listValue." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Value)
                    return object;
                var message = new $root.google.protobuf.Value();
                switch (object.nullValue) {
                case "NULL_VALUE":
                case 0:
                    message.nullValue = 0;
                    break;
                }
                if (object.numberValue != null)
                    message.numberValue = Number(object.numberValue);
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.boolValue != null)
                    message.boolValue = Boolean(object.boolValue);
                if (object.structValue != null) {
                    if (typeof object.structValue !== "object")
                        throw TypeError(".google.protobuf.Value.structValue: object expected");
                    message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
                }
                if (object.listValue != null) {
                    if (typeof object.listValue !== "object")
                        throw TypeError(".google.protobuf.Value.listValue: object expected");
                    message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                    if (options.oneofs)
                        object.kind = "nullValue";
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
                    if (options.oneofs)
                        object.kind = "numberValue";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs)
                        object.kind = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs)
                        object.kind = "boolValue";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                    if (options.oneofs)
                        object.kind = "structValue";
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);
                    if (options.oneofs)
                        object.kind = "listValue";
                }
                return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Value;
        })();

        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {string}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */
        protobuf.NullValue = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        })();

        protobuf.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */

            /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */
            ListValue.prototype.values = $util.emptyArray;

            /**
             * Creates a new ListValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             * @returns {google.protobuf.ListValue} ListValue instance
             */
            ListValue.create = function create(properties) {
                return new ListValue(properties);
            };

            /**
             * Encodes the specified ListValue message. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        $root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListValue message, length delimited. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ListValue} ListValue
             */
            ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ListValue)
                    return object;
                var message = new $root.google.protobuf.ListValue();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".google.protobuf.ListValue.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".google.protobuf.ListValue.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListValue;
        })();

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Empty;
        })();

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Timestamp;
        })();

        return protobuf;
    })();

    google.api = (function() {

        /**
         * Namespace api.
         * @memberof google
         * @namespace
         */
        var api = {};

        api.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof google.api
             * @interface IHttp
             * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
             */

            /**
             * Constructs a new Http.
             * @memberof google.api
             * @classdesc Represents a Http.
             * @implements IHttp
             * @constructor
             * @param {google.api.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                this.rules = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http rules.
             * @member {Array.<google.api.IHttpRule>} rules
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.rules = $util.emptyArray;

            /**
             * Creates a new Http instance using the specified properties.
             * @function create
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp=} [properties] Properties to set
             * @returns {google.api.Http} Http instance
             */
            Http.create = function create(properties) {
                return new Http(properties);
            };

            /**
             * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encode
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rules != null && message.rules.length)
                    for (var i = 0; i < message.rules.length; ++i)
                        $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Http message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Http();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.rules && message.rules.length))
                            message.rules = [];
                        message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Http message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rules != null && message.hasOwnProperty("rules")) {
                    if (!Array.isArray(message.rules))
                        return "rules: array expected";
                    for (var i = 0; i < message.rules.length; ++i) {
                        var error = $root.google.api.HttpRule.verify(message.rules[i]);
                        if (error)
                            return "rules." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Http message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.Http} Http
             */
            Http.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.Http)
                    return object;
                var message = new $root.google.api.Http();
                if (object.rules) {
                    if (!Array.isArray(object.rules))
                        throw TypeError(".google.api.Http.rules: array expected");
                    message.rules = [];
                    for (var i = 0; i < object.rules.length; ++i) {
                        if (typeof object.rules[i] !== "object")
                            throw TypeError(".google.api.Http.rules: object expected");
                        message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Http message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.Http
             * @static
             * @param {google.api.Http} message Http
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Http.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rules = [];
                if (message.rules && message.rules.length) {
                    object.rules = [];
                    for (var j = 0; j < message.rules.length; ++j)
                        object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
                }
                return object;
            };

            /**
             * Converts this Http to JSON.
             * @function toJSON
             * @memberof google.api.Http
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Http.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Http;
        })();

        api.HttpRule = (function() {

            /**
             * Properties of a HttpRule.
             * @memberof google.api
             * @interface IHttpRule
             * @property {string|null} [get] HttpRule get
             * @property {string|null} [put] HttpRule put
             * @property {string|null} [post] HttpRule post
             * @property {string|null} ["delete"] HttpRule delete
             * @property {string|null} [patch] HttpRule patch
             * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
             * @property {string|null} [selector] HttpRule selector
             * @property {string|null} [body] HttpRule body
             * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
             */

            /**
             * Constructs a new HttpRule.
             * @memberof google.api
             * @classdesc Represents a HttpRule.
             * @implements IHttpRule
             * @constructor
             * @param {google.api.IHttpRule=} [properties] Properties to set
             */
            function HttpRule(properties) {
                this.additionalBindings = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HttpRule get.
             * @member {string} get
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.get = "";

            /**
             * HttpRule put.
             * @member {string} put
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.put = "";

            /**
             * HttpRule post.
             * @member {string} post
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.post = "";

            /**
             * HttpRule delete.
             * @member {string} delete
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype["delete"] = "";

            /**
             * HttpRule patch.
             * @member {string} patch
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.patch = "";

            /**
             * HttpRule custom.
             * @member {google.api.ICustomHttpPattern|null|undefined} custom
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.custom = null;

            /**
             * HttpRule selector.
             * @member {string} selector
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.selector = "";

            /**
             * HttpRule body.
             * @member {string} body
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.body = "";

            /**
             * HttpRule additionalBindings.
             * @member {Array.<google.api.IHttpRule>} additionalBindings
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.additionalBindings = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * HttpRule pattern.
             * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
             * @memberof google.api.HttpRule
             * @instance
             */
            Object.defineProperty(HttpRule.prototype, "pattern", {
                get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new HttpRule instance using the specified properties.
             * @function create
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule=} [properties] Properties to set
             * @returns {google.api.HttpRule} HttpRule instance
             */
            HttpRule.create = function create(properties) {
                return new HttpRule(properties);
            };

            /**
             * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encode
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selector != null && message.hasOwnProperty("selector"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
                if (message.get != null && message.hasOwnProperty("get"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
                if (message.put != null && message.hasOwnProperty("put"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
                if (message.post != null && message.hasOwnProperty("post"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
                if (message["delete"] != null && message.hasOwnProperty("delete"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
                if (message.patch != null && message.hasOwnProperty("patch"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
                if (message.body != null && message.hasOwnProperty("body"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
                if (message.custom != null && message.hasOwnProperty("custom"))
                    $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.additionalBindings != null && message.additionalBindings.length)
                    for (var i = 0; i < message.additionalBindings.length; ++i)
                        $root.google.api.HttpRule.encode(message.additionalBindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.get = reader.string();
                        break;
                    case 3:
                        message.put = reader.string();
                        break;
                    case 4:
                        message.post = reader.string();
                        break;
                    case 5:
                        message["delete"] = reader.string();
                        break;
                    case 6:
                        message.patch = reader.string();
                        break;
                    case 8:
                        message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                        break;
                    case 1:
                        message.selector = reader.string();
                        break;
                    case 7:
                        message.body = reader.string();
                        break;
                    case 11:
                        if (!(message.additionalBindings && message.additionalBindings.length))
                            message.additionalBindings = [];
                        message.additionalBindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HttpRule message.
             * @function verify
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HttpRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.get != null && message.hasOwnProperty("get")) {
                    properties.pattern = 1;
                    if (!$util.isString(message.get))
                        return "get: string expected";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.put))
                        return "put: string expected";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.post))
                        return "post: string expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message["delete"]))
                        return "delete: string expected";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.patch))
                        return "patch: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    {
                        var error = $root.google.api.CustomHttpPattern.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    if (!$util.isString(message.selector))
                        return "selector: string expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
                    if (!Array.isArray(message.additionalBindings))
                        return "additionalBindings: array expected";
                    for (var i = 0; i < message.additionalBindings.length; ++i) {
                        var error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
                        if (error)
                            return "additionalBindings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.HttpRule} HttpRule
             */
            HttpRule.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.HttpRule)
                    return object;
                var message = new $root.google.api.HttpRule();
                if (object.get != null)
                    message.get = String(object.get);
                if (object.put != null)
                    message.put = String(object.put);
                if (object.post != null)
                    message.post = String(object.post);
                if (object["delete"] != null)
                    message["delete"] = String(object["delete"]);
                if (object.patch != null)
                    message.patch = String(object.patch);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".google.api.HttpRule.custom: object expected");
                    message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
                }
                if (object.selector != null)
                    message.selector = String(object.selector);
                if (object.body != null)
                    message.body = String(object.body);
                if (object.additionalBindings) {
                    if (!Array.isArray(object.additionalBindings))
                        throw TypeError(".google.api.HttpRule.additionalBindings: array expected");
                    message.additionalBindings = [];
                    for (var i = 0; i < object.additionalBindings.length; ++i) {
                        if (typeof object.additionalBindings[i] !== "object")
                            throw TypeError(".google.api.HttpRule.additionalBindings: object expected");
                        message.additionalBindings[i] = $root.google.api.HttpRule.fromObject(object.additionalBindings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.HttpRule} message HttpRule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpRule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.additionalBindings = [];
                if (options.defaults) {
                    object.selector = "";
                    object.body = "";
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    object.selector = message.selector;
                if (message.get != null && message.hasOwnProperty("get")) {
                    object.get = message.get;
                    if (options.oneofs)
                        object.pattern = "get";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    object.put = message.put;
                    if (options.oneofs)
                        object.pattern = "put";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    object.post = message.post;
                    if (options.oneofs)
                        object.pattern = "post";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    object["delete"] = message["delete"];
                    if (options.oneofs)
                        object.pattern = "delete";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    object.patch = message.patch;
                    if (options.oneofs)
                        object.pattern = "patch";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
                    if (options.oneofs)
                        object.pattern = "custom";
                }
                if (message.additionalBindings && message.additionalBindings.length) {
                    object.additionalBindings = [];
                    for (var j = 0; j < message.additionalBindings.length; ++j)
                        object.additionalBindings[j] = $root.google.api.HttpRule.toObject(message.additionalBindings[j], options);
                }
                return object;
            };

            /**
             * Converts this HttpRule to JSON.
             * @function toJSON
             * @memberof google.api.HttpRule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HttpRule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HttpRule;
        })();

        api.CustomHttpPattern = (function() {

            /**
             * Properties of a CustomHttpPattern.
             * @memberof google.api
             * @interface ICustomHttpPattern
             * @property {string|null} [kind] CustomHttpPattern kind
             * @property {string|null} [path] CustomHttpPattern path
             */

            /**
             * Constructs a new CustomHttpPattern.
             * @memberof google.api
             * @classdesc Represents a CustomHttpPattern.
             * @implements ICustomHttpPattern
             * @constructor
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             */
            function CustomHttpPattern(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomHttpPattern kind.
             * @member {string} kind
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.kind = "";

            /**
             * CustomHttpPattern path.
             * @member {string} path
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.path = "";

            /**
             * Creates a new CustomHttpPattern instance using the specified properties.
             * @function create
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern instance
             */
            CustomHttpPattern.create = function create(properties) {
                return new CustomHttpPattern(properties);
            };

            /**
             * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomHttpPattern message.
             * @function verify
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomHttpPattern.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             */
            CustomHttpPattern.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CustomHttpPattern)
                    return object;
                var message = new $root.google.api.CustomHttpPattern();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.CustomHttpPattern} message CustomHttpPattern
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomHttpPattern.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.path = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this CustomHttpPattern to JSON.
             * @function toJSON
             * @memberof google.api.CustomHttpPattern
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomHttpPattern.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CustomHttpPattern;
        })();

        return api;
    })();

    return google;
})();

$root.yandex = (function() {

    /**
     * Namespace yandex.
     * @exports yandex
     * @namespace
     */
    var yandex = {};

    yandex.cloud = (function() {

        /**
         * Namespace cloud.
         * @memberof yandex
         * @namespace
         */
        var cloud = {};

        cloud.iam = (function() {

            /**
             * Namespace iam.
             * @memberof yandex.cloud
             * @namespace
             */
            var iam = {};

            iam.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof yandex.cloud.iam
                 * @namespace
                 */
                var v1 = {};

                v1.IamTokenService = (function() {

                    /**
                     * Constructs a new IamTokenService service.
                     * @memberof yandex.cloud.iam.v1
                     * @classdesc Represents an IamTokenService
                     * @extends $protobuf.rpc.Service
                     * @constructor
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     */
                    function IamTokenService(rpcImpl, requestDelimited, responseDelimited) {
                        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                    }

                    (IamTokenService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = IamTokenService;

                    /**
                     * Creates new IamTokenService service using the specified rpc implementation.
                     * @function create
                     * @memberof yandex.cloud.iam.v1.IamTokenService
                     * @static
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     * @returns {IamTokenService} RPC service. Useful where requests and/or responses are streamed.
                     */
                    IamTokenService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                        return new this(rpcImpl, requestDelimited, responseDelimited);
                    };

                    /**
                     * Callback as used by {@link yandex.cloud.iam.v1.IamTokenService#create}.
                     * @memberof yandex.cloud.iam.v1.IamTokenService
                     * @typedef CreateCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {yandex.cloud.iam.v1.CreateIamTokenResponse} [response] CreateIamTokenResponse
                     */

                    /**
                     * Calls Create.
                     * @function create
                     * @memberof yandex.cloud.iam.v1.IamTokenService
                     * @instance
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenRequest} request CreateIamTokenRequest message or plain object
                     * @param {yandex.cloud.iam.v1.IamTokenService.CreateCallback} callback Node-style callback called with the error, if any, and CreateIamTokenResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(IamTokenService.prototype.create = function create(request, callback) {
                        return this.rpcCall(create, $root.yandex.cloud.iam.v1.CreateIamTokenRequest, $root.yandex.cloud.iam.v1.CreateIamTokenResponse, request, callback);
                    }, "name", { value: "Create" });

                    /**
                     * Calls Create.
                     * @function create
                     * @memberof yandex.cloud.iam.v1.IamTokenService
                     * @instance
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenRequest} request CreateIamTokenRequest message or plain object
                     * @returns {Promise<yandex.cloud.iam.v1.CreateIamTokenResponse>} Promise
                     * @variation 2
                     */

                    return IamTokenService;
                })();

                v1.CreateIamTokenRequest = (function() {

                    /**
                     * Properties of a CreateIamTokenRequest.
                     * @memberof yandex.cloud.iam.v1
                     * @interface ICreateIamTokenRequest
                     * @property {string|null} [yandexPassportOauthToken] CreateIamTokenRequest yandexPassportOauthToken
                     * @property {string|null} [jwt] CreateIamTokenRequest jwt
                     */

                    /**
                     * Constructs a new CreateIamTokenRequest.
                     * @memberof yandex.cloud.iam.v1
                     * @classdesc Represents a CreateIamTokenRequest.
                     * @implements ICreateIamTokenRequest
                     * @constructor
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenRequest=} [properties] Properties to set
                     */
                    function CreateIamTokenRequest(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateIamTokenRequest yandexPassportOauthToken.
                     * @member {string} yandexPassportOauthToken
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @instance
                     */
                    CreateIamTokenRequest.prototype.yandexPassportOauthToken = "";

                    /**
                     * CreateIamTokenRequest jwt.
                     * @member {string} jwt
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @instance
                     */
                    CreateIamTokenRequest.prototype.jwt = "";

                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;

                    /**
                     * CreateIamTokenRequest identity.
                     * @member {"yandexPassportOauthToken"|"jwt"|undefined} identity
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @instance
                     */
                    Object.defineProperty(CreateIamTokenRequest.prototype, "identity", {
                        get: $util.oneOfGetter($oneOfFields = ["yandexPassportOauthToken", "jwt"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new CreateIamTokenRequest instance using the specified properties.
                     * @function create
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @static
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenRequest=} [properties] Properties to set
                     * @returns {yandex.cloud.iam.v1.CreateIamTokenRequest} CreateIamTokenRequest instance
                     */
                    CreateIamTokenRequest.create = function create(properties) {
                        return new CreateIamTokenRequest(properties);
                    };

                    /**
                     * Encodes the specified CreateIamTokenRequest message. Does not implicitly {@link yandex.cloud.iam.v1.CreateIamTokenRequest.verify|verify} messages.
                     * @function encode
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @static
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenRequest} message CreateIamTokenRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateIamTokenRequest.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.yandexPassportOauthToken != null && message.hasOwnProperty("yandexPassportOauthToken"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.yandexPassportOauthToken);
                        if (message.jwt != null && message.hasOwnProperty("jwt"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.jwt);
                        return writer;
                    };

                    /**
                     * Encodes the specified CreateIamTokenRequest message, length delimited. Does not implicitly {@link yandex.cloud.iam.v1.CreateIamTokenRequest.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @static
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenRequest} message CreateIamTokenRequest message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateIamTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CreateIamTokenRequest message from the specified reader or buffer.
                     * @function decode
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {yandex.cloud.iam.v1.CreateIamTokenRequest} CreateIamTokenRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateIamTokenRequest.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.cloud.iam.v1.CreateIamTokenRequest();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.yandexPassportOauthToken = reader.string();
                                break;
                            case 2:
                                message.jwt = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CreateIamTokenRequest message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {yandex.cloud.iam.v1.CreateIamTokenRequest} CreateIamTokenRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateIamTokenRequest.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CreateIamTokenRequest message.
                     * @function verify
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateIamTokenRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.yandexPassportOauthToken != null && message.hasOwnProperty("yandexPassportOauthToken")) {
                            properties.identity = 1;
                            if (!$util.isString(message.yandexPassportOauthToken))
                                return "yandexPassportOauthToken: string expected";
                        }
                        if (message.jwt != null && message.hasOwnProperty("jwt")) {
                            if (properties.identity === 1)
                                return "identity: multiple values";
                            properties.identity = 1;
                            if (!$util.isString(message.jwt))
                                return "jwt: string expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a CreateIamTokenRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {yandex.cloud.iam.v1.CreateIamTokenRequest} CreateIamTokenRequest
                     */
                    CreateIamTokenRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.yandex.cloud.iam.v1.CreateIamTokenRequest)
                            return object;
                        var message = new $root.yandex.cloud.iam.v1.CreateIamTokenRequest();
                        if (object.yandexPassportOauthToken != null)
                            message.yandexPassportOauthToken = String(object.yandexPassportOauthToken);
                        if (object.jwt != null)
                            message.jwt = String(object.jwt);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateIamTokenRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @static
                     * @param {yandex.cloud.iam.v1.CreateIamTokenRequest} message CreateIamTokenRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateIamTokenRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.yandexPassportOauthToken != null && message.hasOwnProperty("yandexPassportOauthToken")) {
                            object.yandexPassportOauthToken = message.yandexPassportOauthToken;
                            if (options.oneofs)
                                object.identity = "yandexPassportOauthToken";
                        }
                        if (message.jwt != null && message.hasOwnProperty("jwt")) {
                            object.jwt = message.jwt;
                            if (options.oneofs)
                                object.identity = "jwt";
                        }
                        return object;
                    };

                    /**
                     * Converts this CreateIamTokenRequest to JSON.
                     * @function toJSON
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateIamTokenRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateIamTokenRequest;
                })();

                v1.CreateIamTokenResponse = (function() {

                    /**
                     * Properties of a CreateIamTokenResponse.
                     * @memberof yandex.cloud.iam.v1
                     * @interface ICreateIamTokenResponse
                     * @property {string|null} [iamToken] CreateIamTokenResponse iamToken
                     * @property {google.protobuf.ITimestamp|null} [expiresAt] CreateIamTokenResponse expiresAt
                     */

                    /**
                     * Constructs a new CreateIamTokenResponse.
                     * @memberof yandex.cloud.iam.v1
                     * @classdesc Represents a CreateIamTokenResponse.
                     * @implements ICreateIamTokenResponse
                     * @constructor
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenResponse=} [properties] Properties to set
                     */
                    function CreateIamTokenResponse(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateIamTokenResponse iamToken.
                     * @member {string} iamToken
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @instance
                     */
                    CreateIamTokenResponse.prototype.iamToken = "";

                    /**
                     * CreateIamTokenResponse expiresAt.
                     * @member {google.protobuf.ITimestamp|null|undefined} expiresAt
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @instance
                     */
                    CreateIamTokenResponse.prototype.expiresAt = null;

                    /**
                     * Creates a new CreateIamTokenResponse instance using the specified properties.
                     * @function create
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @static
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenResponse=} [properties] Properties to set
                     * @returns {yandex.cloud.iam.v1.CreateIamTokenResponse} CreateIamTokenResponse instance
                     */
                    CreateIamTokenResponse.create = function create(properties) {
                        return new CreateIamTokenResponse(properties);
                    };

                    /**
                     * Encodes the specified CreateIamTokenResponse message. Does not implicitly {@link yandex.cloud.iam.v1.CreateIamTokenResponse.verify|verify} messages.
                     * @function encode
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @static
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenResponse} message CreateIamTokenResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateIamTokenResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.iamToken != null && message.hasOwnProperty("iamToken"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.iamToken);
                        if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                            $root.google.protobuf.Timestamp.encode(message.expiresAt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified CreateIamTokenResponse message, length delimited. Does not implicitly {@link yandex.cloud.iam.v1.CreateIamTokenResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @static
                     * @param {yandex.cloud.iam.v1.ICreateIamTokenResponse} message CreateIamTokenResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateIamTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CreateIamTokenResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {yandex.cloud.iam.v1.CreateIamTokenResponse} CreateIamTokenResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateIamTokenResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.cloud.iam.v1.CreateIamTokenResponse();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.iamToken = reader.string();
                                break;
                            case 2:
                                message.expiresAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CreateIamTokenResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {yandex.cloud.iam.v1.CreateIamTokenResponse} CreateIamTokenResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateIamTokenResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CreateIamTokenResponse message.
                     * @function verify
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateIamTokenResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.iamToken != null && message.hasOwnProperty("iamToken"))
                            if (!$util.isString(message.iamToken))
                                return "iamToken: string expected";
                        if (message.expiresAt != null && message.hasOwnProperty("expiresAt")) {
                            var error = $root.google.protobuf.Timestamp.verify(message.expiresAt);
                            if (error)
                                return "expiresAt." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a CreateIamTokenResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {yandex.cloud.iam.v1.CreateIamTokenResponse} CreateIamTokenResponse
                     */
                    CreateIamTokenResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.yandex.cloud.iam.v1.CreateIamTokenResponse)
                            return object;
                        var message = new $root.yandex.cloud.iam.v1.CreateIamTokenResponse();
                        if (object.iamToken != null)
                            message.iamToken = String(object.iamToken);
                        if (object.expiresAt != null) {
                            if (typeof object.expiresAt !== "object")
                                throw TypeError(".yandex.cloud.iam.v1.CreateIamTokenResponse.expiresAt: object expected");
                            message.expiresAt = $root.google.protobuf.Timestamp.fromObject(object.expiresAt);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateIamTokenResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @static
                     * @param {yandex.cloud.iam.v1.CreateIamTokenResponse} message CreateIamTokenResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateIamTokenResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.iamToken = "";
                            object.expiresAt = null;
                        }
                        if (message.iamToken != null && message.hasOwnProperty("iamToken"))
                            object.iamToken = message.iamToken;
                        if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                            object.expiresAt = $root.google.protobuf.Timestamp.toObject(message.expiresAt, options);
                        return object;
                    };

                    /**
                     * Converts this CreateIamTokenResponse to JSON.
                     * @function toJSON
                     * @memberof yandex.cloud.iam.v1.CreateIamTokenResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateIamTokenResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateIamTokenResponse;
                })();

                return v1;
            })();

            return iam;
        })();

        return cloud;
    })();

    return yandex;
})();

module.exports = $root;
